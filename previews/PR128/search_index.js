var documenterSearchIndex = {"docs":
[{"location":"install/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Before installing Herb.jl, ensure that you have a running Julia distribution installed (Julia version 1.7 and above were tested). ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Thanks to Julia's package management, installing Herb.jl is very straightforward.  Activate the default Julia REPL using","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"julia","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"or from within one of your projects using","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"julia --project=.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"From the Julia REPL run ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"]\nadd Herb","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"or instead running","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Herb\")","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"which will both install all dependencies automatically.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"For later convenience we can also add the respective dependencies to our project, so that we do not have to write Herb.HerbGrammar every time.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"] add HerbConstraints HerbCore HerbSpecification HerbInterpret HerbGrammar HerbSearch","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"And just like this you are done! Welcome to Herb.jl!","category":"page"},{"location":"concepts/#Architecture-and-core-concepts","page":"Architecture and core concepts","title":"Architecture and core concepts","text":"","category":"section"},{"location":"HerbSearch/#HerbSearch_docs","page":"HerbSearch.jl","title":"HerbSearch.jl Documentation","text":"","category":"section"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"CurrentModule=HerbSearch","category":"page"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"Modules = [HerbSearch]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbSearch/#HerbSearch.AbstractBFSIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractBFSIterator","text":"AbstractBFSIterator <: TopDownIterator\n\nThis is the supertype for all breadth-first search iterators. It inherits all stop-criteria and traversal mechanisms from TopDownIterator.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.AbstractDFSIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractDFSIterator","text":"AbstractDFSIterator <: TopDownIterator\n\nThis is the supertype for all depth-first search iterators. It inherits all stop-criteria and from TopDownIterator, but the traversal mechanism is  implemented to perform a depth-first search.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.AbstractMHSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractMHSearchIterator","text":"AbstractMHSearchIterator <: StochasticSearchIterator\n\nThis is the supertype for all Metropolis Hastings (MH) search iterators. It inherits all behaviour from StochasticSearchIterator.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.AbstractSASearchIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractSASearchIterator","text":"AbstractSASearchIterator <: StochasticSearchIterator\n\nThis is the supertype for all SA search iterators. \n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.AbstractVLSNSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractVLSNSearchIterator","text":"AbstractVLSNSearchIterator <: StochasticSearchIterator\n\nThis is the supertype for all VLSN search iterators. \n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.BFSIterator","page":"HerbSearch.jl","title":"HerbSearch.BFSIterator","text":"@programiterator BFSIterator() <: TopDownIterator\n\nCreates a breadth-first search iterator for traversing given a grammar, starting from the given symbol. The iterator returns trees in the grammar in increasing order of size.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.DFSIterator","page":"HerbSearch.jl","title":"HerbSearch.DFSIterator","text":"@programiterator DFSIterator() <: AbstractDFSIterator\n\nCreates a depth-first search iterator for traversing a given a grammar, starting from a given symbol. The iterator returns trees in the grammar in decreasing order of size. \n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.ExpandFailureReason","page":"HerbSearch.jl","title":"HerbSearch.ExpandFailureReason","text":"@enum ExpandFailureReason limit_reached=1 already_complete=2\n\nRepresentation of the different reasons why expanding a partial tree failed.  Currently, there are two possible causes of the expansion failing:\n\nlimit_reached: The depth limit or the size limit of the partial tree would   be violated by the expansion\nalready_complete: There is no hole left in the tree, so nothing can be   expanded.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.GeneticSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.GeneticSearchIterator","text":"GeneticSearchIterator{FitnessFunction,CrossOverFunction,MutationFunction,SelectParentsFunction,EvaluationFunction} <: ProgramIterator\n\nDefines an ProgramIterator using genetic search. \n\nConsists of:\n\nexamples::Vector{<:IOExample}: a collection of examples defining the specification \nevaluation_function::EvaluationFunction: interpreter to evaluate the individual programs\npopulation_size::Int64: number of inviduals in the population\nmutation_probability::Float64: probability of mutation for each individual\nmaximum_initial_population_depth::Int64: maximum depth of trees when population is initialized \n\nend\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.MHSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.MHSearchIterator","text":"MHSearchIterator(examples::AbstractArray{<:IOExample}, cost_function::Function, evaluation_function::Function=HerbInterpret.execute_on_input)\n\nThe MHSearchIterator generates programs using the Metropolis-Hastings algorithm.  The search behaviour has the following characteristics:\n\nIt uses random_fill_propose for the propose function.\nThe accept function isprobabilistic`. \nThe temperature of the algorithm remains constant over time, ensuring a stable acceptance probability.\n\nArguments\n\nexamples::AbstractArray{<:IOExample}: An array of input-output examples used to guide the search.\ncost_function::Function: A function to evaluate the cost of the proposed programs.\nevaluation_function::Function=HerbInterpret.execute_on_input: A function that evaluates the generated program generated and produces an output. Defaults to HerbInterpret.execute_on_input.\n\nReturns\n\nAn iterator to generate programs according to the Metropolis Hastings algorithm.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.MLFSIterator","page":"HerbSearch.jl","title":"HerbSearch.MLFSIterator","text":"@programiterator MLFSIterator() <: TopDownIterator\n\nIterator that enumerates expressions in the grammar in decreasing order of probability (Only use this iterator with probabilistic grammars). Inherits all stop-criteria from TopDownIterator.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.ProgramIterator","page":"HerbSearch.jl","title":"HerbSearch.ProgramIterator","text":"abstract type ProgramIterator\n\nGeneric iterator for all possible search strategies.     All iterators are expected to have the following fields:\n\ngrammar::ContextSensitiveGrammar: the grammar to search over\nsym::Symbol: defines the start symbol from which the search should be started \nmax_depth::Int: maximum depth of program trees\nmax_size::Int: maximum number of AbstractRuleNodes of program trees\nmax_time::Int: maximum time the iterator may take\nmax_enumerations::Int: maximum number of enumerations\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.RandomIterator","page":"HerbSearch.jl","title":"HerbSearch.RandomIterator","text":"@programiterator RandomIterator() <: TopDownIterator\n\nIterates trees in the grammar in a random order.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.SASearchIterator","page":"HerbSearch.jl","title":"HerbSearch.SASearchIterator","text":"SASearchIterator(spec, cost_function, initial_temperature=1, temperature_decreasing_factor = 0.99, evaluation_function::Function=HerbInterpret.execute_on_input)\n\nReturns an enumerator that runs according to the Simulated Annealing Search algorithm.\n\nspec : array of examples\ncost_function : cost function to evaluate the programs proposed\ninitial_temperature : the starting temperature of the algorithm\ntemperature_decreasing_factor : the decreasing factor of the temperature of the time\nevaluation_function : evaluation function that evaluates the program generated and produces an output\n\nThe propose function is random_fill_propose (the same as for Metropolis Hastings). The accept function is probabilistic but takes into account the tempeerature too.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.StochasticSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.StochasticSearchIterator","text":" abstract type StochasticSearchIterator <: ProgramIterator\n\nA unified abstract type for the stochastic search algorithms Metropolis Hastings, Very Large Scale Neighbourhood and Simulated Annealing.  Iterators are customisable by overloading the followign functions:\n\nneighbourhood\npropose\ntemperature\naccept. \n\n\n\nFields\n\nexamples::Vector{IOExample} example used to check the program\ncost_function::Function. Returns the cost of the current program. It receives a list of tuples for (expected, found) and gives back a cost. \ninitial_temperature::Real = 1 \nevaluation_function::Function that evaluates the julia expressions\n\nAn iterator over all possible expressions of a grammar up to maxdepth with start symbol sym. Also inherits all stop criteria like `maxdepthfromProgramIterator`.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.SynthResult","page":"HerbSearch.jl","title":"HerbSearch.SynthResult","text":"@enum SynthResult optimal_program=1 suboptimal_program=2\n\nRepresentation of the possible results of the synth procedure.  At the moment there are two possible outcomes:\n\noptimal_program: The synthesized program satisfies the entire program specification.\nsuboptimal_program: The synthesized program does not satisfy the entire program specification, but got the best score from the evaluator.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.TopDownIterator","page":"HerbSearch.jl","title":"HerbSearch.TopDownIterator","text":"mutable struct TopDownIterator <: ProgramIterator\n\nEnumerates a context-free grammar starting at Symbol sym with respect to the grammar up to a given depth and a given size.  The exploration is done using the given priority function for derivations, and the expand function for discovered nodes. Concrete iterators may overload the following methods:\n\npriority_function\nderivation_heuristic\nhole_heuristic\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.UniformIterator","page":"HerbSearch.jl","title":"HerbSearch.UniformIterator","text":"mutable struct UniformIterator\n\nInner iterator that enumerates all candidate programs of a uniform tree.\n\nsolver: the uniform solver.\nouteriter: outer iterator that is responsible for producing uniform trees. This field is used to dispatch on the derivation_heuristic.\nunvisited_branches: for each search-node from the root to the current search-node, a list of unviisted branches.\nnsolutions: number of solutions found so far.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.UniformIterator-Tuple{UniformSolver, Union{Nothing, ProgramIterator}}","page":"HerbSearch.jl","title":"HerbSearch.UniformIterator","text":"UniformIterator(solver::UniformSolver, outeriter::ProgramIterator)\n\nConstructs a new UniformIterator that traverses solutions of the UniformSolver and is an inner iterator of an outer ProgramIterator.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.VLSNSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.VLSNSearchIterator","text":"VLSNSearchIterator(spec, cost_function, enumeration_depth = 2, evaluation_function::Function=HerbInterpret.execute_on_input) = StochasticSearchIterator(\n\nReturns an iterator that runs according to the Very Large Scale Neighbourhood Search algorithm.\n\nspec : array of examples\ncost_function : cost function to evaluate the proposed programs\nvlsn_neighbourhood_depth : the enumeration depth to search for a best program at a time\nevaluation_function : evaluation function that evaluates the program generated and produces an output\n\nThe propose function consists of all possible programs of the given enumeration_depth. The accept function accepts the program with the lowest cost according to the cost_function. The temperature value of the algorithm remains constant over time.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.@programiterator-Tuple{Any, Any}","page":"HerbSearch.jl","title":"HerbSearch.@programiterator","text":"@programiterator\n\nCanonical way of creating a program iterator. The macro automatically declares the expected fields listed in the ProgramIterator documentation. Syntax accepted by the macro is as follows (anything enclosed in square brackets is optional):     @programiterator [mutable] <IteratorName>(         <arg₁>,         ...,         <argₙ>     ) [<: <SupertypeIterator>] Note that the macro emits an assertion that the SupertypeIterator  is a subtype of ProgramIterator which otherwise throws an ArgumentError. If no supertype is given, the new iterator extends ProgramIterator directly. Each <argᵢ> may be (almost) any expression valid in a struct declaration, and they must be comma separated. One known exception is that an inner constructor must always be given using the extended function <name>(...) ... end syntax. The mutable keyword determines whether the declared struct is mutable.\n\n\n\n\n\n","category":"macro"},{"location":"HerbSearch/#Base.collect-Tuple{TopDownIterator}","page":"HerbSearch.jl","title":"Base.collect","text":"function Base.collect(iter::TopDownIterator)\n\nReturn an array of all programs in the TopDownIterator. \n\nwarning: Warning\nThis requires deepcopying programs from type StateHole to type RuleNode. If it is not needed to save all programs, iterate over the iterator manually.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{GeneticSearchIterator, HerbSearch.GeneticIteratorState}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::GeneticSearchIterator, current_state::GeneticIteratorState)\n\nIterates the search space using a genetic algorithm. Takes the iterator and the current state to mutate and crossover random inviduals. Returns the best program-so-far and the state of the iterator.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{GeneticSearchIterator}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::GeneticSearchIterator)\n\nIterates the search space using a genetic algorithm. First generates a population sampling random programs. Returns the best program-so-far, and the state of the iterator.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{HerbSearch.StochasticSearchIterator, HerbSearch.IteratorState}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::StochasticSearchIterator, current_state::IteratorState)\n\nThe algorithm that constructs the iterator of StochasticSearchIterator. It has the following structure:\n\nget a random node location -> location,dict = neighbourhood(current_program)\ncall propose on the current program getting a list of full programs\niterate through all the proposals and check if the proposed program is \"better\" than the previous one\n\"accept\" the new program by calling the accept\nreturn the new next_program\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{TopDownIterator, Tuple{Vector{<:AbstractRuleNode}, DataStructures.PriorityQueue}}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue)\n\nDescribes the iteration for a given TopDownIterator and a PriorityQueue over the grammar without enqueueing new items to the priority queue. Recursively returns the result for the priority queue.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{TopDownIterator}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::TopDownIterator)\n\nDescribes the iteration for a given TopDownIterator over the grammar. The iteration constructs a PriorityQueue first and then prunes it propagating the active constraints. Recursively returns the result for the priority queue.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.length-Tuple{ProgramIterator}","page":"HerbSearch.jl","title":"Base.length","text":"Base.length(iter::ProgramIterator)\n\nCounts and returns the number of possible programs without storing all the programs. !!! warning: modifies and exhausts the iterator\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.length-Tuple{UniformIterator}","page":"HerbSearch.jl","title":"Base.length","text":"Base.length(iter::UniformIterator)\n\nCounts and returns the number of programs without storing all the programs. !!! warning: modifies and exhausts the iterator\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.rand","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::AbstractGrammar, typ::Symbol, max_depth::Int=10)\n\nGenerates a random RuleNode of return type typ and maximum depth max_depth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#Base.rand-2","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::AbstractGrammar, max_depth::Int=10)\n\nGenerates a random RuleNode of arbitrary type and maximum depth max_depth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#Base.rand-3","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::AbstractGrammar, typ::Symbol, dmap::AbstractVector{Int}, max_depth::Int=10)\n\nGenerates a random RuleNode, i.e. an expression tree, of root type typ and maximum depth max_depth guided by a depth map dmap if possible.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch._calculate_cost-Tuple{Union{StateHole, RuleNode}, Function, AbstractVector{<:IOExample}, AbstractGrammar, Function}","page":"HerbSearch.jl","title":"HerbSearch._calculate_cost","text":"_calculate_cost(program::RuleNode, cost_function::Function, spec::AbstractVector{IOExample}, grammar::AbstractGrammar, evaluation_function::Function)\n\nReturns the cost of the program using the examples and the cost_function. It first convert the program to an expression and evaluates it on all the examples.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch._find_next_complete_tree-Tuple{Solver, DataStructures.PriorityQueue, TopDownIterator}","page":"HerbSearch.jl","title":"HerbSearch._find_next_complete_tree","text":"_find_next_complete_tree(solver::Solver, pq::PriorityQueue, iter::TopDownIterator)::Union{Tuple{RuleNode, Tuple{Vector{AbstractRuleNode}, PriorityQueue}}, Nothing}\n\nTakes a priority queue and returns the smallest AST from the grammar it can obtain from the queue or by (repeatedly) expanding trees that are in the queue. Returns nothing if there are no trees left within the depth limit.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.accept-Tuple{HerbSearch.StochasticSearchIterator, Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.accept","text":"accept(::StochasticSearchIterator, current_cost::Real, next_cost::Real, temperature::Real)\n\nBased on the current program and possible cost and temperature a program is accepted or not. Usually we would always want to accept better programs but we might get stuck if we do so. That is why some implementations of the accept function accept with a probability  costs that are worse.  cost means how different are the outcomes of the program compared to the correct outcomes. The lower the cost the better the program performs on the examples. The cost is provided by the cost_function\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.best_accept-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.best_accept","text":"best_accept(current_cost::Real, next_cost::Real, temperature::Real)\n\nReturns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns false.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature; not used.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.calculate_cost-Union{Tuple{T}, Tuple{T, Union{StateHole, RuleNode}}} where T<:HerbSearch.StochasticSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.calculate_cost","text":"calculate_cost(iter::T, program::Union{RuleNode, StateHole}) where T <: StochasticSearchIterator\n\nWrapper around _calculate_cost.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.const_temperature-Tuple{Real}","page":"HerbSearch.jl","title":"HerbSearch.const_temperature","text":"const_temperature(current_temperature::Real)\n\nReturns the temperature unchanged. This function is used by Metropolis Hastings and Very Large Neighbourhood Search algorithms.\n\nArguments\n\ncurrent_temperature::Real: the current temperature of the search.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.constructNeighbourhood-Tuple{RuleNode, AbstractGrammar}","page":"HerbSearch.jl","title":"HerbSearch.constructNeighbourhood","text":"constructNeighbourhood(current_program::RuleNode, grammar::AbstractGrammar)\n\nThe neighbourhood node location is chosen at random. The dictionary is nothing.\n\nArguments\n\ncurrent_program::RuleNode: the current program.\ngrammar::AbstractGrammar: the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, AbstractGrammar}","page":"HerbSearch.jl","title":"HerbSearch.constructNeighbourhoodRuleSubset","text":"constructNeighbourhoodRuleSubset(current_program::RuleNode, grammar::AbstractGrammar)\n\nThe neighbourhood node location is chosen at random. The dictionary is contains one entry with key \"rule_subset\" and value of type Vector{Any} being a random subset of grammar rules.\n\nArguments\n\ncurrent_program::RuleNode: the current program.\ngrammar::AbstractGrammar: the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.cross_over-Tuple{GeneticSearchIterator, RuleNode, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.cross_over","text":"cross_over(::GeneticSearchIterator, parent_1::RuleNode, parent_2::RuleNode)\n\nCombines the program from two parent individuals to create one or more offspring individuals.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.crossover_swap_children_1","text":"crossover_swap_children_1(parent_1::RuleNode, parent_2::RuleNode)\n\nPerforms a random crossover of two parents of type RuleNode. The subprograms are swapped and only one altered parent program is returned.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.crossover_swap_children_2","text":"crossover_swap_children_2(parent_1::RuleNode, parent_2::RuleNode)\n\nPerforms a random crossover of two parents of type RuleNode. The subprograms are swapped and both altered parent programs are returned.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.decreasing_temperature-Tuple{Real}","page":"HerbSearch.jl","title":"HerbSearch.decreasing_temperature","text":"decreasing_temperature(percentage::Real)\n\nReturns a function that produces a temperature decreased by percentage%. This function is used by the Simmulated Annealing algorithm.\n\nArguments\n\npercentage::Real: the percentage to decrease the temperature by.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.default_fitness-Tuple{Any, Any}","page":"HerbSearch.jl","title":"HerbSearch.default_fitness","text":"default_fitness(program, results)\n\nDefines the default fitness function taking the program and its results. Results are a vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}. As we are looking for individuals with the highest fitness function, the error is inverted. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.derivation_heuristic-Tuple{RandomIterator, Vector{Int64}}","page":"HerbSearch.jl","title":"HerbSearch.derivation_heuristic","text":"function derivation_heuristic(::RandomIterator, indices::Vector{Int})\n\nRandomly shuffles the rules.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.derivation_heuristic-Tuple{TopDownIterator, Vector{Int64}}","page":"HerbSearch.jl","title":"HerbSearch.derivation_heuristic","text":"function derivation_heuristic(::TopDownIterator, indices::Vector{Int})\n\nReturns a sorted sublist of the indices, based on which rules are most promising to fill a hole. By default, this is the identity function.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.enumerate_neighbours_propose-Tuple{Int64}","page":"HerbSearch.jl","title":"HerbSearch.enumerate_neighbours_propose","text":"enumerate_neighbours_propose(enumeration_depth::Int64)\n\nThe return function is a function that produces a list with all the subprograms with depth at most enumeration_depth.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.evaluate-Tuple{Problem{<:AbstractVector{<:IOExample}}, Any, Dict{Symbol, Any}}","page":"HerbSearch.jl","title":"HerbSearch.evaluate","text":"evaluate(problem::Problem{Vector{IOExample}}, expr::Any, tab::SymbolTable; allow_evaluation_errors::Bool=false)\n\nEvaluate the expression on the examples.\n\nOptional parameters:\n\n- `shortcircuit` - Whether to stop evaluating after finding single example fails, to speed up the [synth](@ref) procedure. If true, the returned score is an underapproximation of the actual score.\n- `allow_evaluation_errors` - Whether the search should continue if an exception is thrown in the evaluation or throw the error\n\nReturns a score in the interval [0, 1]\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.extract_name_from_argument-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.extract_name_from_argument","text":"extract_name_from_argument(ex)\n\nExtracts the name of a field declaration, otherwise throws an ArgumentError. A field declaration is either a simple field name with possible a type attached to it or a keyword argument.\n\nExample\n\nx::Int     -> x  hello      -> hello  x = 4      -> x  x::Int = 3 -> x\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.fitness-Tuple{GeneticSearchIterator, RuleNode, AbstractVector{<:Tuple{Any, Any}}}","page":"HerbSearch.jl","title":"HerbSearch.fitness","text":"fitness(::GeneticSearchIterator, program, results)\n\nAssigns a numerical value (fitness score) to each individual based on how closely it meets the desired objective.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.generate_branches-Tuple{UniformIterator}","page":"HerbSearch.jl","title":"HerbSearch.generate_branches","text":"Returns a vector of disjoint branches to expand the search tree at its current state. Example:\n\n# pseudo code\nHole(domain=[2, 4, 5], children=[\n    Hole(domain=[1, 6]), \n    Hole(domain=[1, 6])\n])\n\nIf we split on the first hole, this function will create three branches.\n\n(firsthole, 2)\n(firsthole, 4)\n(firsthole, 5)\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.get_best_program-Tuple{Array{RuleNode}, GeneticSearchIterator}","page":"HerbSearch.jl","title":"HerbSearch.get_best_program","text":"get_best_program(population::Array{RuleNode}, iter::GeneticSearchIterator)::RuleNode\n\nReturns the best program within the population with respect to the fitness function.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_leftmost","text":"heuristic_leftmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where the left-most hole always gets considered first. Returns a HoleReference once a hole is found. This is the default option for enumerators.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_leftmost_fixed_shaped_hole-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_leftmost_fixed_shaped_hole","text":"heuristic_leftmost_fixed_shaped_hole(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over FixedShapeHoles, where the left-most hole always gets considered first. Returns a HoleReference once a hole is found. This is the default option for enumerators.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_random","text":"heuristic_random(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where random holes get chosen randomly using random exploration. Returns a HoleReference once a hole is found.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_rightmost","text":"heuristic_rightmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where the right-most hole always gets considered first. Returns a HoleReference once a hole is found. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_smallest_domain","text":"heuristic_smallest_domain(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over all available holes in the unfinished AST, by considering the size of their respective domains. A domain here describes the number of possible derivations with respect to the constraints. Returns a HoleReference once a hole is found. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.hole_heuristic-Tuple{TopDownIterator, AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.hole_heuristic","text":"hole_heuristic(::TopDownIterator, node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over variable shaped holes. Returns a HoleReference once a hole is found.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.is_field_decl-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.is_field_decl","text":"is_field_decl(ex)\n\nCheck if extractname(ex) returns a name.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.is_kwdef-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.is_kwdef","text":"is_kwdeg(ex)\n\nChecks if a field declaration is a keyword argument or not.  This is called when filtering if the user arguments to the program iteartor are keyword arguments or not.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.mean_squared_error-Tuple{AbstractVector{<:Tuple{Number, Number}}}","page":"HerbSearch.jl","title":"HerbSearch.mean_squared_error","text":"mean_squared_error(results::AbstractVector{Tuple{<:Number,<:Number}})\n\nReturns the mean squared error of results.\n\nArguments\n\nresults<:AbstractVector{<:Tuple{Number,Number}}: the vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.misclassification-Tuple{T} where T<:(AbstractVector{<:Tuple{Number, Number}})","page":"HerbSearch.jl","title":"HerbSearch.misclassification","text":"misclassification(results::AbstractVector{Tuple{<:Number,<:Number}})\n\nReturns the amount of misclassified examples, i.e. how many tuples with non-matching entries are there in results.\n\nArguments\n\nresults<:AbstractVector{<:Tuple{Number,Number}}: the vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.mutate!","page":"HerbSearch.jl","title":"HerbSearch.mutate!","text":"mutate!(::GeneticSearchIterator, program::RuleNode, grammar::AbstractGrammar, max_depth::Int = 2)\n\nMutates the program of an invididual.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.mutate_random!","page":"HerbSearch.jl","title":"HerbSearch.mutate_random!","text":"mutate_random!(program::RuleNode, grammar::AbstractGrammar, max_depth::Int64 = 2)\n\nMutates the given program by inserting a randomly generated sub-program at a random location.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.neighbourhood-Tuple{HerbSearch.StochasticSearchIterator, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.neighbourhood","text":"neighbourhood(iter::StochasticSearchIterator, current_program::RuleNode)\n\nReturns a node location from the neighbourhood of the current program. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.next_solution!-Tuple{UniformIterator}","page":"HerbSearch.jl","title":"HerbSearch.next_solution!","text":"next_solution!(iter::UniformIterator)::Union{RuleNode, StateHole, Nothing}\n\nSearches for the next unvisited solution. Returns nothing if all solutions have been found already.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.priority_function-Tuple{HerbSearch.AbstractDFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}, Bool}","page":"HerbSearch.jl","title":"HerbSearch.priority_function","text":"priority_function(::AbstractDFSIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}}, isrequeued::Bool)\n\nAssigns priority such that the search tree is traversed like in a DFS manner. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.priority_function-Tuple{MLFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}, Bool}","page":"HerbSearch.jl","title":"HerbSearch.priority_function","text":"priority_function(::MLFSIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}}, isrequeued::Bool)\n\nCalculates logit for all possible derivations for a node in a tree and returns them.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.priority_function-Tuple{RandomIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}, Bool}","page":"HerbSearch.jl","title":"HerbSearch.priority_function","text":"priority_function(::RandomIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}}, isrequeued::Bool)\n\nAssigns a random priority to each state.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.priority_function-Tuple{TopDownIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}, Bool}","page":"HerbSearch.jl","title":"HerbSearch.priority_function","text":"priority_function(::TopDownIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}}, isrequeued::Bool)\n\nAssigns a priority value to a tree that needs to be considered later in the search. Trees with the lowest priority value are considered first.\n\n``: The first argument is a dispatch argument and is only used to dispatch to the correct priority function\ng: The grammar used for enumeration\ntree: The tree that is about to be stored in the priority queue\nparent_value: The priority value of the parent SolverState\nisrequeued: The same tree shape will be requeued. The next time this tree shape is considered, the UniformSolver will produce the next complete program deriving from this shape.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept","text":"probabilistic_accept(current_cost::Real, next_cost::Real, temperature::Real)\n\nProbabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program. Returns True if the new program is accepted, False otherwise.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature; not used.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept_with_temperature","text":"probabilistic_accept_with_temperature(current_cost::Real, next_cost::Real, temperature::Real)\n\nReturns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns true with the probability equal to: \n\n1  (1 + exp(delta  temperature))\n\nIn any other case, returns false.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature of the search.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept_with_temperature_fraction","text":"probabilistic_accept_with_temperature_fraction(current_cost::Real, program_to_consider_cost::Real, temperature::Real)\n\nProbabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program multiplied by the temperature. Returns True if the new program is accepted, False otherwise.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the current temperature \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.processkwarg!-Tuple{Vector{Expr}, Union{Expr, Symbol}}","page":"HerbSearch.jl","title":"HerbSearch.processkwarg!","text":"processkwarg!(keywords::Vector{Expr}, ex::Union{Expr, Symbol})\n\nChecks if ex has a default value specified, if so it returns only the field declaration,  and pushes ex to keywords. Otherwise it returns ex\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.propose-Tuple{HerbSearch.StochasticSearchIterator, Vector{Int64}, Union{Nothing, Dict{String, Any}}}","page":"HerbSearch.jl","title":"HerbSearch.propose","text":"propose(iter::StochasticSearchIterator, path::Vector{Int}, dict::Union{Nothing,Dict{String,Any}})\n\nProposes a list of programs to fill in the location provided by path and the dict.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.random_fill_propose","page":"HerbSearch.jl","title":"HerbSearch.random_fill_propose","text":"random_fill_propose(solver::Solver, path::Vector{Int}, dict::Union{Nothing,Dict{String,Any}}, nr_random=5)\n\nReturns a list with only one proposed, completely random, subprogram.\n\nArguments\n\nsolver::solver: solver\npath::Vector{Int}: path to the location to be filled.\ndict::Dict{String, Any}: the dictionary with additional arguments; not used.\nnr_random=1 : the number of random subprograms to be generated.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{<:Real}}","page":"HerbSearch.jl","title":"HerbSearch.select_chromosome","text":"select_chromosome(population::Array{RuleNode}, fitness_array::Array{<:Real})::RuleNode\n\nSelects a chromosome (individual) from the population based on a fitness array. The function uses a fitness-proportionate selection strategy, often referred to as \"roulette wheel\" selection. Assumes fitness_array to be normalized already.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{<:Real}}","page":"HerbSearch.jl","title":"HerbSearch.select_fitness_proportional_parents","text":"select_fitness_proportional_parents(population::Array{RuleNode}, fitness_array::Array{<:Real})::Tuple{RuleNode,RuleNode}\n\nSelects two parent chromosomes (individuals) from a population based on fitness-proportionate selection. The selected parents can be used for genetic crossover in the next steps of the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.select_parents-Tuple{GeneticSearchIterator, Array{RuleNode}, Array{<:Real}}","page":"HerbSearch.jl","title":"HerbSearch.select_parents","text":"select_parents(::GeneticSearchIterator, population::Array{RuleNode}, fitness_array::Array{<:Real})\n\nSelects two parents for the crossover.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.set_stateholes!-Tuple{UniformIterator, Union{StateHole, RuleNode}}","page":"HerbSearch.jl","title":"HerbSearch.set_stateholes!","text":"function set_stateholes!(iter::UniformIterator, node::Union{StateHole, RuleNode})::Vector{StateHole}\n\nDoes a dfs to retrieve all unfilled state holes in the program tree and stores them in the stateholes vector.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.synth-Tuple{Problem, ProgramIterator}","page":"HerbSearch.jl","title":"HerbSearch.synth","text":"synth(problem::Problem, iterator::ProgramIterator; shortcircuit::Bool=true, allow_evaluation_errors::Bool=false, mod::Module=Main)::Union{Tuple{RuleNode, SynthResult}, Nothing}\n\nSynthesize a program that satisfies the maximum number of examples in the problem.         - problem                 - The problem definition with IO examples         - iterator                - The iterator that will be used         - shortcircuit            - Whether to stop evaluating after finding a single example that fails, to speed up the synth procedure. If true, the returned score is an underapproximation of the actual score.         - allowevaluationerrors - Whether the search should crash if an exception is thrown in the evaluation         - maxtime                - Maximum time that the iterator will run          - maxenumerations        - Maximum number of iterations that the iterator will run          - mod                     - A module containing definitions for the functions in the grammar that do not exist in Main\n\nReturns a tuple of the rulenode representing the solution program and a synthresult that indicates if that program is optimal. synth uses evaluate which returns a score in the interval [0, 1] and checks whether that score reaches 1. If not it will return the best program so far, with the proper flag\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.temperature-Tuple{HerbSearch.StochasticSearchIterator, Real}","page":"HerbSearch.jl","title":"HerbSearch.temperature","text":"temperature(::StochasticSearchIterator, current_temperature::Real)\n\nReturns the new temperature based on the current temperature. A higher temperature means that the algorithm will explore more.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.validate_iterator-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.validate_iterator","text":"validate_iterator(iter)\n\nValidates the parameters of the iterator\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#StatsBase.sample","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(root::RuleNode, typ::Symbol, grammar::AbstractGrammar, maxdepth::Int=typemax(Int))\n\nUniformly samples a random node from the tree limited to maxdepth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-2","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(root::RuleNode, typ::Symbol, grammar::AbstractGrammar,\n                      maxdepth::Int=typemax(Int))\n\nUniformly selects a random node of the given return type typ limited by maxdepth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-3","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(::Type{NodeLoc}, root::RuleNode, maxdepth::Int=typemax(Int))\n\nUniformly selects a random node in the tree no deeper than maxdepth using reservoir sampling. Returns a NodeLoc that specifies the location using its parent so that the subtree can be replaced.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-4","page":"HerbSearch.jl","title":"StatsBase.sample","text":"StatsBase.sample(::Type{NodeLoc}, root::RuleNode, typ::Symbol, grammar::AbstractGrammar, maxdepth::Int=typemax(Int))\n\nUniformly selects a random node in the tree of a given type, specified using its parent such that the subtree can be replaced. Returns a NodeLoc.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"The HerbSearch package takes care of all operations related to searching for the desired program. This includes","category":"page"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"the functionality to sample a certain program given a grammar,\nthe implementation of several heuristic functions,\nsearching for a program that satisfies the specification, and\nimplementations of several search algorithms in terms of how they enumerate the search space\nBreadth-First Search \nDepth-First Search \nMetropolis Hastings \nVery Large Scale Neighbourhood Search \nSimulated Annealing\nGenetic Search","category":"page"},{"location":"HerbSearch/#Index","page":"HerbSearch.jl","title":"Index","text":"","category":"section"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"","category":"page"},{"location":"tutorials/working_with_interpreters/","page":"Working with custom interpreters","title":"Working with custom interpreters","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"13ec7a0f085d12f6a4dd4cbd3e681f3ea7bf61c56b3233492183d7d565cc6584\"\n    julia_version = \"1.11.3\"\n-->\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><h1>Using the Julia interpreter</h1><p>To know how good a candidate program is, program synthesisers execute them. The easiest way to execute a program is to rely on Julia itself. To leverage the Julia interpreter, you only have to ensure that your programs are valid Julia expressions. </p><p>For example, assume the following grammar.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g = @csgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g\">1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><p>Let's construct a program <code>x+3</code>, which would correspond to the following <code>RuleNode</code> representation</p></div>\n\n<pre class='language-julia'><code class='language-julia'>myprog = RuleNode(4, [RuleNode(3), RuleNode(1)])</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-myprog\">4{3,1}</pre>\n\n\n<div class=\"markdown\"><p>To run this program, we have to convert it into a Julia expression, which we can do in the following way:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>myprog_julia = rulenode2expr(myprog, g)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-myprog_julia\">:(x + 1)</pre>\n\n\n<div class=\"markdown\"><p>Now we have a valid Julia expression, but we are still missing one key ingredient: we have to inform the interpreter about the special symbols. In our case, these are <code>:x</code> and <code>:+</code>. To do so, we need to create a symbol table, which is nothing more than a dictionary mapping symbols to their values:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>symboltable = Dict{Symbol,Any}(:x =&gt; 2, :+ =&gt; +)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-symboltable\">Dict{Symbol, Any} with 2 entries:\n  :+ =&gt; +\n  :x =&gt; 2</pre>\n\n\n<div class=\"markdown\"><p>Now we can execute our program through the default interpreter available in <code>HerbInterpret</code>:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>interpret(symboltable, myprog_julia)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash103373\">3</pre>\n\n\n<div class=\"markdown\"><p>And that's it!</p></div>\n\n\n<div class=\"markdown\"><h1>Defining a custom interpreter</h1><p>A disadvantage of the default Julia interpreter is that it needs to traverse abstract syntax tree twice – once to convert it into a Julia expression, and the second time to execute that expression. Program execution is regularly the most consuming part of the entire pipeline and, by eliminating one of these steps, we can cut the runtime in half.</p><p>We can define an interpreter that works directly over <code>RuleNode</code>s.  Consider the scenario in which we want to write programs for robot navigation: imagine a 2D world in which the robot can move around and pick up a ball. The programs we could write direct the robot to go up, down, left, and right. For convenience, the programming language also offers conditionals and loops:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>grammar_robots = @csgrammar begin\n    Start = Sequence                   #1\n\n    Sequence = Operation                #2\n    Sequence = (Operation; Sequence)    #3\n    Operation = Transformation          #4\n    Operation = ControlStatement        #5\n\n    Transformation = moveRight() | moveDown() | moveLeft() | moveUp() | drop() | grab()     #6\n    ControlStatement = IF(Condition, Sequence, Sequence)        #12\n    ControlStatement = WHILE(Condition, Sequence)               #13\n\n    Condition = atTop() | atBottom() | atLeft() | atRight() | notAtTop() | notAtBottom() | notAtLeft() | notAtRight()      #14\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grammar_robots\">1: Start = Sequence\n2: Sequence = Operation\n3: Sequence = begin\n    Operation\n    Sequence\nend\n4: Operation = Transformation\n5: Operation = ControlStatement\n6: Transformation = moveRight()\n7: Transformation = moveDown()\n8: Transformation = moveLeft()\n9: Transformation = moveUp()\n10: Transformation = drop()\n11: Transformation = grab()\n12: ControlStatement = IF(Condition, Sequence, Sequence)\n13: ControlStatement = WHILE(Condition, Sequence)\n14: Condition = atTop()\n15: Condition = atBottom()\n16: Condition = atLeft()\n17: Condition = atRight()\n18: Condition = notAtTop()\n19: Condition = notAtBottom()\n20: Condition = notAtLeft()\n21: Condition = notAtRight()\n</pre>\n\n\n<div class=\"markdown\"><p>This grammar specifies a simple sequential program with instructions for the robot. A couple of example programs:</p><ul><li><p><code>moveRight(); moveLeft(); drop()</code></p></li><li><p>WHILE(notAtTop(), moveUp())</p></li></ul><p>The idea behind this programming language is that the program specifies a set of transformations over a state of the robot world. Thus, a program can only be executed over a particular state. In this case, the state represents the size of the 2D world, the current position of a robot, the current position of a ball, and whether the robot is currently holding a ball. The execution of a particular instruction acts as a state transformation: each instruction takes a state as an input, transforms it, and passes it to the subsequent instruction. For example, execution of the program <code>moveRight(); moveLeft(); drop()</code> would proceed as:</p><ol><li><p>take an input state, </p></li><li><p>pass it to the <code>moveRight()</code> instruction,</p></li><li><p>pass the output of <code>moveRight()</code> to <code>moveLeft()</code> instructions,</p></li><li><p>pass the output of <code>moveLeft()</code> to <code>drop()</code>,</p></li><li><p>return the output of <code>drop()</code>.</p></li></ol><p>The following is only one possible way to implement a custom interpreter, but it demonstrates a general template that can always be followed.</p><p>We want to implement the following function, which would take in a program in the form of a <code>RuleNode</code>, a grammar, and a starting state, and return the state obtained after executing the program:</p><pre><code>    interpret(prog::AbstractRuleNode, grammar::ContextSensitiveGrammar, state::RobotState)::RobotState</code></pre><p>As <code>RuleNode</code>s only store indices of derivation rules from the grammar, not the functions themselves, we will first pull the function call associated with every derivation rule. In Julia, this is indicated by the top-level symbol of the rules. For example, the top-level symbol for the derivation rule 6 is <code>:moveRight</code>; for rule 12, that is <code>:IF</code>.</p></div>\n\n\n<div class=\"markdown\"><p>The remaining functions follow a similar idea. (You can see the full implementation of this interpreter <a href=\"https://github.com/Herb-AI/HerbBenchmarks.jl/blob/new-robots/src/data/Robots_2020/robots_primitives.jl\">here</a>).</p></div>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/working_with_interpreters/","page":"Working with custom interpreters","title":"Working with custom interpreters","text":"EditURL = \"https://github.com/Herb-AI/Herb.jl/blob/main/docs/src/tutorials/working_with_interpreters.jl\"","category":"page"},{"location":"HerbCore/#HerbCore_docs","page":"HerbCore.jl","title":"HerbCore.jl Documentation","text":"","category":"section"},{"location":"HerbCore/","page":"HerbCore.jl","title":"HerbCore.jl","text":"CurrentModule=HerbCore","category":"page"},{"location":"HerbCore/","page":"HerbCore.jl","title":"HerbCore.jl","text":"Modules = [HerbCore]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbCore/#HerbCore.AbstractConstraint","page":"HerbCore.jl","title":"HerbCore.AbstractConstraint","text":"Represents a constraint for a AbstractGrammar. Concrete implementations can be found in HerbConstraints.jl.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.AbstractGrammar","page":"HerbCore.jl","title":"HerbCore.AbstractGrammar","text":"AbstractGrammar\n\nAbstract type representing all grammars. It is assumed that all grammar structs have at least the following attributes:\n\nrules::Vector{Any}: A list of RHS of rules (subexpressions).\ntypes::Vector{Symbol}: A list of LHS of rules (types, all symbols).\nisterminal::BitVector: A bitvector where bit i represents whether rule i is terminal.\niseval::BitVector: A bitvector where bit i represents whether rule i is an eval rule.\nbytype::Dict{Symbol,Vector{Int}}: A dictionary that maps a type to all rules of said type.\ndomains::Dict{Symbol, BitVector}: A dictionary that maps a type to a domain bitvector.  The domain bitvector has bit i set to true iff the ith rule is of this type.\nchildtypes::Vector{Vector{Symbol}}: A list of types of the children for each rule. \n\nIf a rule is terminal, the corresponding list is empty.\n\nlog_probabilities::Union{Vector{Real}, Nothing}: A list of probabilities for each rule. \n\nIf the grammar is non-probabilistic, the list can be nothing.\n\nFor concrete types, see ContextSensitiveGrammar within the HerbGrammar module.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.AbstractHole","page":"HerbCore.jl","title":"HerbCore.AbstractHole","text":"AbstractHole <: AbstractRuleNode\n\nA AbstractHole is a placeholder where certain rules from the grammar can still be applied. The domain of a AbstractHole defines which rules can be applied. The domain is a bitvector, where the ith bit is set to true if the ith rule in the grammar can be applied.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.AbstractRuleNode","page":"HerbCore.jl","title":"HerbCore.AbstractRuleNode","text":"abstract type AbstractRuleNode end\n\nAbstract type for representing expression trees. An AbstractRuleNode is expected to implement the following functions:\n\nisfilled(::AbstractRuleNode)::Bool. True iff the grammar rule this node holds is not ambiguous, i.e. has domain size 1.\nisuniform(::AbstractRuleNode)::Bool. True iff the children of this node are known.\nget_rule(::AbstractRuleNode)::Int. Returns the index of the grammar rule it represents.\nget_children(::AbstractRuleNode)::Vector{AbstractRuleNode}. Returns the children of this node.\n\nExpression trees consist of RuleNodes and AbstractHoles.\n\nA RuleNode represents a certain production rule in the AbstractGrammar.\nA AbstractHole is a placeholder where certain rules in the grammar still can be applied. \n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.AbstractUniformHole","page":"HerbCore.jl","title":"HerbCore.AbstractUniformHole","text":"Hole <: AbstractHole\n\nAn AbstractUniformHole is a placeholder where certain rules from the grammar can still be applied, but all rules in the domain are required to have the same childtypes.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.Hole","page":"HerbCore.jl","title":"HerbCore.Hole","text":"Hole <: AbstractHole\n\ndomain: A bitvector, where the ith bit is set to true if the ith rule in the grammar can be applied.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.HoleReference","page":"HerbCore.jl","title":"HerbCore.HoleReference","text":"HoleReference\n\nContains a hole and the path to the hole from the root of the tree.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.RuleNode","page":"HerbCore.jl","title":"HerbCore.RuleNode","text":"RuleNode <: AbstractRuleNode\n\nA RuleNode represents a node in an expression tree. Each node corresponds to a certain rule in the AbstractGrammar. A RuleNode consists of:\n\nind: The index of the rule in the AbstractGrammar which this node is representing.\n_val: Field for caching evaluations of RuleNodes, preventing multiple unnecessary evaluations. The field can be used to store any needed infromation.\nchildren: The children of this node in the expression tree\n\ncompat: Compat\nEvaluate immediately functionality is not yet supported by most of Herb.jl.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.RuleNode-Tuple{Int64, Any}","page":"HerbCore.jl","title":"HerbCore.RuleNode","text":"RuleNode(ind::Int, _val::Any)\n\nCreate a RuleNode for the AbstractGrammar rule with index ind,  _val as immediately evaluated value and no children\n\nwarning: Warning\nOnly use this constructor if you are absolutely certain that a rule is terminal and cannot have children. Use [RuleNode(ind::Int, grammar::AbstractGrammar)] for rules that might have children. In general, AbstractHoles should be used as a placeholder when the children of a node are not yet known.   \n\ncompat: Compat\nEvaluate immediately functionality is not yet supported by most of Herb.jl.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.RuleNode-Tuple{Int64, Vector{<:AbstractRuleNode}}","page":"HerbCore.jl","title":"HerbCore.RuleNode","text":"RuleNode(ind::Int, children::Vector{AbstractRuleNode})\n\nCreate a RuleNode for the AbstractGrammar rule with index ind and children as subtrees.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.UniformHole","page":"HerbCore.jl","title":"HerbCore.UniformHole","text":"UniformHole <: AbstractHole\n\ndomain: A bitvector, where the ith bit is set to true if the ith rule in the grammar can be applied. All rules in the domain are required to have the same childtypes.\nchildren: The children of this hole in the expression tree.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.@rulenode-Tuple{Union{Expr, Integer}}","page":"HerbCore.jl","title":"HerbCore.@rulenode","text":"@rulenode\n\nConstruct a RuleNode using the shorthand notation RuleNodes are printed with using Base.show. Does not support AbstractHoles.\n\nExamples\n\njulia> @rulenode 1{4{5,6},1{2,3}}\n1{4{5,6},1{2,3}}\n\njulia> @rulenode 1\n1\n\njulia> @rulenode 1{2, 3}\n1{2,3}\n\n\n\n\n\n","category":"macro"},{"location":"HerbCore/#Base.isless-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbCore.jl","title":"Base.isless","text":"Base.isless(rn₁::AbstractRuleNode, rn₂::AbstractRuleNode)::Bool\n\nCompares two RuleNodes. Returns true if the left RuleNode is less than the right RuleNode. Order is determined from the index of the RuleNodes. If both RuleNodes have the same index, a depth-first search is performed in both RuleNodes until nodes with a different index are found.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#Base.length-Tuple{AbstractRuleNode}","page":"HerbCore.jl","title":"Base.length","text":"Base.length(root::RuleNode)\n\nReturn the number of nodes in the tree rooted at root.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.contains_hole-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.contains_hole","text":"contains_hole(rn::RuleNode) = any(contains_hole(c) for c ∈ rn.children)\n\nChecks if an AbstractRuleNode tree contains a AbstractHole.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.contains_nonuniform_hole-Tuple{AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.contains_nonuniform_hole","text":"contains_nonuniform_hole(rn::RuleNode)\n\nChecks if an AbstractRuleNode tree contains a Hole.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.depth-Tuple{AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.depth","text":"depth(root::RuleNode)::Int\n\nReturn the depth of the AbstractRuleNode tree rooted at root. Holes do count towards the depth.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_children-Tuple{AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.get_children","text":"get_children(rn::AbstractRuleNode)\n\nReturns the children of the given AbstractRuleNode\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_node_at_location-Tuple{AbstractRuleNode, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.get_node_at_location","text":"get_node_at_location(root::AbstractRuleNode, location::Vector{Int})\n\nRetrieves a RuleNode at the given location by reference.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_node_at_location-Tuple{Hole, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.get_node_at_location","text":"get_node_at_location(root::Hole, location::Vector{Int})\n\nRetrieves the current hole, if location is this very hole. Throws error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_path-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.get_path","text":"get_path(root::AbstractRuleNode, node::AbstractRuleNode)\n\nReturns the path from the root to the targetnode. Returns nothing if no path exists.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_rule-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.get_rule","text":"get_rule(rn::AbstractRuleNode)\n\nReturns the index of the rule that this AbstractRuleNode represents\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_rulesequence-Tuple{RuleNode, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.get_rulesequence","text":"get_rulesequence(node::RuleNode, path::Vector{Int})\n\nExtract the derivation sequence from a path (sequence of child indices) and an AbstractRuleNode. If the path is deeper than the deepest node, it returns what it has.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.hasdynamicvalue-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.hasdynamicvalue","text":"function hasdynamicvalue(rn::AbstractRuleNode)::Bool\n\nReturns true iff the rule has a _val field set up.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.have_same_shape-Tuple{Any, Any}","page":"HerbCore.jl","title":"HerbCore.have_same_shape","text":"have_same_shape(node1::AbstractRuleNode, node2::AbstractRuleNode)\n\nReturns true iff node1 and node2 have the same shape Example: RuleNode(3, [ \tRuleNode(1), \tRuleNode(1) ]) and RuleNode(9, [ \tRuleNode(2), \tHole(domain) ]) have the same shape: 1 root with 2 children.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.isfilled-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.isfilled","text":"isfilled(node::AbstractRuleNode)::Bool\n\nReturns whether the [AbstractRuleNode] holds a single rule. This is always the case for RuleNodes. Holes are considered to be \"filled\" iff their domain size is exactly 1.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.isuniform-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.isuniform","text":"isuniform(rn::AbstractRuleNode)\n\nReturns true iff the children of the AbstractRuleNode are known.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.node_depth-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.node_depth","text":"node_depth(root::AbstractRuleNode, node::AbstractRuleNode)::Int\n\nReturn the depth of node for an AbstractRuleNode tree rooted at root. Depth is 1 when root == node.\n\nwarning: Warning\nnode must be a subtree of root in order for this function to work.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.number_of_holes-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.number_of_holes","text":"number_of_holes(rn::AbstractRuleNode)::Int\n\nRecursively counts the number of holes in an AbstractRuleNode\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.rulesoftype-Tuple{RuleNode, Set{Int64}}","page":"HerbCore.jl","title":"HerbCore.rulesoftype","text":"rulesoftype(node::RuleNode, ruleset::Set{Int})\n\nReturns every rule in the ruleset that is also used in the AbstractRuleNode tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.rulesonleft-Tuple{RuleNode, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.rulesonleft","text":"rulesonleft(expr::RuleNode, path::Vector{Int})::Set{Int}\n\nFinds all rules that are used in the left subtree defined by the path.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.swap_node","text":"swap_node(expr::AbstractRuleNode, new_expr::AbstractRuleNode, path::Vector{Int})\n\nReplace a node in expr, specified by path, with new_expr. Path is a sequence of child indices, starting from the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}","page":"HerbCore.jl","title":"HerbCore.swap_node","text":"swap_node(expr::RuleNode, node::RuleNode, child_index::Int, new_expr::RuleNode)\n\nReplace child i of a node, a part of larger expr, with new_expr.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#Index","page":"HerbCore.jl","title":"Index","text":"","category":"section"},{"location":"HerbCore/","page":"HerbCore.jl","title":"HerbCore.jl","text":"","category":"page"},{"location":"HerbGrammar/#HerbGrammar_docs","page":"HerbGrammar.jl","title":"HerbGrammar.jl Documentation","text":"","category":"section"},{"location":"HerbGrammar/","page":"HerbGrammar.jl","title":"HerbGrammar.jl","text":"CurrentModule=HerbGrammar","category":"page"},{"location":"HerbGrammar/","page":"HerbGrammar.jl","title":"HerbGrammar.jl","text":"Modules = [HerbGrammar]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbGrammar/#HerbGrammar.ContextSensitiveGrammar","page":"HerbGrammar.jl","title":"HerbGrammar.ContextSensitiveGrammar","text":"ContextSensitiveGrammar <: AbstractGrammar\n\nRepresents a context-sensitive grammar. Extends AbstractGrammar with constraints.\n\nConsists of:\n\nrules::Vector{Any}: A list of RHS of rules (subexpressions).\ntypes::Vector{Symbol}: A list of LHS of rules (types, all symbols).\nisterminal::BitVector: A bitvector where bit i represents whether rule i is terminal.\niseval::BitVector: A bitvector where bit i represents whether rule i is an eval rule.\nbytype::Dict{Symbol,Vector{Int}}: A dictionary that maps a type to all rules of said type.\ndomains::Dict{Symbol, BitVector}: A dictionary that maps a type to a domain bitvector.  The domain bitvector has bit i set to true iff the ith rule is of this type.\nchildtypes::Vector{Vector{Symbol}}: A list of types of the children for each rule.  If a rule is terminal, the corresponding list is empty.\nbychildtypes::Vector{BitVector}: A bitvector of rules that share the same childtypes for each rule\nlog_probabilities::Union{Vector{Real}, Nothing}: A list of probabilities for each rule.  If the grammar is non-probabilistic, the list can be nothing.\nconstraints::Vector{AbstractConstraint}: A list of constraints that programs in this grammar have to abide.\n\nUse the @csgrammar macro to create a ContextSensitiveGrammar object. Use the @pcsgrammar macro to create a ContextSensitiveGrammar object with probabilities.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.NodeLoc","page":"HerbGrammar.jl","title":"HerbGrammar.NodeLoc","text":"NodeLoc A helper struct that points to a node in the tree via its parent such that the child can be easily swapped out. If i is 0 the node pointed to is the root node and parent is the node itself.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.SymbolTable","page":"HerbGrammar.jl","title":"HerbGrammar.SymbolTable","text":"SymbolTable\n\nType alias for a Dict that maps terminal symbols in the AbstractGrammar to their Julia interpretation.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.@cfgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@cfgrammar","text":"@cfgrammar\n\nThis macro is deprecated and will be removed in future versions. Use @csgrammar instead.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#HerbGrammar.@csgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@csgrammar","text":"@csgrammar\n\nA macro for defining a ContextSensitiveGrammar.  AbstractConstraints can be added afterwards using the addconstraint! function.\n\nExample usage:\n\ngrammar = @csgrammar begin\n\tR = x\n\tR = 1 | 2\n\tR = R + R\nend\n\nSyntax:\n\nLiterals: Symbols that are already defined in Julia are considered literals, such as 1, 2, or π. For example: R = 1.\nVariables: A variable is a symbol that is not a nonterminal symbol and not already defined in Julia. For example: R = x.\nFunctions: Functions and infix operators that are defined in Julia or the Main module can be used  with the default evaluator. For example: R = R + R, R = f(a, b).\nCombinations: Multiple rules can be defined on a single line in the grammar definition using the | symbol. For example: R = 1 | 2 | 3.\nIterators: Another way to define multiple rules is by providing a Julia iterator after a | symbol. For example: R = |(1:9).\n\nRelated:\n\n@pcsgrammar uses a similar syntax to create probabilistic ContextSensitiveGrammars.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#HerbGrammar.@pcsgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@pcsgrammar","text":"@pcsgrammar\n\nA macro for defining a probabilistic ContextSensitiveGrammar. \n\nExample usage:\n\ngrammar = @pcsgrammar begin\n\t0.5 : R = x\n\t0.3 : R = 1 | 2\n\t0.2 : R = R + R\nend\n\nSyntax:\n\nThe syntax of rules is identical to the syntax used by @csgrammar:\n\nLiterals: Symbols that are already defined in Julia are considered literals, such as 1, 2, or π. For example: R = 1.\nVariables: A variable is a symbol that is not a nonterminal symbol and not already defined in Julia. For example: R = x.\nFunctions: Functions and infix operators that are defined in Julia or the Main module can be used  with the default evaluator. For example: R = R + R, R = f(a, b).\nCombinations: Multiple rules can be defined on a single line in the grammar definition using the | symbol. For example: R = 1 | 2 | 3.\nIterators: Another way to define multiple rules is by providing a Julia iterator after a | symbol. For example: R = |(1:9).\n\nEvery rule is also prefixed with a probability. Rules and probabilities are separated using the : symbol. If multiple rules are defined on a single line, the probability is equally divided between the rules. The sum of probabilities for all rules of a certain non-terminal symbol should be equal to 1.  The probabilities are automatically scaled if this isn't the case.\n\nRelated:\n\n@csgrammar uses a similar syntax to create non-probabilistic ContextSensitiveGrammars.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#Base.get-Tuple{AbstractRuleNode, NodeLoc}","page":"HerbGrammar.jl","title":"Base.get","text":"get(root::AbstractRuleNode, loc::NodeLoc) Obtain the node pointed to by loc.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#Base.insert!-Tuple{RuleNode, NodeLoc, RuleNode}","page":"HerbGrammar.jl","title":"Base.insert!","text":"insert!(loc::NodeLoc, rulenode::RuleNode) Replaces the subtree pointed to by loc with the given rulenode.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.add_rule!-Tuple{AbstractGrammar, AbstractRuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.add_rule!","text":"add_rule(grammar, tree)\n\nExtends a given grammar with an AbstractRuleNode. The type of the rule is inferred from the root-type.\n\nArguments\n\ngrammar::AbstractGrammar: the grammar to extend\ntree::RuleNode: the Herb tree\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.add_rule!-Tuple{AbstractGrammar, Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.add_rule!","text":"add_rule!(g::AbstractGrammar, e::Expr)\n\nAdds a rule to the grammar. \n\nUsage:\n\n    add_rule!(grammar, :(\"Real = Real + Real\"))\n\nThe syntax is identical to the syntax of @csgrammar and @cfgrammar, but only single rules are supported.\n\nwarning: Warning\nCalls to this function are ignored if a rule is already in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.add_rule!-Tuple{AbstractGrammar, Real, Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.add_rule!","text":"add_rule!(g::AbstractGrammar, p::Real, e::Expr)\n\nAdds a probabilistic derivation rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.addconstraint!-Tuple{ContextSensitiveGrammar, AbstractConstraint}","page":"HerbGrammar.jl","title":"HerbGrammar.addconstraint!","text":"addconstraint!(grammar::ContextSensitiveGrammar, c::AbstractConstraint)\n\nAdds a AbstractConstraint to a ContextSensitiveGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.child_types-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.child_types","text":"child_types(grammar::AbstractGrammar, rule_index::Int)\n\nReturns the types of the children (nonterminals) of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.child_types-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.child_types","text":"child_types(grammar::AbstractGrammar, node::RuleNode)\n\nReturns the list of child types (nonterminal symbols) in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.cleanup_removed_rules!-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.cleanup_removed_rules!","text":"cleanup_removed_rules!(g::AbstractGrammar)\n\nRemoves any placeholders for previously deleted rules.  This means that indices get shifted.\n\nwarning: Warning\nWhen indices are shifted, this grammar can no longer be used to interpret  AbstractRuleNode trees created before the call to this function. These trees become meaningless. \n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.clearconstraints!-Tuple{ContextSensitiveGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.clearconstraints!","text":"Clear all constraints from the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.containedin-Tuple{Vector, Vector}","page":"HerbGrammar.jl","title":"HerbGrammar.containedin","text":"containedin(vec1::Vector, vec2::Vector)\n\nChecks if elements of vec1 are contained in vec2 in the same order (possibly with elements in between)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.contains_returntype","page":"HerbGrammar.jl","title":"HerbGrammar.contains_returntype","text":"contains_returntype(node::RuleNode, grammar::AbstractGrammar, sym::Symbol, maxdepth::Int=typemax(Int))\n\nReturns true if the tree rooted at node contains at least one node at depth less than maxdepth with the given return type or nonterminal symbol.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.expr2csgrammar-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2csgrammar","text":"expr2csgrammar(ex::Expr)::ContextSensitiveGrammar\n\nA function for converting an Expr to a ContextSensitiveGrammar. If the expression is hardcoded, you should use the @csgrammar macro. Only expressions in the correct format (see @csgrammar) can be converted.\n\nExample usage:\n\ngrammar = expr2csgrammar(\n\tbegin\n\t\tR = x\n\t\tR = 1 | 2\n\t\tR = R + R\n\tend\n)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2pcsgrammar-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2pcsgrammar","text":"Function for converting an Expr to a ContextSensitiveGrammar with probabilities. If the expression is hardcoded, you should use the @pcsgrammar macro. Only expressions in the correct format (see @pcsgrammar) can be converted.\n\nExample usage:\n\ngrammar = expr2pcsgrammar(\n\tbegin\n\t\t0.5 : R = x\n\t\t0.3 : R = 1 | 2\n\t\t0.2 : R = R + R\n\tend\n)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2rulenode-Tuple{Expr, AbstractGrammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2rulenode","text":"expr2rulenode(expr::Expr, grammar::AbstractGrammar, startSymbol::Symbol)\n\nConverts an expression into a AbstractRuleNode corresponding to the rule definitions in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2rulenode-Tuple{Expr, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2rulenode","text":"expr2rulenode(expr::Expr, grammar::AbstractGrammar)\n\nConverts an expression into a AbstractRuleNode corresponding to the rule definitions in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2rulenode-Tuple{Symbol, AbstractGrammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2rulenode","text":"expr2rulenode(expr::Symbol, grammar::AbstractGrammar, startSymbol::Symbol)\n\nConverts an expression into a AbstractRuleNode corresponding to the rule definitions in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2rulenode-Tuple{Union{Number, Symbol}, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2rulenode","text":"expr2rulenode(expr::Symbol, grammar::AbstractGrammar)\n\nConverts an expression into a AbstractRuleNode corresponding to the rule definitions in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_childtypes-Tuple{Any, AbstractVector{Symbol}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_childtypes","text":"get_childtypes(rule::Any, types::AbstractVector{Symbol})\n\nReturns the child types/nonterminals of a production rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_domain-Tuple{AbstractGrammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.get_domain","text":"get_domain(g::AbstractGrammar, type::Symbol)::BitVector\n\nReturns the domain for the hole of a certain type as a BitVector of the same length as the number of  rules in the grammar. Bit i is set to true iff rule i is of type type.\n\ninfo: Info\nSince this function can be intensively used when exploring a program space defined by a grammar, the outcomes of this function are precomputed and stored in the domains field in a AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_domain-Tuple{AbstractGrammar, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_domain","text":"get_domain(g::AbstractGrammar, rules::Vector{Int})::BitVector\n\nTakes a domain rules defined as a vector of ints and converts it to a domain defined as a BitVector.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_rulesequence-Tuple{RuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_rulesequence","text":"get_rulesequence(node::RuleNode, path::Vector{Int})\n\nExtract the derivation sequence from a path (sequence of child indices) and an AbstractRuleNode. If the path is deeper than the deepest node, it returns what it has.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.grammar2symboltable","page":"HerbGrammar.jl","title":"HerbGrammar.grammar2symboltable","text":"grammar2symboltable(grammar::AbstractGrammar, mod::Module=Main)\n\nReturns a SymbolTable populated with a mapping from symbols in the  AbstractGrammar to symbols in module mod or Main, if defined.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.iscomplete-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.iscomplete","text":"iscomplete(grammar::AbstractGrammar, node::RuleNode)\n\nReturns true if the expression represented by the RuleNode is a complete expression,  meaning that it is fully defined and doesn't have any Holes.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(grammar::AbstractGrammar, index::Int)::Bool\n\nReturns true if the production rule at rule_index contains the special _() eval function.\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(grammar::AbstractGrammar)::Bool\n\nReturns true if any production rules in grammar contain the special _() eval function.\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(rule)\n\nReturns true if the rule is the special evaluate immediately function, i.e., _()\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isprobabilistic-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.isprobabilistic","text":"isprobabilistic(grammar::AbstractGrammar)::Bool\n\nFunction returns whether a AbstractGrammar is probabilistic.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{AbstractGrammar, AbstractRuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(grammar::AbstractGrammar, node::AbstractRuleNode)::Bool\n\nReturns true if the production rule used by node is terminal, i.e., does not contain any nonterminal symbols.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(grammar::AbstractGrammar, rule_index::Int)::Bool\n\nReturns true if the production rule at rule_index is terminal, i.e., does not contain any nonterminal symbols.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{Any, AbstractVector{Symbol}}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(rule::Any, types::AbstractVector{Symbol})\n\nReturns true if the rule is terminal, i.e., it does not contain any of the types in the provided vector. For example, :(x) is terminal, and :(1+1) is terminal, but :(Real + Real) is typically not.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, Int64, Vararg{Module}}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::AbstractGrammar, ind::Int, mod::Module)::Bool\n\nReturn true if the rule with index ind represents a variable.\n\nTaking into account the symbols defined in the given module(s).\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::AbstractGrammar, ind::Int)::Bool\n\nReturn true if the rule with index ind represents a variable.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, RuleNode, Vararg{Module}}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::AbstractGrammar, node::RuleNode, mod::Module)::Bool\n\nReturn true if the rule used by node represents a variable.\n\nTaking into account the symbols defined in the given module(s).\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::AbstractGrammar, node::RuleNode)::Bool\n\nReturn true if the rule used by node represents a variable in a program (essentially, an input to the program)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.log_probability-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.log_probability","text":"log_probability(grammar::AbstractGrammar, index::Int)::Real\n\nReturns the log probability for the rule at index in the grammar.\n\nwarning: Warning\nIf the grammar is not probabilistic, a warning is displayed, and a uniform probability is assumed.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.max_arity-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.max_arity","text":"max_arity(grammar::AbstractGrammar)::Int\n\nReturns the maximum arity (number of children) over all production rules in the AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.merge_grammars!-Tuple{AbstractGrammar, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.merge_grammars!","text":"merge_grammars!(merge_to::AbstractGrammar, merge_from::AbstractGrammar)\n\nAdds all rules and constraints from merge_from to merge_to.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.mindepth-Tuple{AbstractGrammar, Symbol, AbstractVector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.mindepth","text":"mindepth(grammar::AbstractGrammar, typ::Symbol, dmap::AbstractVector{Int})\n\nReturns the minimum depth achievable for a given nonterminal symbol. The minimum depth is the depth of the lowest tree that can be made using typ  as a start symbol. dmap can be obtained from mindepth_map.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.mindepth_map-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.mindepth_map","text":"mindepth_map(grammar::AbstractGrammar)\n\nReturns the minimum depth achievable for each production rule in the AbstractGrammar. In other words, this function finds the depths of the lowest trees that can be made  using each of the available production rules as a root.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nchildren-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.nchildren","text":"nchildren(grammar::AbstractGrammar, rule_index::Int)::Int\n\nReturns the number of children (nonterminals) of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nchildren-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.nchildren","text":"nchildren(grammar::AbstractGrammar, node::RuleNode)::Int\n\nReturns the number of children in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nonterminals-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.nonterminals","text":"nonterminals(grammar::AbstractGrammar)::Vector{Symbol}\n\nReturns a list of the nonterminals or types in the AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.normalize!","page":"HerbGrammar.jl","title":"HerbGrammar.normalize!","text":"A function for normalizing the probabilities of a probabilistic ContextSensitiveGrammar. If the optional type argument is provided, only the rules of that type are normalized.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.parse_probabilistic_rule-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.parse_probabilistic_rule","text":"Parses a single (potentially shorthand) derivation rule of a probabilistic ContextSensitiveGrammar. Returns nothing if the rule is not probabilistic, otherwise a Tuple of its type and a  Vector of probability-rule pairs it expands into.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.probability-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.probability","text":"probability(grammar::AbstractGrammar, index::Int)::Real\n\nReturn the probability for a rule in the grammar. Use log_probability whenever possible.\n\nwarning: Warning\nIf the grammar is not probabilistic, a warning is displayed, and a uniform probability is assumed.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.read_csg","page":"HerbGrammar.jl","title":"HerbGrammar.read_csg","text":"read_csg(grammarpath::AbstractString, constraintspath::OptionalPath=nothing)::ContextSensitiveGrammar\n\nReads a ContextSensitiveGrammar from the files at grammarpath and constraintspath.\n\ndanger: Danger\nOnly open trusted grammars.  Parts of the grammar can be passed to Julia's eval function.  \n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.read_pcsg","page":"HerbGrammar.jl","title":"HerbGrammar.read_pcsg","text":"read_pcsg(grammarpath::AbstractString, constraintspath::OptionalPath=nothing)::ContextSensitiveGrammar\n\nReads a probabilistic ContextSensitiveGrammar from the files at grammarpath and constraintspath.\n\ndanger: Danger\nOnly open trusted grammars.  Parts of the grammar can be passed to Julia's eval function.  \n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.remove_rule!-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.remove_rule!","text":"remove_rule!(g::AbstractGrammar, idx::Int)\n\nRemoves the rule corresponding to idx from the grammar.  In order to avoid shifting indices, the rule is replaced with nothing, and all other data structures are updated accordingly.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.return_type-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.return_type","text":"return_type(grammar::AbstractGrammar, rule_index::Int)::Symbol\n\nReturns the type of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.return_type-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.return_type","text":"return_type(grammar::AbstractGrammar, node::RuleNode)\n\nGives the return type or nonterminal symbol in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.return_type-Tuple{AbstractGrammar, UniformHole}","page":"HerbGrammar.jl","title":"HerbGrammar.return_type","text":"return_type(grammar::AbstractGrammar, hole::UniformHole)\n\nGives the return type or nonterminal symbol in the production rule used by hole.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.root_node_loc-Tuple{RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.root_node_loc","text":"rootnodeloc(root::RuleNode) Returns a NodeLoc pointing to the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulenode2expr-Tuple{AbstractRuleNode, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.rulenode2expr","text":"rulenode2expr(rulenode::AbstractRuleNode, grammar::AbstractGrammar)\n\nConverts an AbstractRuleNode into a Julia expression corresponding to the rule definitions in the grammar. The returned expression can be evaluated with Julia semantics using eval().\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulenode_log_probability-Tuple{RuleNode, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.rulenode_log_probability","text":"Calculates the log probability associated with a rulenode in a probabilistic grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, AbstractGrammar, Symbol, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesoftype","text":"rulesoftype(node::RuleNode, grammar::AbstractGrammar, ruletype::Symbol, ignoreNode::RuleNode)\n\nReturns every rule of nonterminal symbol ruletype that is also used in the AbstractRuleNode tree, but not in the ignoreNode subtree.\n\nwarning: Warning\nThe ignoreNode must be a subtree of node for it to have an effect.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, AbstractGrammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesoftype","text":"rulesoftype(node::RuleNode, grammar::AbstractGrammar, ruletype::Symbol)\n\nReturns every rule of nonterminal symbol ruletype that is also used in the AbstractRuleNode tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Set{Int64}, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesoftype","text":"rulesoftype(node::RuleNode, ruleset::Set{Int}, ignoreNode::RuleNode)\n\nReturns every rule in the ruleset that is also used in the AbstractRuleNode tree, but not in the ignoreNode subtree.\n\nwarning: Warning\nThe ignoreNode must be a subtree of node for it to have an effect.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesonleft-Tuple{RuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesonleft","text":"rulesonleft(node::RuleNode, path::Vector{Int})::Set{Int}\n\nFinds all rules that are used in the left subtree defined by the path.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.store_csg","page":"HerbGrammar.jl","title":"HerbGrammar.store_csg","text":"store_csg(g::ContextSensitiveGrammar, grammarpath::AbstractString, constraintspath::OptionalPath=nothing)\n\nWrites a ContextSensitiveGrammar to the files at grammarpath and constraintspath. The grammarpath file will contain a ContextSensitiveGrammar definition, and the constraintspath file will contain the AbstractConstraints of the ContextSensitiveGrammar.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.subsequenceof-Tuple{Vector{Int64}, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.subsequenceof","text":"subsequenceof(vec1::Vector{Int}, vec2::Vector{Int})\n\nChecks if vec1 is a subsequence of vec2.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.swap_node","text":"swap_node(expr::AbstractRuleNode, new_expr::AbstractRuleNode, path::Vector{Int})\n\nReplace a node in expr, specified by path, with new_expr. Path is a sequence of child indices, starting from the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.swap_node","text":"swap_node(expr::RuleNode, node::RuleNode, child_index::Int, new_expr::RuleNode)\n\nReplace child i of a node, a part of larger expr, with new_expr.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#Index","page":"HerbGrammar.jl","title":"Index","text":"","category":"section"},{"location":"HerbGrammar/","page":"HerbGrammar.jl","title":"HerbGrammar.jl","text":"","category":"page"},{"location":"HerbSpecification/#HerbSpecification_docs","page":"HerbSpecification.jl","title":"HerbSpecification.jl Documentation","text":"","category":"section"},{"location":"HerbSpecification/","page":"HerbSpecification.jl","title":"HerbSpecification.jl","text":"CurrentModule=HerbSpecification","category":"page"},{"location":"HerbSpecification/","page":"HerbSpecification.jl","title":"HerbSpecification.jl","text":"Modules = [HerbSpecification]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbSpecification/#HerbSpecification.AbstractDependentTypeSpecification","page":"HerbSpecification.jl","title":"HerbSpecification.AbstractDependentTypeSpecification","text":"struct AbstractDependentTypeSpecification <: AbstractTypeSpecification\n\nDefines a specification through dependent types. Needs a concrete type checker as oracle.\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.AgdaSpecification","page":"HerbSpecification.jl","title":"HerbSpecification.AgdaSpecification","text":"struct AgdaSpecification <: AbstractDependentTypeSpecification\n\nDefines a specification \n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.IOExample","page":"HerbSpecification.jl","title":"HerbSpecification.IOExample","text":"struct IOExample\n\nAn input-output example. in is a Dict of {Symbol,Any} where the symbol represents a variable in a program. out can be anything.\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.MetricProblem","page":"HerbSpecification.jl","title":"HerbSpecification.MetricProblem","text":"struct MetricProblem{T <: Vector{IOExample}}\n\nProgram synthesis problem defined by an specification and a metric. The specification has to be based on input/output examples, while the function needs to return a numerical value.\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.Problem","page":"HerbSpecification.jl","title":"HerbSpecification.Problem","text":"struct Problem\n\nProgram synthesis problem defined by an AbstractSpecifications. Has a name and a specification of type T.\n\nwarning: Warning\nPlease care that concrete Problem types with different values of T are never subtypes of each other. \n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.SMTSpecification","page":"HerbSpecification.jl","title":"HerbSpecification.SMTSpecification","text":"struct SMTSpecification <: AbstractFormalSpecification\n\nA specification based on a logical formula defined by a SMT solver.\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.Trace","page":"HerbSpecification.jl","title":"HerbSpecification.Trace","text":"struct Trace\n\nA trace defining a wanted program execution for program synthesis.  @TODO combine with Gen.jl\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#Base.getindex-Tuple{Problem{<:AbstractVector{<:IOExample}}, Any}","page":"HerbSpecification.jl","title":"Base.getindex","text":"Base.getindex(p::Problem{Vector{IOExample}}, indices)\n\nOverwrite Base.getindex to allow for slicing of input/output-based problems.\n\n\n\n\n\n","category":"method"},{"location":"HerbSpecification/#Index","page":"HerbSpecification.jl","title":"Index","text":"","category":"section"},{"location":"HerbSpecification/","page":"HerbSpecification.jl","title":"HerbSpecification.jl","text":"","category":"page"},{"location":"HerbConstraints/#HerbConstraints_docs","page":"HerbConstraints.jl","title":"HerbConstraints.jl Documentation","text":"","category":"section"},{"location":"HerbConstraints/","page":"HerbConstraints.jl","title":"HerbConstraints.jl","text":"CurrentModule=HerbConstraints","category":"page"},{"location":"HerbConstraints/","page":"HerbConstraints.jl","title":"HerbConstraints.jl","text":"Modules = [HerbConstraints]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbConstraints/#HerbConstraints.AbstractGrammarConstraint","page":"HerbConstraints.jl","title":"HerbConstraints.AbstractGrammarConstraint","text":"abstract type AbstractGrammarConstraint <: AbstractConstraint\n\nAbstract type representing all user-defined constraints. Each grammar constraint has a related AbstractLocalConstraint that is responsible for propagating the constraint at a specific location in the tree. Grammar constraints should implement on_new_node to post a AbstractLocalConstraint at that new node\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.AbstractLocalConstraint","page":"HerbConstraints.jl","title":"HerbConstraints.AbstractLocalConstraint","text":"abstract type AbstractLocalConstraint <: AbstractConstraint\n\nAbstract type representing all local constraints. Each local constraint contains a path that points to a specific location in the tree at which the constraint applies.\n\nEach local constraint should implement a propagate!-function. Inside the propagate! function, the constraint can use the following solver functions:\n\nremove!: Elementary tree manipulation. Removes a value from a domain. (other tree manipulations are: remove_above!, remove_below!, remove_all_but!)\ndeactivate!: Prevent repropagation. Call this as soon as the constraint is satisfied.\nset_infeasible!: Report a non-trivial inconsistency. Call this if the constraint can never be satisfied. An empty domain is considered a trivial inconsistency, such inconsistencies are already handled by tree manipulations.\nisfeasible: Check if the current tree is still feasible. Return from the propagate function, as soon as infeasibility is detected.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.AbstractStateManager","page":"HerbConstraints.jl","title":"HerbConstraints.AbstractStateManager","text":"Manages all changes made to StateInts using StateIntBackups. Support the following functions:\n\nStateInt Creates a new stateful integer\nsave_state! Creates a checkpoint for all stateful integers\nrestore! Restores the values to the latest checkpoint\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Contains","page":"HerbConstraints.jl","title":"HerbConstraints.Contains","text":"Contains <: AbstractGrammarConstraint This [AbstractGrammarConstraint] enforces that a given rule appears in the program tree at least once.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.ContainsSubtree","page":"HerbConstraints.jl","title":"HerbConstraints.ContainsSubtree","text":"ContainsSubtree <: AbstractGrammarConstraint\n\nThis [AbstractGrammarConstraint] enforces that a given subtree appears in the program tree at least once.\n\n!!! warning:     This constraint can only be propagated by the UniformSolver\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.DomainRuleNode","page":"HerbConstraints.jl","title":"HerbConstraints.DomainRuleNode","text":"struct DomainRuleNode <: AbstractRuleNode\n\nMatches any 1 rule in its domain. Example usage:\n\nDomainRuleNode(Bitvector((0, 0, 1, 1)), [RuleNode(1), RuleNode(1)])\n\nThis matches RuleNode(3, [RuleNode(1), RuleNode(1)]) and RuleNode(4, [RuleNode(1), RuleNode(1)]) and UniformHole({3, 4}, [RuleNode(1), RuleNode(1)])\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Forbidden","page":"HerbConstraints.jl","title":"HerbConstraints.Forbidden","text":"Forbidden <: AbstractGrammarConstraint\n\nThis [AbstractGrammarConstraint] forbids any subtree that matches the pattern given by tree to be generated. A pattern is a tree of AbstractRuleNodes.  Such a node can either be a RuleNode, which contains a rule index corresponding to the  rule index in the AbstractGrammar and the appropriate number of children, similar to RuleNodes. It can also contain a VarNode, which contains a single identifier symbol. A VarNode can match any subtree, but if there are multiple instances of the same variable in the pattern, the matched subtrees must be identical. Any rule in the domain that makes the match attempt successful is removed.\n\nFor example, consider the tree 1(a, 2(b, 3(c, 4)))):\n\nForbidden(RuleNode(3, [RuleNode(5), RuleNode(4)])) forbids c to be filled with 5.\nForbidden(RuleNode(3, [VarNode(:v), RuleNode(4)])) forbids c to be filled, since a [VarNode] can    match any rule, thus making the match attempt successful for the entire domain of c.    Therefore, this tree invalid.\nForbidden(RuleNode(3, [VarNode(:v), VarNode(:v)])) forbids c to be filled with 4, since that would    make both assignments to v equal, which causes a successful match.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.ForbiddenSequence","page":"HerbConstraints.jl","title":"HerbConstraints.ForbiddenSequence","text":"ForbiddenPath <: AbstractGrammarConstraint\n\nThis [AbstractGrammarConstraint] forbids the given sequence of rule nodes. Sequences are strictly vertical and may include gaps. Consider the tree 1(a, 2(b, 3(c, d)))):\n\n[2, 3, d] is a sequence\n[1, 3, d] is a sequence\n[3, c, d] is not a sequence\n\nExamples:\n\nForbiddenSequence([3, 4]) enforces that rule 4 cannot be applied at c or d.\nForbiddenSequence([1, 2, 4]) enforces that rule 4 cannot be applied at b, c or d.\nForbiddenSequence([1, 4]) enforces that rule 4 cannot be applied anywhere.\n\nIf any of the rules in ignore_if appears in the sequence, the constraint is ignored. Suppose the forbidden sequence = [1, 2, 3] and ignore_if = [99] Consider the following paths from the root:\n\n[1, 2, 2, 3] is forbidden, as the sequence does not contain 99\n[1, 99, 2, 3] is NOT forbidden, as the sequence does contain 99\n[1, 99, 1, 2, 3] is forbidden, as there is a subsequence that does not contain 99\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.GenericSolver","page":"HerbConstraints.jl","title":"HerbConstraints.GenericSolver","text":"GenericSolver\n\nMaintains a feasible partial program in a SolverState. A ProgramIterator may manipulate the partial tree with the following tree manipulations:\n\nsubstitute!\nremove!\nremove_below!\nremove_above!\nremove_all_but!\n\nEach SolverState holds an independent propagation program. Program iterators can freely move back and forth between states using:\n\nnew_state!\nsave_state!\nload_state!\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.GenericSolver-Tuple{AbstractGrammar, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.GenericSolver","text":"GenericSolver(grammar::AbstractGrammar, init_node::AbstractRuleNode)\n\nConstructs a new solver, with an initial state of the provided AbstractRuleNode.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.GenericSolver-Tuple{AbstractGrammar, Symbol}","page":"HerbConstraints.jl","title":"HerbConstraints.GenericSolver","text":"GenericSolver(grammar::AbstractGrammar, sym::Symbol)\n\nConstructs a new solver, with an initial state using starting symbol sym\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualHardFail","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualHardFail","text":"struct LessThanOrEqualHardFail <: LessThanOrEqualResult end\n\nnode1 > node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualResult","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualResult","text":"abstract type LessThanOrEqualResult end\n\nA result of the less_than_or_equal function. Can be one of 3 cases:\n\nLessThanOrEqualSuccess\nLessThanOrEqualHardFail\nLessThanOrEqualSoftFail\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSoftFail","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSoftFail","text":"struct LessThanOrEqualSoftFail <: LessThanOrEqualResult\n\nnode1 <= node2 and node1 > node2 are both possible depending on the assignment of hole1 and hole2. Includes two cases:\n\nhole2::AbstractHole: A failed AbstractHole-AbstractHole comparison. (e.g. AbstractHole(BitVector((1, 0, 1))) vs AbstractHole(BitVector((0, 1, 1))))\nhole2::Nothing: A failed AbstractHole-RuleNode comparison. (e.g. AbstractHole(BitVector((1, 0, 1))) vs RuleNode(2))\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSuccess","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSuccess","text":"abstract type LessThanOrEqualSuccess <: LessThanOrEqualResult\n\nnode1 <= node2 is guaranteed under all possible assignments of the holes involved. The strictness of a LessThanOrEqualSuccess is specified by 1 of 2 concrete cases:\n\nLessThanOrEqualSuccessLessThan: node1 < node2\nLessThanOrEqualSuccessEquality: node1 == node2\nLessThanOrEqualSuccessWithHoles: node1 <= node2. Unable to specific.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSuccessEquality","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSuccessEquality","text":"struct LessThanOrEqualSuccessEquality <: LessThanOrEqualSuccess end\n\nnode1 == node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSuccessLessThan","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSuccessLessThan","text":"struct LessThanOrEqualSuccessEquality <: LessThanOrEqualSuccess end\n\nnode1 < node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSuccessWithHoles","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSuccessWithHoles","text":"struct LessThanOrEqualSuccessWithHoles <: LessThanOrEqualSuccess end\n\nnode1 <= node2 is guaranteed under all possible assignments of the holes involved. Because of the holes involved, it is not possible to specify '<' or '=='.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalContains","page":"HerbConstraints.jl","title":"HerbConstraints.LocalContains","text":"LocalContains\n\nEnforces that a given rule appears at or below the given path at least once.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalContainsSubtree","page":"HerbConstraints.jl","title":"HerbConstraints.LocalContainsSubtree","text":"LocalContains\n\nEnforces that a given tree appears at or below the given path at least once.\n\n!!! warning:     This is a stateful constraint can only be propagated by the UniformSolver.     The indices and candidates fields should not be set by the user.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalContainsSubtree-Tuple{Vector{Int64}, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.LocalContainsSubtree","text":"LocalContainsSubtree(path::Vector{Int}, tree::AbstractRuleNode)\n\nEnforces that a given tree appears at or below the given path at least once.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.LocalForbidden","page":"HerbConstraints.jl","title":"HerbConstraints.LocalForbidden","text":"LocalForbidden\n\nForbids the a subtree that matches the tree to be generated at the location  provided by the path.  Use a Forbidden constraint for enforcing this throughout the entire search space.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalForbiddenSequence","page":"HerbConstraints.jl","title":"HerbConstraints.LocalForbiddenSequence","text":"LocalForbiddenSequence <: AbstractLocalConstraint\n\nForbids the given sequence of rule nodes ending at the node at the path. If any of the rules in ignore_if appears in the sequence, the constraint is ignored.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalOrdered","page":"HerbConstraints.jl","title":"HerbConstraints.LocalOrdered","text":"Enforces an order over two or more subtrees that fill the variables  specified in order when the pattern is applied at the location given by path. Use an Ordered constraint for enforcing this throughout the entire search space.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalUnique","page":"HerbConstraints.jl","title":"HerbConstraints.LocalUnique","text":"LocalUnique <: AbstractLocalConstraint\n\nEnforces that a given rule appears at or below the given path at most once. In case of the UniformSolver, cache the list of holes, since no new holes can appear.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MakeEqualHardFail","page":"HerbConstraints.jl","title":"HerbConstraints.MakeEqualHardFail","text":"struct MakeEqualHardFail <: MakeEqualResult end\n\nnode1 != node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MakeEqualResult","page":"HerbConstraints.jl","title":"HerbConstraints.MakeEqualResult","text":"abstract type MakeEqualResult end\n\nA result of the make_equal! function. Can be one of 3 cases:\n\nMakeEqualSuccess\nMakeEqualHardFail\nMakeEqualSoftFail\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MakeEqualSoftFail","page":"HerbConstraints.jl","title":"HerbConstraints.MakeEqualSoftFail","text":"struct MakeEqualSoftFail <: MakeEqualResult end\n\nMaking node1 == node2 is ambiguous. Examples:\n\nRuleNode(1, [Hole({1, 2, 3})]) == RuleNode(1, [VarNode(:a)]). The hole can be filled with any rule.\nHole({1, 2, 3}) == DomainRuleNode({1, 2, 3}). The hole can be filled with any rule.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MakeEqualSuccess","page":"HerbConstraints.jl","title":"HerbConstraints.MakeEqualSuccess","text":"struct MakeEqualSuccess <: MakeEqualResult end\n\nnode1 == node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Ordered","page":"HerbConstraints.jl","title":"HerbConstraints.Ordered","text":"Ordered <: AbstractGrammarConstraint\n\nA AbstractGrammarConstraint that enforces a specific order in MatchVar  assignments in the pattern defined by tree. Nodes in the pattern can either be a RuleNode, which contains a rule index corresponding to the  rule index in the AbstractGrammar and the appropriate number of children. It can also contain a VarNode, which contains a single identifier symbol. A VarNode can match any subtree.  If there are multiple instances of the same variable in the pattern, the matched subtrees must be identical.\n\nThe order defines an order between the variable assignments.  For example, if the order is [x, y], the constraint will require  the assignment to x to be less than or equal to the assignment to y. The order is recursively defined by RuleNode indices.  For more information, see Base.isless(rn₁::AbstractRuleNode, rn₂::AbstractRuleNode).\n\nFor example, consider the tree 1(a, 2(b, 3(c, 4)))):\n\nOrdered(RuleNode(3, [VarNode(:v), VarNode(:w)]), [:v, :w]) removes every rule    with an index of 5 or greater from the domain of c, since that would make the index of the    assignment to v greater than the index of the assignment to w, violating the order.\nOrdered(RuleNode(3, [VarNode(:v), VarNode(:w)]), [:w, :v]) removes every rule    with an index of 4 or less from the domain of c, since that would make the index of the    assignment to v less than the index of the assignment to w, violating the order.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchHardFail","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchHardFail","text":"The pattern is not matched and can never be matched by filling in holes\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchResult","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchResult","text":"abstract type PatternMatchResult end\n\nA result of the pattern_match function. Can be one of 4 cases:\n\nPatternMatchSuccess\nPatternMatchSuccessWhenHoleAssignedTo\nPatternMatchHardFail\nPatternMatchSoftFail\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchSoftFail","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchSoftFail","text":"The pattern can still be matched in a non-trivial way. Includes two cases:\n\nmultiple holes are involved. this result stores a reference to one of them\na single hole is involved, but needs to be filled with a node of size >= 2\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchSuccess","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchSuccess","text":"The pattern is exactly matched and does not involve any holes at all\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchSuccessWhenHoleAssignedTo","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchSuccessWhenHoleAssignedTo","text":"The pattern can be matched when the hole is filled with any of the given ind(s).\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Solver","page":"HerbConstraints.jl","title":"HerbConstraints.Solver","text":"abstract type Solver\n\nAbstract constraint solver.  Each solver should have at least the following fields:\n\nstatistics::SolverStatistics\nfix_point_running::Bool\nschedule::PriorityQueue{AbstractLocalConstraint, Int}\n\nEach solver should implement at least:\n\npost!\nget_tree\nget_grammar\nset_infeasible!\nisfeasible\nHerbCore.get_node_at_location\nget_hole_at_location\nnotify_tree_manipulation\ndeactivate!\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.SolverState","page":"HerbConstraints.jl","title":"HerbConstraints.SolverState","text":"mutable struct SolverState\n\nA state to be solved by the GenericSolver. A state contains of:\n\ntree: A partial AST\nactive_constraints: The local constraints that apply to this tree.   These constraints are enforced each time the tree is modified.\nisfeasible: Flag to indicate if this state is still feasible.  When a propagator spots an inconsistency, this field will be set to false.  Tree manipulations and further propagations are not allowed on infeasible states\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.SolverStatistics","page":"HerbConstraints.jl","title":"HerbConstraints.SolverStatistics","text":"Temporary struct to track! the number of several function calls centered around the Solver\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateHole","page":"HerbConstraints.jl","title":"HerbConstraints.StateHole","text":"StateHole <: AbstractUniformHole\n\nStateHoles are uniform holes used by the UniformSolver. Domain manipulations are tracked for backpropagation.\n\ndomain: A StateSparseSet representing the rule nodes this hole can take. If size(domain) == 1, this hole should act like a RuleNode\nchildren: The children of this hole in the expression tree.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateHole-Tuple{HerbConstraints.StateManager, RuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.StateHole","text":"Converts a RuleNode to a StateHole\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateHole-Tuple{HerbConstraints.StateManager, UniformHole}","page":"HerbConstraints.jl","title":"HerbConstraints.StateHole","text":"Converts a UniformHole to a StateHole\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateInt","page":"HerbConstraints.jl","title":"HerbConstraints.StateInt","text":"Stateful integer that can be saved and restored by the StateManager. Supports the following functions:\n\nget_value\nset_value!\nincrement!\ndecrement!\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateIntBackup","page":"HerbConstraints.jl","title":"HerbConstraints.StateIntBackup","text":"Backup entry for the given StateInt\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateManager","page":"HerbConstraints.jl","title":"HerbConstraints.StateManager","text":"Manages all changes made to StateInts using StateIntBackups\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateSparseSet-Tuple{HerbConstraints.StateManager, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.StateSparseSet","text":"Converts a BitVector domain representation to a StateSparseSet Example:\n\nset = StateSparseSet(sm, BitVector((1, 1, 0, 0, 1, 0, 0))) #{1, 2, 5}\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateSparseSet-Tuple{HerbConstraints.StateManager, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.StateSparseSet","text":"Create a new StateSparseSet with values [1, 2, ..., n]\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateStack","page":"HerbConstraints.jl","title":"HerbConstraints.StateStack","text":"Simple stack that can only increase in size. Supports backtracking by decreasing the size to the saved size.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateStack-Union{Tuple{HerbConstraints.AbstractStateManager}, Tuple{T}} where T","page":"HerbConstraints.jl","title":"HerbConstraints.StateStack","text":"function StateStack{T}(sm::AbstractStateManager) where T\n\nCreate an empty StateStack supporting elements of type T\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateStack-Union{Tuple{T}, Tuple{HerbConstraints.AbstractStateManager, Vector{T}}} where T","page":"HerbConstraints.jl","title":"HerbConstraints.StateStack","text":"function StateStack{T}(sm::AbstractStateManager, vec::Vector{T}) where T\n\nCreate a StateStack for the provided vec\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.UniformSolver","page":"HerbConstraints.jl","title":"HerbConstraints.UniformSolver","text":"A DFS-based solver that uses StateHoles that support backtracking.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.UniformSolver-Tuple{AbstractGrammar, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.UniformSolver","text":"UniformSolver(grammar::AbstractGrammar, fixed_shaped_tree::AbstractRuleNode)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.Unique","page":"HerbConstraints.jl","title":"HerbConstraints.Unique","text":"Unique <: AbstractGrammarConstraint\n\nThis [AbstractGrammarConstraint] enforces that a given rule appears in the program tree at most once.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.VarNode","page":"HerbConstraints.jl","title":"HerbConstraints.VarNode","text":"struct VarNode <: AbstractRuleNode\n\nMatches any subtree and assigns it to a variable name. The LocalForbidden constraint will not match if identical variable symbols match to different trees. Example usage:\n\nRuleNode(3, [VarNode(:x), VarNode(:x)])\n\nThis matches RuleNode(3, [RuleNode(1), RuleNode(1)]), RuleNode(3, [RuleNode(2), RuleNode(2)]), etc. but also larger subtrees such as RuleNode(3, [RuleNode(4, [RuleNode(1)]), RuleNode(4, [RuleNode(1)])])\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.@csgrammar_annotated-Tuple{Any}","page":"HerbConstraints.jl","title":"HerbConstraints.@csgrammar_annotated","text":"@csgrammar_annotated Define an annotated grammar and return it as a ContextSensitiveGrammar. Allows for adding optional annotations per rule. As well as that, allows for adding optional labels per rule, which can be referenced in annotations.  Syntax is backwards-compatible with @csgrammar. Examples:\n\ng₁ = @csgrammar_annotated begin\n    Element = 1\n    Element = x\n    Element = Element + Element := commutative\n    Element = Element * Element := (commutative, transitive)\nend\n\ng₁ = @csgrammar_annotated begin\n    Element = 1\n    Element = x\n    Element = Element + Element := forbidden_path([3, 1])\n    Element = Element * Element := (commutative, transitive)\nend\n\ng₁ = @csgrammar_annotated begin\n    one::            Element = 1\n    variable::       Element = x\n    addition::       Element = Element + Element := (\n                                                       commutative,\n                                                       transitive,\n                                                       forbidden_path([:addition, :one]) || forbidden_path([:one, :variable])\n                                                    )\n    multiplication:: Element = Element * Element := (commutative, transitive)\nend\n\n\n\n\n\n","category":"macro"},{"location":"HerbConstraints/#Base.collect-Tuple{HerbConstraints.StateStack}","page":"HerbConstraints.jl","title":"Base.collect","text":"function Base.collect(stack::StateStack)\n\nReturn the internal Vector representation of the stack. !!! warning:     The returned vector is read-only.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.findall-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.findall","text":"Returns all elements in the set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.findfirst-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.findfirst","text":"Returns the minimum value in the set. This function name is used instead of min to allow code reuse for domains of type BitVector and StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.findlast-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.findlast","text":"Returns the maximum value in the set. This function name is used instead of min to allow code reuse for domains of type BitVector and StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.getindex-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"Base.getindex","text":"Checks if value val is in StateSparseSet s. !!! warning:     This allows a StateSparseSet to be used as if it were a BitVector representation of a set\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.in-Tuple{Int64, HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.in","text":"Checks if value val is in StateSparseSet s.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.in-Union{Tuple{T}, Tuple{HerbConstraints.StateStack{T}, T}} where T","page":"HerbConstraints.jl","title":"Base.in","text":"function Base.in(stack::StateStack, value)::Bool\n\nChecks whether the value is in the stack.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.length-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.length","text":"Returns the number of values in the StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.push!-Tuple{HerbConstraints.StateStack, Any}","page":"HerbConstraints.jl","title":"Base.push!","text":"function Base.push!(stack::StateStack, item)\n\nPlace an item on top of the stack.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.show-Tuple{IO, HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.show","text":"Pretty print the StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.size-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.size","text":"Returns the number of values in the StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.size-Tuple{HerbConstraints.StateStack}","page":"HerbConstraints.jl","title":"Base.size","text":"function Base.size(stack::StateStack)\n\nGet the current size of the stack.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.sum-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.sum","text":"Returns the number of values in the StateSparseSet. !!! warning:     This is not actually the sum of the set. It is the length of the set.     This allows a StateSparseSet to be used as if it were a BitVector representation of a set\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._contains-Tuple{AbstractRuleNode, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._contains","text":"_contains(node::AbstractRuleNode, rule::Int)::Bool\n\nRecursive helper function for the LocalContains constraint Returns one of the following:\n\ntrue, if the node does contains the rule\nfalse, if the node does not contain the rule\nVector{AbstractHole}, if the node contains the rule if one the holes gets filled with the target rule\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._count_occurrences!-Tuple{AbstractRuleNode, Int64, Vector{AbstractHole}}","page":"HerbConstraints.jl","title":"HerbConstraints._count_occurrences!","text":"function _count_occurrences!(node::AbstractRuleNode, rule::Int, holes::Vector{AbstractHole})::Int\n\nRecursive helper function for the LocalUnique constraint. Returns the number of certain occurrences of the rule in the tree. All holes that potentially can hold the target rule are stored in the holes vector.\n\n!!! warning:      Stops counting if the rule occurs more than once.      Counting beyond 2 is not needed for LocalUnique. \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._count_occurrences-Tuple{AbstractRuleNode, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._count_occurrences","text":"function _count_occurrences(rule::Int, node::AbstractRuleNode)::Int\n\nRecursively counts the number of occurrences of the rule in the node.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._count_occurrences-Tuple{Vector{AbstractHole}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._count_occurrences","text":"function _count_occurrences(holes::Vector{AbstractHole}, rule::Int)\n\nCounts the occurences of the rule in the cached list of holes.\n\n!!! warning:      Stops counting if the rule occurs more than once.      Counting beyond 2 is not needed for LocalUnique. \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._exchange_positions!-Tuple{HerbConstraints.StateSparseSet, Int64, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._exchange_positions!","text":"Exchanges the positions in the internal representation of the StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._update_bounds_val_removed!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._update_bounds_val_removed!","text":"This function should be called whenever the minimum or maximum value from the set might have been removed. The minimum and maximum value of the set will be updated to the actual bounds of the set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._update_max_val_removed!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._update_max_val_removed!","text":"This function should be called whenever the maximum value from the set might have been removed. The maximum value of the set will be updated to the actual maximum of the set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._update_min_val_removed!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._update_min_val_removed!","text":"This function should be called whenever the minimum value from the set might have been removed. The minimum value of the set will be updated to the actual minimum of the set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.annotation2constraint-Tuple{Any, Int64, Vector{String}}","page":"HerbConstraints.jl","title":"HerbConstraints.annotation2constraint","text":"Converts an annotation to a constraint. commutative: creates an Ordered constraint transitive: creates an (incorrect) Forbidden constraint forbidden_path(path::Vector{Union{Symbol, Int}}): creates a ForbiddenPath constraint with the original rule included ... || ...: creates a OneOf constraint (also works with ... || ... || ... et cetera, though not very performant)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.are_disjoint-Tuple{BitVector, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.are_disjoint","text":"are_disjoint(domain1::BitVector, domain2::BitVector)::Bool\n\nReturns true if there is no overlap in values between domain1 and domain2\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.are_disjoint-Tuple{HerbConstraints.StateSparseSet, HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"HerbConstraints.are_disjoint","text":"are_disjoint(set1::StateSparseSet, set2::StateSparseSet)\n\nReturns true if there is no overlap in values between set1 and set2\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.backup!-Tuple{StateInt}","page":"HerbConstraints.jl","title":"HerbConstraints.backup!","text":"Should be called whenever the state of a StateInt is modified. Creates a StateIntBackup for the given StateInt. Only backup the value if this integer has not been stored during this state before Example usecase:\n\na = StateInt(sm, 10)\nsave_state!(sm)\nset_value!(a, 9) #backup value 10\nset_value!(a, 8) #no need to backup again\nset_value!(a, 3) #no need to backup again\nrestore!(sm) #restores a to value 10\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Contains, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::Contains, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Contains constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{ContainsSubtree, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::ContainsSubtree, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the ContainsSubtree constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Forbidden, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::Forbidden, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Forbidden constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{ForbiddenSequence, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::ForbiddenSequence, tree::AbstractRuleNode; sequence_started=false)::Bool\n\nChecks if the given AbstractRuleNode tree abides the ForbiddenSequence constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Ordered, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::Ordered, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Ordered constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Unique, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"function check_tree(c::Unique, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Unique constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.contains_varnode-Tuple{AbstractRuleNode, Symbol}","page":"HerbConstraints.jl","title":"HerbConstraints.contains_varnode","text":"contains_varnode(rn::AbstractRuleNode, name::Symbol)\n\nChecks if an AbstractRuleNode tree contains a VarNode with the given name.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.deactivate!-Tuple{GenericSolver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.deactivate!","text":"deactivate!(solver::GenericSolver, constraint::AbstractLocalConstraint)\n\nFunction that should be called whenever the constraint is already satisfied and never has to be repropagated.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.deactivate!-Tuple{UniformSolver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.deactivate!","text":"deactivate!(solver::UniformSolver, constraint::AbstractLocalConstraint)\n\nFunction that should be called whenever the constraint is already satisfied and never has to be repropagated.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.decrement!-Tuple{StateInt}","page":"HerbConstraints.jl","title":"HerbConstraints.decrement!","text":"Decrease the value of the integer by 1\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.fix_point!-Tuple{Solver}","page":"HerbConstraints.jl","title":"HerbConstraints.fix_point!","text":"fix_point!(solver::Solver)\n\nPropagate constraints in the current state until no further dedecutions can be made\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.freeze_state-Tuple{StateHole}","page":"HerbConstraints.jl","title":"HerbConstraints.freeze_state","text":"freeze_state(hole::StateHole)::RuleNode\n\nConverts a [StateHole])(@ref) to a [RuleNode]@(ref). The hole and its children are assumed to be filled.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_grammar-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_grammar","text":"function get_grammar(solver::GenericSolver)::AbstractGrammar\n\nGet the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_grammar-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_grammar","text":"function get_grammar(solver::UniformSolver)::AbstractGrammar\n\nGet the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_hole_at_location-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.get_hole_at_location","text":"get_hole_at_location(solver::GenericSolver, location::Vector{Int})::AbstractHole\n\nGet the node at path location and assert it is a AbstractHole.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_hole_at_location-Tuple{UniformSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.get_hole_at_location","text":"get_hole_at_location(solver::UniformSolver, path::Vector{Int})\n\nGet the hole that is located at the provided path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_intersection-Tuple{BitVector, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.get_intersection","text":"get_intersection(domain1::BitVector, domain2::BitVector)::Bool\n\nReturns all the values that are in both domain1 and domain2\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_max_depth-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_max_depth","text":"function get_max_depth(solver::GenericSolver)::SolverState\n\nGet the maximum depth of the tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_max_size-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_max_size","text":"function get_max_depth(solver::GenericSolver)::SolverState\n\nGet the maximum number of AbstractRuleNodes allowed inside the tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_nodes-Tuple{Any}","page":"HerbConstraints.jl","title":"HerbConstraints.get_nodes","text":"get_nodes(solver)\n\nReturn an iterator over all nodes in the tree\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_nodes_on_path-Tuple{AbstractRuleNode, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.get_nodes_on_path","text":"function get_nodes_on_path(root::AbstractRuleNode, path::Vector{Int})::Vector{AbstractRuleNode}\n\nGets a list of nodes on the path, starting (and including) the root.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_priority-Tuple{AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.get_priority","text":"function get_priority(::AbstractLocalConstraint)\n\nUsed to determine which constraint to propagate first in fix_point!. Constraints with fast propagators and/or strong inference should be propagated first.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_starting_symbol-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_starting_symbol","text":"function get_starting_symbol(solver::GenericSolver)::Symbol\n\nGet the symbol from the solver.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_state-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_state","text":"function get_state(solver::GenericSolver)::SolverState\n\nGet the current [SolverState]@(ref) of the solver.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_tree-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_tree","text":"function get_tree(solver::GenericSolver)::AbstractRuleNode\n\nReturns the number of AbstractRuleNodes in the tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_tree-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_tree","text":"function get_tree(solver::UniformSolver)::AbstractRuleNode\n\nGet the root of the tree. This remains the same instance throughout the entire search.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_tree_size-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_tree_size","text":"function get_tree_size(solver::GenericSolver)::Int\n\nReturns the number of AbstractRuleNodes in the tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_value-Tuple{StateInt}","page":"HerbConstraints.jl","title":"HerbConstraints.get_value","text":"Get the value of the stateful integer\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.increment!-Tuple{StateInt}","page":"HerbConstraints.jl","title":"HerbConstraints.increment!","text":"Increase the value of the integer by 1\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.is_subdomain-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.is_subdomain","text":"is_subdomain(specific_tree::AbstractRuleNode, general_tree::AbstractRuleNode)\n\nChecks if the specific_tree can be obtained by repeatedly removing values from the general_tree\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.is_subdomain-Tuple{BitVector, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.is_subdomain","text":" is_subdomain(subdomain::BitVector, domain::BitVector)\n\nChecks if subdomain is a subdomain of domain. Example: [0, 0, 1, 0] is a subdomain of [0, 1, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.isfeasible-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.isfeasible","text":"isfeasible(solver::GenericSolver)\n\nReturns true if no inconsistency has been detected. Used in several ways:\n\nIterators should check for infeasibility to discard infeasible states\nAfter any tree manipulation with the possibility of an inconsistency (e.g. remove_below!, remove_above!, remove!)\nfix_point! should check for infeasibility to clear its schedule and return\nSome GenericSolver functions assert a feasible state for debugging purposes @assert isfeasible(solver)\nSome GenericSolver functions have a guard that skip the function on an infeasible state: if !isfeasible(solver) return end\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.isfeasible-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.isfeasible","text":"isfeasible(solver::UniformSolver)\n\nReturns true if no inconsistency has been detected.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.load_state!-Tuple{GenericSolver, SolverState}","page":"HerbConstraints.jl","title":"HerbConstraints.load_state!","text":"load_state!(solver::GenericSolver, state::SolverState)\n\nOverwrites the current state with the given state\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_equal!-Tuple{Solver, Union{AbstractHole, RuleNode}, Union{DomainRuleNode, AbstractHole, RuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_equal!","text":"function make_equal!(solver::Solver, node1::AbstractRuleNode, node2::AbstractRuleNode)::MakeEqualResult\n\nTree manipulation that enforces node1 == node2 if unambiguous.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_less_than_or_equal!-Tuple{Solver, Union{AbstractHole, RuleNode}, Union{AbstractHole, RuleNode}, Vector{Tuple{AbstractHole, Int64}}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_less_than_or_equal!","text":"function make_less_than_or_equal!(h1::Union{RuleNode, AbstractHole}, h2::Union{RuleNode, AbstractHole}, guards::Vector{Tuple{AbstractHole, Int}})::LessThanOrEqualResult\n\nHelper function that keeps track of the guards\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_less_than_or_equal!-Tuple{Solver, Union{AbstractHole, RuleNode}, Union{AbstractHole, RuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_less_than_or_equal!","text":"function make_less_than_or_equal!(h1::Union{RuleNode, AbstractHole}, h2::Union{RuleNode, AbstractHole})::LessThanOrEqualResult\n\nEnsures that n1<=n2 by removing impossible values from holes. Returns one of the following results:\n\nLessThanOrEqualSuccess. When [n1<=n2].\nLessThanOrEqualHardFail. When [n1>n2] or when the solver state is infeasible.\nLessThanOrEqualSoftFail. When no further deductions can be made, but [n1<=n2] and [n1>n2] are still possible.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_less_than_or_equal!-Tuple{Solver, Vector{AbstractRuleNode}, Vector{AbstractRuleNode}, Vector{Tuple{AbstractHole, Int64}}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_less_than_or_equal!","text":"function make_less_than_or_equal!(solver::Solver, nodes1::Vector{AbstractRuleNode}, nodes2::Vector{AbstractRuleNode}, guards::Vector{Tuple{AbstractHole, Int}})::LessThanOrEqualResult\n\nHelper function that tiebreaks on children.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.new_state!-Tuple{GenericSolver, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.new_state!","text":"new_state!(solver::GenericSolver, tree::AbstractRuleNode)\n\nOverwrites the current state and propagates constraints on the tree from the ground up\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_new_node-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_new_node","text":"notify_new_node(solver::GenericSolver, event_path::Vector{Int})\n\nNotify all constraints that a new node has appeared at the event_path by calling their respective on_new_node function.\n\nwarning: Warning\nThis does not notify the solver about nodes below the event_path. In that case, call notify_new_nodes instead.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_new_nodes-Tuple{GenericSolver, AbstractRuleNode, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_new_nodes","text":"notify_new_nodes(solver::GenericSolver, node::AbstractRuleNode, path::Vector{Int})\n\nNotify all grammar constraints about the new node and its (grand)children\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_new_nodes-Tuple{UniformSolver, AbstractRuleNode, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_new_nodes","text":"notify_new_nodes(solver::UniformSolver, node::AbstractRuleNode, path::Vector{Int})\n\nNotify all grammar constraints about the new node and its (grand)children\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_tree_manipulation-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_tree_manipulation","text":"notify_tree_manipulation(solver::GenericSolver, event_path::Vector{Int})\n\nNotify subscribed constraints that a tree manipulation has occured at the event_path by scheduling them for propagation\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_tree_manipulation-Tuple{UniformSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_tree_manipulation","text":"notify_tree_manipulation(solver::UniformSolver, event_path::Vector{Int})\n\nNotify subscribed constraints that a tree manipulation has occured at the event_path by scheduling them for propagation\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.partition-Tuple{Hole, ContextSensitiveGrammar}","page":"HerbConstraints.jl","title":"HerbConstraints.partition","text":"partition(hole::Hole, grammar::ContextSensitiveGrammar)::Vector{BitVector}\n\nPartition a Hole into subdomains grouped by childtypes\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{AbstractRuleNode, AbstractRuleNode, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"Generic fallback function for commutativity. Swaps arguments 1 and 2, then dispatches to a more specific signature. If this gets stuck in an infinite loop, the implementation of an AbstractRuleNode type pair is missing.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(rn::AbstractRuleNode, mn::AbstractRuleNode)::PatternMatchResult\n\nRecursively tries to match AbstractRuleNode rn with AbstractRuleNode mn. Returns a PatternMatchResult that describes if the pattern was matched.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{AbstractRuleNode, DomainRuleNode, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(node::AbstractRuleNode, domainrulenode::DomainRuleNode, vars::Dict{Symbol, AbstractRuleNode})::PatternMatchResult\n\nComparing any AbstractRuleNode with a DomainRuleNode\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{AbstractRuleNode, VarNode, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(rn::AbstractRuleNode, var::VarNode, vars::Dict{Symbol, AbstractRuleNode})::PatternMatchResult\n\nComparing any AbstractRuleNode with a named VarNode\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{Union{AbstractHole, RuleNode}, Union{AbstractHole, RuleNode}, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(h1::Union{RuleNode, AbstractHole}, h2::Union{RuleNode, AbstractHole}, vars::Dict{Symbol, AbstractRuleNode})::PatternMatchResult\n\nComparing any pair of Rulenode and/or AbstractHole. It is important to note that some AbstractHoles are already filled and should be treated as RuleNode. This is why this function is dispatched on (isfilled(h1), isfilled(h2)). The '(RuleNode, AbstractHole)' case could still include two nodes of type AbstractHole, but one of them should be treated as a rulenode.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{Vector{AbstractRuleNode}, Vector{AbstractRuleNode}, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(rns::Vector{AbstractRuleNode}, mns::Vector{AbstractRuleNode}, vars::Dict{Symbol, AbstractRuleNode})::PatternMatchResult\n\nPairwise tries to match two ordered lists of AbstractRuleNodes.  Typically, this function is used to pattern match the children two AbstractRuleNodes.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.post!-Tuple{GenericSolver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.post!","text":"post!(solver::GenericSolver, constraint::AbstractLocalConstraint)\n\nImposes the constraint to the current state. By default, the constraint will be scheduled for its initial propagation. Constraints can overload this method to add themselves to notify lists or triggers.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.post!-Tuple{UniformSolver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.post!","text":"post!(solver::UniformSolver, constraint::AbstractLocalConstraint)\n\nPost a new local constraint. Converts the constraint to a state constraint and schedules it for propagation.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{GenericSolver, LocalContainsSubtree}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(::GenericSolver, ::LocalContainsSubtree)\n\n!!! warning:     LocalContainsSubtree uses stateful properties and can therefore not be propagated in the GenericSolver.     (The GenericSolver shares constraints among different states, so they cannot use stateful properties)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalContains}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalContains)\n\nEnforce that the rule appears at or below the path at least once. Uses a helper function to retrieve a list of holes that can potentially hold the target rule. If there is only a single hole that can potentially hold the target rule, that hole will be filled with that rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalForbiddenSequence}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalForbiddenSequence)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalForbidden}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalForbidden)\n\nEnforce that the forbidden tree does not occur at the path. The forbidden tree is matched against the AbstractRuleNode located at the path. Deductions are based on the type of the PatternMatchResult returned by the pattern_match function.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalOrdered}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalOrdered)\n\nEnforce that the VarNodes in the tree are in the specified order. First the node located at the path is matched to see if the ordered constraint applies here. The nodes matching the variables are stored in the vars dictionary. Then the order is enforced within the make_less_than_or_equal! tree manipulation.   \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalUnique}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalUnique)\n\nEnforce that the rule appears at or below the path at least once. Uses a helper function to retrieve a list of holes that can potentially hold the target rule. If there is only a single hole that can potentially hold the target rule, that hole will be filled with that rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{UniformSolver, LocalContainsSubtree}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::UniformSolver, c::LocalContainsSubtree)\n\nEnforce that the tree appears at or below the path at least once. Nodes that can potentially become the target sub-tree are considered candidates. In case of multiple candidates, a stateful set of indices is used to keep track of active candidates.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{GenericSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(solver::GenericSolver, path::Vector{Int}, rule_index::Int)\n\nRemove rule_index from the domain of the hole located at the path. It is assumed the path points to a hole, otherwise an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{GenericSolver, Vector{Int64}, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(solver::GenericSolver, path::Vector{Int}, rules::Vector{Int})\n\nRemove all rules from the domain of the hole located at the path. It is assumed the path points to a hole, otherwise an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(set::StateSparseSet, val::Int)\n\nRemoves value val from StateSparseSet set. Returns true if val was in set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{UniformSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(solver::Solver, path::Vector{Int}, rule_index::Int)\n\nRemove rule_index from the domain of the hole located at the path. It is assumed the path points to a hole, otherwise an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{UniformSolver, Vector{Int64}, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(solver::UniformSolver, path::Vector{Int}, rules::Vector{Int})\n\nRemove all rules from the domain of the hole located at the path. It is assumed the path points to a hole, otherwise an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_above!-Tuple{GenericSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_above!","text":"remove_above!(solver::GenericSolver, path::Vector{Int}, rule_index::Int)\n\nReduce the domain of the hole located at the path by removing all rules indices above rule_index Example: rule_index = 2.  hole with domain [1, 1, 0, 1] gets reduced to [1, 0, 0, 0] and gets simplified to a RuleNode\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_above!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_above!","text":"Remove all the values greater than val from the set\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_above!-Tuple{UniformSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_above!","text":"remove_above!(solver::UniformSolver, path::Vector{Int}, rule_index::Int)\n\nReduce the domain of the hole located at the path by removing all rules indices above rule_index Example: rule_index = 2.  hole with domain {1, 2, 4} gets reduced to {1}\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{GenericSolver, Vector{Int64}, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(solver::GenericSolver, path::Vector{Int}, new_domain::BitVector)\n\nReduce the domain of the hole located at the path, to the new_domain. It is assumed the path points to a hole, otherwise an exception will be thrown. It is assumed new_domain ⊆ domain. For example: [1, 0, 1, 0] ⊆ [1, 0, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{GenericSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(solver::GenericSolver, path::Vector{Int}, rule_index::Int)\n\nFill in the hole located at the path with rule rule_index. It is assumed the path points to a hole, otherwise an exception will be thrown. It is assumed rule_index ∈ hole.domain.\n\n!!! warning: If the hole is known to be in the current tree, the hole can be passed directly.     The caller has to make sure that the hole instance is actually present at the provided path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(set::StateSparseSet, val::Int)::Bool\n\nRemoves all values from StateSparseSet set, except val\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{UniformSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(solver::UniformSolver, path::Vector{Int}, rule_index::Int)\n\nFill in the hole located at the path with rule rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_below!-Tuple{GenericSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_below!","text":"remove_below!(solver::GenericSolver, path::Vector{Int}, rule_index::Int)\n\nReduce the domain of the hole located at the path by removing all rules indices below rule_index Example: rule_index = 2.  hole with domain [1, 1, 0, 1] gets reduced to [0, 1, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_below!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_below!","text":"Remove all the values less than val from the set\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_below!-Tuple{UniformSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_below!","text":"remove_below!(solver::UniformSolver, path::Vector{Int}, rule_index::Int)\n\nReduce the domain of the hole located at the path by removing all rules indices below rule_index Example: rule_index = 2.  hole with domain {1, 2, 4} gets reduced to {2, 4}\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_node!-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_node!","text":"function remove_node!(solver::GenericSolver, path::Vector{Int})\n\nRemove the node at the given path by substituting it with a hole of the same symbol.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.restore!-Tuple{HerbConstraints.StateIntBackup}","page":"HerbConstraints.jl","title":"HerbConstraints.restore!","text":"Restores the StateInt stored in the StateIntBackup to its original value\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.restore!-Tuple{HerbConstraints.StateManager}","page":"HerbConstraints.jl","title":"HerbConstraints.restore!","text":"Reverts all the backups since the last save_state!.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.restore!-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.restore!","text":"Restore state of the solver until the last save_state!\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.save_state!-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.save_state!","text":"save_state!(solver::GenericSolver)\n\nReturns a copy of the current state that can be restored by calling load_state!(solver, state)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.save_state!-Tuple{HerbConstraints.StateManager}","page":"HerbConstraints.jl","title":"HerbConstraints.save_state!","text":"Make a backup of the current state. Return to this state by calling restore!.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.save_state!-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.save_state!","text":"Save the current state of the solver, can restored using restore!\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.schedule!-Tuple{Solver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.schedule!","text":"schedule(solver::GenericSolver, constraint::AbstractLocalConstraint)\n\nSchedules the constraint for propagation.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.set_infeasible!-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.set_infeasible!","text":"set_infeasible!(solver::GenericSolver)\n\nFunction to be called if any inconsistency has been detected\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.set_infeasible!-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.set_infeasible!","text":"set_infeasible!(solver::Solver)\n\nFunction to be called if any inconsistency has been detected\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.set_value!-Tuple{StateInt, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.set_value!","text":"Set the value of the integer to the given val\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.shouldschedule-Tuple{Solver, AbstractLocalConstraint, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.shouldschedule","text":"shouldschedule(solver::Solver, constraint::AbstractLocalConstraint, path::Vector{Int})::Bool\n\nFunction that is called when a tree manipulation occured at the path. Returns true if the constraint should be scheduled for propagation.\n\nDefault behavior: return true iff the manipulation happened at or below the constraint path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.shouldschedule-Tuple{Solver, LocalForbiddenSequence, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.shouldschedule","text":"shouldschedule(::Solver, constraint::LocalForbiddenSequence, path::Vector{Int})::Bool\n\nReturn true iff the manipulation happened at or above the constraint path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.simplify_hole!-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.simplify_hole!","text":"simplify_hole!(solver::GenericSolver, path::Vector{Int})\n\nTakes a Hole and tries to simplify it to a UniformHole or RuleNode. If the domain of the hole is empty, the state will be marked as infeasible\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.substitute!-Tuple{GenericSolver, Vector{Int64}, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.substitute!","text":"substitute!(solver::GenericSolver, path::Vector{Int}, new_node::AbstractRuleNode; is_domain_increasing::Union{Nothing, Bool}=nothing)\n\nSubstitute the node at the path, with a new_node.\n\nis_domain_increasing: indicates if all grammar constraints should be repropagated from the ground up.\n\nDomain increasing substitutions are substitutions that cannot be achieved by repeatedly removing values from domains. Example of an domain increasing event: hole[{3, 4, 5}] -> hole[{1, 2}]. Example of an domain decreasing event: hole[{3, 4, 5}] -> rulenode(4, [hole[{1, 2}], rulenode(1)]).\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.contains_hole-Tuple{StateHole}","page":"HerbConstraints.jl","title":"HerbCore.contains_hole","text":"contains_hole(hole::StateHole)::Bool\n\nReturns true if the hole or any of its (grand)children are not filled.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_node_at_location-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbCore.get_node_at_location","text":"HerbCore.get_node_at_location(solver::GenericSolver, location::Vector{Int})::AbstractRuleNode\n\nGet the node at path location.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_node_at_location-Tuple{UniformSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbCore.get_node_at_location","text":"get_node_at_location(solver::UniformSolver, path::Vector{Int})\n\nGet the node that is located at the provided path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_path-Tuple{GenericSolver, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbCore.get_path","text":"get_path(solver::GenericSolver, node::AbstractRuleNode)\n\nGet the path at which the node is located.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_path-Tuple{UniformSolver, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbCore.get_path","text":"get_path(solver::UniformSolver, node::AbstractRuleNode)\n\nGet the path at which the node is located.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_rule-Tuple{StateHole}","page":"HerbConstraints.jl","title":"HerbCore.get_rule","text":"get_rule(hole::StateHole)::Int\n\nAssuming the hole has domain size 1, get the rule it is currently assigned to.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.isfilled-Tuple{StateHole}","page":"HerbConstraints.jl","title":"HerbCore.isfilled","text":"isfilled(hole::StateHole)::Bool\n\nHoles with domain size 1 are fixed to a rule. Returns whether the hole has domain size 1. (holes with an empty domain are not considered to be fixed)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Index","page":"HerbConstraints.jl","title":"Index","text":"","category":"section"},{"location":"HerbConstraints/","page":"HerbConstraints.jl","title":"HerbConstraints.jl","text":"","category":"page"},{"location":"tutorials/advanced_search/","page":"Advanced Search Procedures","title":"Advanced Search Procedures","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"fb140a0cd458551110904e688cae9caaa711d1b7ac33fc6a3a54009e89dffff2\"\n    julia_version = \"1.11.3\"\n-->\n\n<div class=\"markdown\"><h1>Advanced Search Procedures in Herb.jl</h1><p><a href=\"\">A more verbose getting started with Herb.jl</a> described the concept of a program space and showed how to search it with Herb.jl, using a simple breadth-first-search (BFS) iterator for the search.  This tutorial takes a closer look at advanced search procedures hat can be employed to find a solution program to a program synthesis problem. </p><p>More specifically, you will learn about</p><ul><li><p><strong>Parameters</strong> that can be specified and their effect on the search procedure.  </p></li><li><p><strong>Deterministic search methods</strong> BFS and DFS.</p></li><li><p><strong>Stochastic search methods</strong>, which introduce randomness to search the program space. We will look at Metropolis-Hastings, Very Large Scale Neighbourhood Search, Simulated Annealing and Genetic Search.</p></li></ul></div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<div class=\"markdown\"><p>Let's import all the Herb modules that we will use throughout the tutorial.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><p>We start with a simple grammar:.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g_1 = @csgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g_1\">1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><p>Let's use the simple program <code>2x+1</code> as our problem and generate some input-output examples for the problem specification.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>problem_1 = Problem([IOExample(Dict(:x =&gt; x), 2x+1) for x ∈ 1:5])</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-problem_1\">Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 11)])</pre>\n\n","category":"page"},{"location":"tutorials/advanced_search/#Parameters","page":"Advanced Search Procedures","title":"Parameters","text":"","category":"section"},{"location":"tutorials/advanced_search/","page":"Advanced Search Procedures","title":"Advanced Search Procedures","text":"<div class=\"markdown\">\n<p>Search procedures typically have some hyperparameters that you can configure.</p><h3><code>max_depth</code></h3><p><code>max_depth</code> controls the maximum depth of the program trees that are explored during the search, effectively limiting the size and complexity of the synthesized program. The parameter is configured as part of the iterator.</p><p>In the following example, we consider two different values for <code>max_depth</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator_1 = BFSIterator(g_1, :Number, max_depth=3)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_1\">BFSIterator(GenericSolver(1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n, SolverState(hole[Bool[1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 3))</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_2 = BFSIterator(g_1, :Number, max_depth=6)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_2\">BFSIterator(GenericSolver(1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n, SolverState(hole[Bool[1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 6))</pre>\n\n\n<div class=\"markdown\"><p>To see the effect <code>max_depth</code> has on the number of memory allocations made during the program synthesis process, we use the <code>@time</code> macro.  </p></div>\n\n\n<div class=\"markdown\"><p>Solution for max_depth = 3:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>solution_1 = @time synth(problem_1, iterator_1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-solution_1\">(4{3,4{1,3}}, optimal_program)</pre>\n\n<pre class='language-julia'><code class='language-julia'>rulenode2expr(solution_1[1], g_1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash195477\">:(x + (1 + x))</pre>\n\n\n<div class=\"markdown\"><p>Solution for max_depth = 6:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    solution_2 = @time synth(problem_1, iterator_2)\n    rulenode2expr(solution_2[1], g_1)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-solution_2\">:(x + (1 + x))</pre>\n\n\n<div class=\"markdown\"><p>While increasing <code>max_depth</code> allows us to explore more complex and deeper program trees, which may lead to a better solution, it also requires more memory allocation and can increase the execution time. </p></div>\n\n\n<div class=\"markdown\"><h3><code>max_enumerations</code></h3><p><code>max_enumerations</code> defines the maximum number of candidate programs that can be evaluated before the search is terminated. </p><p>Let's explore how many enumerations are necessary to solve our simple problem.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    solutions = []\n    times = []\n    nodes = []\n    iterations = []\n    for i in range(1, 50)\n        iterator = BFSIterator(g_1, :Number, max_depth=i)\n        solution = @timed synth(problem_1, iterator)\n        push!(times, solution.time)\n        push!(nodes, solution[1][1])\n        push!(solutions, rulenode2expr(solution[1][1], g_1))\n        push!(iterations, i)\n    end\n    pretty_table(HTML, [iterations nodes solutions times], header=[\"Iteration\", \"RuleNode\", \"Program\", \"Duration\"])\nend</code></pre>\n<table><thead><tr class=\"header headerLastRow\"><th style=\"text-align: right;\">Iteration</th><th style=\"text-align: right;\">RuleNode</th><th style=\"text-align: right;\">Program</th><th style=\"text-align: right;\">Duration</th></tr></thead><tbody><tr><td style=\"text-align: right;\">1</td><td style=\"text-align: right;\">3</td><td style=\"text-align: right;\">x</td><td style=\"text-align: right;\">0.00314305</td></tr><tr><td style=\"text-align: right;\">2</td><td style=\"text-align: right;\">4{2,1}</td><td style=\"text-align: right;\">2 + 1</td><td style=\"text-align: right;\">0.000186581</td></tr><tr><td style=\"text-align: right;\">3</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.000904733</td></tr><tr><td style=\"text-align: right;\">4</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00104546</td></tr><tr><td style=\"text-align: right;\">5</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00116283</td></tr><tr><td style=\"text-align: right;\">6</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00122995</td></tr><tr><td style=\"text-align: right;\">7</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00124177</td></tr><tr><td style=\"text-align: right;\">8</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.001237</td></tr><tr><td style=\"text-align: right;\">9</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123491</td></tr><tr><td style=\"text-align: right;\">10</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00122614</td></tr><tr><td style=\"text-align: right;\">11</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00127422</td></tr><tr><td style=\"text-align: right;\">12</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123371</td></tr><tr><td style=\"text-align: right;\">13</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123353</td></tr><tr><td style=\"text-align: right;\">14</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123776</td></tr><tr><td style=\"text-align: right;\">15</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00126292</td></tr><tr><td style=\"text-align: right;\">16</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.0248513</td></tr><tr><td style=\"text-align: right;\">17</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00129083</td></tr><tr><td style=\"text-align: right;\">18</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123984</td></tr><tr><td style=\"text-align: right;\">19</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00122717</td></tr><tr><td style=\"text-align: right;\">20</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00122492</td></tr><tr><td style=\"text-align: right;\">21</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00124526</td></tr><tr><td style=\"text-align: right;\">22</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123546</td></tr><tr><td style=\"text-align: right;\">23</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00124593</td></tr><tr><td style=\"text-align: right;\">24</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123243</td></tr><tr><td style=\"text-align: right;\">25</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00125782</td></tr><tr><td style=\"text-align: right;\">26</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.0012423</td></tr><tr><td style=\"text-align: right;\">27</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.001243</td></tr><tr><td style=\"text-align: right;\">28</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00124211</td></tr><tr><td style=\"text-align: right;\">29</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00127398</td></tr><tr><td style=\"text-align: right;\">30</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00124235</td></tr><tr><td style=\"text-align: right;\">31</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00124405</td></tr><tr><td style=\"text-align: right;\">32</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123028</td></tr><tr><td style=\"text-align: right;\">33</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00125804</td></tr><tr><td style=\"text-align: right;\">34</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00121403</td></tr><tr><td style=\"text-align: right;\">35</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123671</td></tr><tr><td style=\"text-align: right;\">36</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00122878</td></tr><tr><td style=\"text-align: right;\">37</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00124102</td></tr><tr><td style=\"text-align: right;\">38</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00122493</td></tr><tr><td style=\"text-align: right;\">39</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.0012378</td></tr><tr><td style=\"text-align: right;\">40</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123989</td></tr><tr><td style=\"text-align: right;\">41</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00125367</td></tr><tr><td style=\"text-align: right;\">42</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00125118</td></tr><tr><td style=\"text-align: right;\">43</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00124222</td></tr><tr><td style=\"text-align: right;\">44</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00125317</td></tr><tr><td style=\"text-align: right;\">45</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00126762</td></tr><tr><td style=\"text-align: right;\">46</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00123898</td></tr><tr><td style=\"text-align: right;\">47</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.0012577</td></tr><tr><td style=\"text-align: right;\">48</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00127301</td></tr><tr><td style=\"text-align: right;\">49</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00125286</td></tr><tr><td style=\"text-align: right;\">50</td><td style=\"text-align: right;\">4{3,4{1,3}}</td><td style=\"text-align: right;\">x + (1 + x)</td><td style=\"text-align: right;\">0.00126737</td></tr></tbody></table>\n\n\n<div class=\"markdown\"><p>At <code>i = 3</code>, we observe that an optimal program is found. Increasing the number of enumerations beyond that does not affect the solution or the number of memory allocations. </p></div>\n\n\n<div class=\"markdown\"><h3><code>allow_evaluation_errors</code></h3><p>A final parameter we consider here is <code>allow_evaluation_errors</code>, which is <code>false</code> by default. When <code>true</code>, the search continues even if an exception occurs during the evaluation of a candidate program. This allows the search process to handle faulty candidate programs and explore other ones, instead of throwing an error and terminating prematurely.</p><p>We will use a new example to see the effect of <code>allow_evaluation_errors</code>. We begin defining a new simple grammar. We then create some input-output examples to specify the problem we want to solve. This time, we choose a problem that we cannot solve with the provided grammar. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>g_2 = @csgrammar begin\n    Number = 1\n    List = []\n    Index = List[Number]\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g_2\">1: Number = 1\n2: List = []\n3: Index = List[Number]\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_2 = Problem([IOExample(Dict{Symbol,Any}(), x) for x ∈ 1:5])</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-problem_2\">Problem{Vector{IOExample{Any, Int64}}}(\"\", IOExample{Any, Int64}[IOExample{Any, Int64}(Dict{Symbol, Any}(), 1), IOExample{Any, Int64}(Dict{Symbol, Any}(), 2), IOExample{Any, Int64}(Dict{Symbol, Any}(), 3), IOExample{Any, Int64}(Dict{Symbol, Any}(), 4), IOExample{Any, Int64}(Dict{Symbol, Any}(), 5)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_3 = BFSIterator(g_2, :Index, max_depth=2)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_3\">BFSIterator(GenericSolver(1: Number = 1\n2: List = []\n3: Index = List[Number]\n, SolverState(3{2,1}, Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 2))</pre>\n\n<pre class='language-julia'><code class='language-julia'>Test.@test_throws HerbSearch.EvaluationError synth(problem_2, iterator_3)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash467858\">Test Passed\n      Thrown: HerbSearch.EvaluationError</pre>\n\n\n<div class=\"markdown\"><p>As expected, an exception occurs during the synthesis process. Now we try the same again, with <code>allow_evaluation_errors=true</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>solution_4 = synth(problem_2, iterator_3, allow_evaluation_errors=true)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-solution_4\">(3{2,1}, suboptimal_program)</pre>\n\n\n<div class=\"markdown\"><p>\"This time we find a solution, although a suboptimal one.</p></div>\n\n","category":"page"},{"location":"tutorials/advanced_search/#Top-down-search","page":"Advanced Search Procedures","title":"Top-down search","text":"","category":"section"},{"location":"tutorials/advanced_search/","page":"Advanced Search Procedures","title":"Advanced Search Procedures","text":"<div class=\"markdown\">\n<p>Herb.jl provides already implemented, ready-to-use search methods. The core building block of the search is the program iterator, which represents a walk through the program space. All program iterators share the top-level abstract type <code>ProgramIterator</code>. For more information on iterators and how to customize them, see <a href=\"https://herb-ai.github.io/Herb.jl/dev/tutorials/TopDown/\">this tutorial</a>.</p><p>First, we explore two fundamental deterministic top-down search algorithms: <strong>breadth-first search (BFS)</strong> and <strong>depth-first search (DFS)</strong>. Both algorithms are implemented using the abstract type <code>TopDownIterator</code>, which can be customized through the functions </p><ul><li><p><code>priority_function</code></p></li><li><p><code>derivation_heuristic</code></p></li><li><p><code>hole_heuristic</code></p></li></ul></div>\n\n\n<div class=\"markdown\"><p>First, we explore two fundamental deterministic top-down search algorithms: <strong>breadth-first search (BFS)</strong> and <strong>depth-first search (DFS)</strong>. Both algorithms are implemented using the abstract type <code>TopDownIterator</code>, which can be customized through the functions priority<em>function, derivation</em>heuristic, and hole_heuristic.</p><h3>Breadth-First Search</h3><p>The <code>BFSIterator</code> enumerates all possible programs at a given depth before progressing to the next level, ensuring that trees are explored in increasing order of size. This guarantees that smaller programs are evaluated first, and larger, more complex ones are considered only after all smaller ones have been processed.</p><p>To explore <code>BFSIterator</code>, we define another very simple grammar.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g_3 = @csgrammar begin\n        Real = 1 | 2\n        Real = Real * Real\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g_3\">1: Real = 1\n2: Real = 2\n3: Real = Real * Real\n</pre>\n\n\n<div class=\"markdown\"><p>Next, we define a <code>BFSIterator</code> with a <code>max_depth</code> of 2 and a <code>max_size</code> of infinite (which we approximate with the maximum value of <code>Int</code>), and a starting symbol of type <code>Real</code>. By default, <code>BFSIterator</code> uses the heuristic 'left-most first', i.e., the left-most child in the tree is always explored first.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator_bfs = BFSIterator(g_3, :Real, max_depth=2, max_size=typemax(Int))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_bfs\">BFSIterator(GenericSolver(1: Real = 1\n2: Real = 2\n3: Real = Real * Real\n, SolverState(hole[Bool[1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 2))</pre>\n\n\n<div class=\"markdown\"><p>To see all possible solution programs the iterator explores, we use <code>collect</code>. It returs a list of the programs, ordered by increasing size and depth. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>programs_bfs = collect(iterator_bfs)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-programs_bfs\">6-element Vector{RuleNode}:\n 1\n 2\n 3{1,1}\n 3{1,2}\n 3{2,2}\n 3{2,1}</pre>\n\n\n<div class=\"markdown\"><p>Let's verify that the iterator returns the programs we expect (keep in mind we use a leftmost-first heuristic).</p></div>\n\n<pre class='language-julia'><code class='language-julia'>answer_programs = [\n    RuleNode(1),\n    RuleNode(2),\n    RuleNode(3, [RuleNode(1), RuleNode(1)]),\n    RuleNode(3, [RuleNode(1), RuleNode(2)]),\n    RuleNode(3, [RuleNode(2), RuleNode(1)]),\n    RuleNode(3, [RuleNode(2), RuleNode(2)])\n]</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-answer_programs\">6-element Vector{RuleNode}:\n 1\n 2\n 3{1,1}\n 3{1,2}\n 3{2,1}\n 3{2,2}</pre>\n\n<pre class='language-julia'><code class='language-julia'>rulenode_programs = [rulenode2expr(r, g_3) for r in answer_programs]</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-rulenode_programs\">6-element Vector{Any}:\n 1\n 2\n  :(1 * 1)\n  :(1 * 2)\n  :(2 * 1)\n  :(2 * 2)</pre>\n\n<pre class='language-julia'><code class='language-julia'>found_all_programs = all(p ∈ programs_bfs for p ∈ answer_programs)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-found_all_programs\">true</pre>\n\n\n<div class=\"markdown\"><h3>Depth-First Search</h3><p>The <code>DFSIterator</code> explores one branch of the search tree at a time, fully traversing it unitl a correct program is found or the specified <code>max_depth</code> is reached. Only after completing the current branch, it proceeds to the next branch.</p><p>As before, we <code>collect</code> the candidate programs using the same grammar, but a <code>DFSIterator</code>. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator_dfs = DFSIterator(g_3, :Real, max_depth=2, max_size=typemax(Int))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_dfs\">DFSIterator(GenericSolver(1: Real = 1\n2: Real = 2\n3: Real = Real * Real\n, SolverState(hole[Bool[1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 2))</pre>\n\n<pre class='language-julia'><code class='language-julia'>programs_dfs = collect(iterator_dfs)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-programs_dfs\">6-element Vector{RuleNode}:\n 1\n 3{1,1}\n 3{1,2}\n 3{2,2}\n 3{2,1}\n 2</pre>\n\n\n<div class=\"markdown\"><p><code>DFSIterator</code> also uses by default a <strong>leftmost-first</strong> heuristic. If we want to use a <strong>rightmost-first</strong> heuristic instead, we can create our own iterator <code>DFSIteratorRightmost</code> as a sub-type of <code>TopDownIterator</code>, using the <code>@programiterator</code> macro. Then we implement the functions <code>priority_function</code> and <code>hole_heuristic</code>. Also see the tutorial <a href=\"https://herb-ai.github.io/Herb.jl/dev/tutorials/TopDown/\">Top Down Iterator</a> for how to build iterators is Herb.jl. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>@programiterator DFSIteratorRightmost() &lt;: TopDownIterator</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-DFSIteratorRightmost\">DFSIteratorRightmost</pre>\n\n\n<div class=\"markdown\"><p>By default, <code>priority_function</code> for a <code>TopDownIterator</code> is that of a BFS iterator. Hence, we need to provide a new implementation. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>function priority_function(\n    ::DFSIteratorRightmost, \n    ::AbstractGrammar, \n    ::AbstractRuleNode, \n    parent_value::Union{Real, Tuple{Vararg{Real}}},\n    isrequeued::Bool\n)\n    if isrequeued\n        return parent_value;\n    end\n    return parent_value - 1;\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-priority_function\">priority_function (generic function with 1 method)</pre>\n\n\n<div class=\"markdown\"><p>Next, we need to implement the <code>hole_heuristic</code> to be rightmost-first.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function hole_heuristic(::DFSIteratorRightmost, node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n    return heuristic_rightmost(node, max_depth);\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hole_heuristic\">hole_heuristic (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>iteratordfs_rightmost = DFSIteratorRightmost(g_3, :Real, max_depth=2, max_size=typemax(Int))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iteratordfs_rightmost\">DFSIteratorRightmost(GenericSolver(1: Real = 1\n2: Real = 2\n3: Real = Real * Real\n, SolverState(hole[Bool[1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 2))</pre>\n\n<pre class='language-julia'><code class='language-julia'>programs_dfs_rightmost = collect(iteratordfs_rightmost)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-programs_dfs_rightmost\">6-element Vector{RuleNode}:\n 1\n 2\n 3{1,1}\n 3{1,2}\n 3{2,2}\n 3{2,1}</pre>\n\n\n<div class=\"markdown\"><p>We observe that the order of programs has changed. We can also test if both DFS iterators return the same programs:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>Set(programs_dfs)==Set(programs_dfs_rightmost)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash121764\">true</pre>\n\n","category":"page"},{"location":"tutorials/advanced_search/#Stochastic-search","page":"Advanced Search Procedures","title":"Stochastic search","text":"","category":"section"},{"location":"tutorials/advanced_search/","page":"Advanced Search Procedures","title":"Advanced Search Procedures","text":"<div class=\"markdown\">\n<p>While deterministic search methods explore the search space in a predictable way, stochastic ones introduce randomness to allow for more flexibility.</p><p>In this section, we will look at the stochastic search algorithms: Metropolis-Hastings (MH), Very Large Scale Neighbourhood Search (VLSNS), and Simulated Annealing (SA). In Herb.jl, all of these search methodsthe share a common supertype <code>StochasticSearchIterator</code>, which defines the following fields</p><ul><li><p><code>examples</code></p></li><li><p><code>cost_function</code></p></li><li><p><code>initial_temperature</code></p></li><li><p><code>evaluation_function</code>.</p></li></ul><p>They are customized by overriding the functions <code>neighbourhood</code>, <code>propose</code>, <code>accept</code> and <code>temperature</code> as required.</p><p>We start with a simple grammar and a helper function to create the input-output examples for the problem we want to solve.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g_4 = @csgrammar begin\n    X = |(1:5)\n    X = X * X\n    X = X + X\n    X = X - X\n    X = x\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g_4\">1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>function create_problem(f, range=20)\n    examples = [IOExample(Dict(:x =&gt; x), f(x)) for x ∈ 1:range]\n    return Problem(examples), examples\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-create_problem\">create_problem (generic function with 2 methods)</pre>\n\n\n<div class=\"markdown\"><p>Throughout the stochastic search examples, we will use mean-squared-error as cost function. The cost function helps to guide the search by evaluating how well a candidate program solves the given task. This is used to decide whether a proposed program should be accepted or rejected.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>cost_function = mean_squared_error</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-cost_function\">mean_squared_error (generic function with 1 method)</pre>\n\n\n<div class=\"markdown\"><h3>Metropolis-Hastings</h3><p>Metropolis-Hastings (MH) is a method to produce samples from a distribution that may otherwise be difficult to sample. In the context of program synthesis, we sample from a distribution of programs defined by the grammar. </p><p>For more information on MH, see for example <a href=\"https://stephens999.github.io/fiveMinuteStats/MH_intro.html\">this webpage</a>.</p><p>To illustrate MH, we use a simple arithmetic example.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>e_mh = x -&gt; x * x + 4</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-e_mh\">#9 (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_mh, examples_mh = create_problem(e_mh)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_mh\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)])</pre>\n\n\n<div class=\"markdown\"><p>Run the following code block to define the iterator and perform the program synthesis multiple times. Since the search process is stochastic, you will likely see different solution programs with each run.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    rules = []\n    programs = []\n    iters = []\n    for i in range(1, 3)\n        iterator_mh = MHSearchIterator(g_4, :X, examples_mh, cost_function, max_depth=3) \n        program_mh = synth(problem_mh, iterator_mh)\n        push!(rules, program_mh[1])\n        push!(programs, rulenode2expr(program_mh[1], g_4))\n        push!(iters, i)\n    end\n    pretty_table(HTML, [iters rules programs], header=[\"Run\", \"RuleNode\", \"Program\"])\nend</code></pre>\n<table><thead><tr class=\"header headerLastRow\"><th style=\"text-align: right;\">Run</th><th style=\"text-align: right;\">RuleNode</th><th style=\"text-align: right;\">Program</th></tr></thead><tbody><tr><td style=\"text-align: right;\">1</td><td style=\"text-align: right;\">8{6{9,9},8{1,5}}</td><td style=\"text-align: right;\">x * x - (1 - 5)</td></tr><tr><td style=\"text-align: right;\">2</td><td style=\"text-align: right;\">7{6{9,9},7{1,3}}</td><td style=\"text-align: right;\">x * x + (1 + 3)</td></tr><tr><td style=\"text-align: right;\">3</td><td style=\"text-align: right;\">8{6{9,9},8{1,5}}</td><td style=\"text-align: right;\">x * x - (1 - 5)</td></tr></tbody></table>\n\n\n<div class=\"markdown\"><h3>Very Large Scale Neighbourhood Search</h3><p>The second stochastic search method we consider is Very Large Scale Neighbourhood Search (VLSN). In each iteration, the algorithm searches the neighbourhood of the current candidate program for a local optimum, aiming to find a better candidate solution.</p><p>For more information, see <a href=\"https://backend.orbit.dtu.dk/ws/portalfiles/portal/5293785/Pisinger.pdf\">this article</a>.</p><p>Given the same grammar as before, we can try it with some simple examples.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>e_vlsn = x -&gt; 10</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-e_vlsn\">#11 (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_vlsn1, examples_vlsn1 = create_problem(e_vlsn)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_vlsn1\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 10)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 10)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_vlsn1 = VLSNSearchIterator(g_4, :X, examples_vlsn1, cost_function, max_depth=2) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_vlsn1\">VLSNSearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 2), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 10)], mean_squared_error, 2, 1, execute_on_input)</pre>\n\n<pre class='language-julia'><code class='language-julia'>program_vlsn1 = synth(problem_vlsn1, iterator_vlsn1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program_vlsn1\">(6{2,5}, optimal_program)</pre>\n\n<pre class='language-julia'><code class='language-julia'>e_vlsn2 = x -&gt; x</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-e_vlsn2\">#13 (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_vlsn2, examples_vlsn2 = create_problem(e_vlsn2)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_vlsn2\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 1), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 2), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 4), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 11), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 12), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 14), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 15), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 17), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 18), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 19), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 20)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 1), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 2), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 4), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 11), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 12), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 14), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 15), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 17), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 18), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 19), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 20)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_vlsn2 = VLSNSearchIterator(g_4, :X, examples_vlsn2, cost_function, max_depth=1) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_vlsn2\">VLSNSearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 1), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 1), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 2), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 4), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 11), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 12), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 14), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 15), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 17), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 18), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 19), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 20)], mean_squared_error, 2, 1, execute_on_input)</pre>\n\n<pre class='language-julia'><code class='language-julia'>program_vlsn2 = synth(problem_vlsn2, iterator_vlsn2)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program_vlsn2\">(9, optimal_program)</pre>\n\n\n<div class=\"markdown\"><h3>Simulated Annealing</h3><p>Simulated Annealing (SA) explores smaller, incremental changes to the candidate program in each iteration, gradually refining the solution. It is a variation of the hill-climbing algorithm: Instead of always selecting the best move, SA picks a random move. If the move improves the solution (i.e., the candidate program), it is accepted.</p><p>Occasionally, SA will accept a move that worsens the solution. This allows the algorithm to escape local optima and explore more of the solution space. However, this strategy follows a cooling (annealing) schedule: at the beginning (high temperature), the algorithm explores more broadly and is more likely to accept worse solutions. As the temperature decreases, it becomes more selective, accepting worse solutions less often.</p><p>For more information, see <a href=\"https://www.cs.cmu.edu/afs/cs.cmu.edu/project/learn-43/lib/photoz/.g/web/glossary/anneal.html\">this page</a>.</p></div>\n\n\n<div class=\"markdown\"><p>We use the same example as for MH. SA additionally has the option to specify the <code>initial_temperature</code> for the annealing (default <code>initial_temperature=1</code>). Let's see what effect changing the temperature from 1 to 2 has on the solution program.   </p></div>\n\n<pre class='language-julia'><code class='language-julia'>problem_sa, examples_sa = create_problem(e_mh)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_sa\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>initial_temperature1 = 1</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-initial_temperature1\">1</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_sa1 = SASearchIterator(g_4, :X, examples_sa, cost_function, max_depth=3, initial_temperature = initial_temperature1) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_sa1\">SASearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 3), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)], mean_squared_error, 1, 0.99, execute_on_input)</pre>\n\n<pre class='language-julia'><code class='language-julia'>program_sa1 = synth(problem_sa, iterator_sa1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program_sa1\">(7{4,6{9,9}}, optimal_program)</pre>\n\n<pre class='language-julia'><code class='language-julia'>initial_temperature2 = 2</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-initial_temperature2\">2</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_sa2 = SASearchIterator(g_4, :X, examples_sa, cost_function, max_depth=3, initial_temperature = initial_temperature2) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_sa2\">SASearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 3), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)], mean_squared_error, 2, 0.99, execute_on_input)</pre>\n\n","category":"page"},{"location":"tutorials/advanced_search/#Genetic-Search","page":"Advanced Search Procedures","title":"Genetic Search","text":"","category":"section"},{"location":"tutorials/advanced_search/","page":"Advanced Search Procedures","title":"Advanced Search Procedures","text":"<div class=\"markdown\">\n<p>Genetic search is a type of evolutionary algorithm, which simulates the process of natural selection. It evolves a population of candidate programs through operations like mutation, crossover (recombination), and selection. Then, the fitness of each program is assessed (i.e., how well it satisfies the given specifications). Only the 'fittest' programs are selected for the next generation, thus gradually refining the population of candidate programs.</p><p>For more information, see <a href=\"https://www.geeksforgeeks.org/genetic-algorithms/\">here</a>.</p><p>We show the example of finding a lambda function. Try varying the parameters of the genetic search to see what happens.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>e_gs = x -&gt; 3 * x * x + (x + 2)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-e_gs\">#15 (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_gs, examples_gs = create_problem(e_gs)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_gs\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 32), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 54), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 82), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 116), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 156), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 202), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 254), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 312), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 376), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 446), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 522), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 604), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 692), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 786), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 886), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 992), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 1104), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 1222)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 32), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 54), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 82), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 116), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 156), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 202), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 254), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 312), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 376), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 446), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 522), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 604), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 692), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 786), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 886), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 992), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 1104), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 1222)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_gs = GeneticSearchIterator(g_4, :X, examples_gs, population_size = 10, mutation_probability = 0.8, maximum_initial_population_depth = 3) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_gs\">GeneticSearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 9223372036854775807), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 32), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 54), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 82), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 116), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 156), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 202), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 254), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 312), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 376), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 446), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 522), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 604), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 692), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 786), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 886), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 992), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 1104), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 1222)], execute_on_input, 10, 0.8, 3)</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    program_gs, error_gs = synth(problem_gs, iterator_gs)\n    rulenode2expr(program_gs, g_4)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program_gs\">:((2 + (x - 2) * (x + x)) + x * (x + 5))</pre>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/advanced_search/","page":"Advanced Search Procedures","title":"Advanced Search Procedures","text":"EditURL = \"https://github.com/Herb-AI/Herb.jl/blob/main/docs/src/tutorials/advanced_search.jl\"","category":"page"},{"location":"tutorials/getting_started_with_constraints/","page":"Getting started with Constraints","title":"Getting started with Constraints","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"c414d5813d1e89547418b8875fcbab9216bfb067086cd79b127822d08dd93736\"\n    julia_version = \"1.11.3\"\n-->\n\n<div class=\"markdown\"><h1>Getting started with HerbConstraints</h1><p>When enumerating programs using a grammar, we will encounter many redundant programs. For example, <code>x</code>, <code>-(-x)</code> and <code>1 * x</code> are syntactically different programs, but they have the same semantics. Grammar constraints aim to speed up synthesis by eliminating such redundant programs and thereby reducing the size of the program space.</p></div>\n\n\n<div class=\"markdown\"><h3>Setup</h3><p>For this tutorial, we need to import the following modules of the Herb.jl framework:</p><ul><li><p><code>HerbCore</code> for the necessary data structures, like <code>Hole</code>s and <code>RuleNode</code>s</p></li><li><p><code>HerbGrammar</code> to define the grammar</p></li><li><p><code>HerbConstraints</code> to define the constraints</p></li><li><p><code>HerbSearch</code> to execute a constrained enumeration</p></li></ul><p>We will also redefine the simple arithmetic grammar from the previous tutorial.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>grammar = @csgrammar begin\n    Int = 1\n    Int = x\n    Int = - Int\n    Int = Int + Int\n    Int = Int * Int\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grammar\">1: Int = 1\n2: Int = x\n3: Int = -Int\n4: Int = Int + Int\n5: Int = Int * Int\n</pre>\n\n\n<div class=\"markdown\"><h3>Working with constraints</h3><p>To show the effects of constraints, we will first enumerate all programs without constraints (up to a maximum size of 3 AST nodes).</p><p>(To make sure the grammar doesn't have any constraints, we can clear the constraints using <code>clearconstraints!</code>. This is not needed at this point, but could come in handy if your REPL holds a reference to a constrained version of the grammar)</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n    iter_1 = BFSIterator(grammar, :Int, max_size=3)\n    \n    for program ∈ iter_1\n        println(rulenode2expr(program, grammar))\n    end\n    \nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Upon inspection, we can already see some redundant programs, like <code>1 * 1</code> and <code>-(-1)</code>. To eliminate these redundant programs, we will set up some constraints that prevent these patterns from appearing. Then we will create another iterator to enumerate all programs that satisfy the defined grammar constraints.</p><p>To make the forbidden pattern constraint general, we will use a special type of rulenode: <code>VarNode(:A)</code>. This node matches with any subtree and can be used to forbid multiple forbidden patterns using a single constraint. For example, <code>Forbidden(RuleNode(minus, [RuleNode(minus, [VarNode(:A)])])))</code> forbids:</p><ul><li><p><code>-(-1)</code></p></li><li><p><code>-(-X)</code></p></li><li><p><code>-(-(1 + 1))</code></p></li><li><p><code>1 + -(-(1 + 1))</code></p></li><li><p>etc</p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    one = 1\n    x = 2\n    minus = 3\n    plus = 4\n    times = 5\n    \n    addconstraint!(grammar, Forbidden(RuleNode(times, [RuleNode(one), VarNode(:A)])))        # forbid 1*A\n    addconstraint!(grammar, Forbidden(RuleNode(minus, [RuleNode(minus, [VarNode(:A)])])))    # forbid -(-A)\n    \n    iter_2 = BFSIterator(grammar, :Int, max_size=3)\n    \n    for program ∈ iter_2\n        println(rulenode2expr(program, grammar))\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3>Forbidden Constraint</h3><p>The <code>Forbidden</code> constraint forbids any subtree in the program that matches a given template tree. Such a template tree can consist of 3 node types:</p><ul><li><p><code>RuleNode(1)</code>. Matches exactly the given rule.</p></li><li><p><code>DomainRuleNode(BitVector((0, 0, 0, 1, 1)), children)</code>. Matches any rule in its bitvector domain. In this case, rule 4 and 5.</p></li><li><p><code>VarNode(:A)</code>. Matches any subtree. If another VarNode of the same name is used, the subtrees have to be the same.</p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    #this constraint forbids A+A and A*A\n    constraint_1 = Forbidden(DomainRuleNode(BitVector((0, 0, 0, 1, 1)), [VarNode(:A), VarNode(:A)]))\n    \n    # Without this constraint, we encounter 154 programs\n    clearconstraints!(grammar)\n    iter_3 = BFSIterator(grammar, :Int, max_size=5)\n    println(length(iter_3))\n    \n    # With this constraint, we encounter 106 programs\n    clearconstraints!(grammar)\n    addconstraint!(grammar, constraint_1)\n    iter_4 = BFSIterator(grammar, :Int, max_size=5)\n    println(length(iter_4))\n    \nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3>Contains Constraint</h3><p>The <code>Contains</code> constraint enforces that a given rule appears in the program tree at least once. </p><p>In the arithmetic grammar, this constraint can be used to ensure the input symbol <code>x</code> is used in the program. Otherwise, the program is just a constant.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n    addconstraint!(grammar, Contains(2)) #rule 2 should be used in the program\n    iter_5 = BFSIterator(grammar, :Int, max_size=3)\n    \n    for program ∈ iter_5\n        println(rulenode2expr(program, grammar))\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3>Contains Subtree Constraint</h3><p>Similarly to the <code>Contains</code> constraint, the <code>ContainsSubtree</code> can be used to enforce a given template tree is used in the program at least once.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n    addconstraint!(grammar, ContainsSubtree(RuleNode(times, [RuleNode(x), RuleNode(x)]))) #x*x should be in the program tree\n    iter_6 = BFSIterator(grammar, :Int, max_size=4)\n    \n    for program ∈ iter_6\n        println(rulenode2expr(program, grammar))\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3>Ordered Constraint</h3><p>The <code>Ordered</code> constraint enforces an <code>&lt;=</code> ordering on a provided list of variables. With this constraint, we can break symmetries based on commutativity. For example, <code>1+x</code> and <code>x+1</code> are semantically equivalent. By imposing an <code>Ordered</code> constraint, we can eliminate one of the symmetric variants.</p><p>To define an <code>Ordered</code> constraint, we need to provide it with a template tree including at least two differently named <code>VarNode</code>s. And additionally, an ordering of the variables in the tree.</p><p>In the upcoming example we will set up a template tree representing <code>a+b</code> and <code>a*b</code>. Then, we will impose an ordering <code>a&lt;=b</code> on all the subtrees that match the template.</p><p>The result is that our iterator skips the redundant programs <code>x+1</code> and <code>x*1</code>, as they are already represented by <code>1+x</code> and <code>1*x</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n    \n    template_tree = DomainRuleNode(BitVector((0, 0, 0, 1, 1)), [VarNode(:a), VarNode(:b)])\n    order = [:a, :b]\n    \n    addconstraint!(grammar, Ordered(template_tree, order))\n    iter_7 = BFSIterator(grammar, :Int, max_size=3)\n    \n    for program ∈ iter_7\n        println(rulenode2expr(program, grammar))\n    end\n    \nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3>Forbidden Sequence Constraint</h3><p>The <code>ForbiddenSequence</code> constraints forbids a given sequence of rule nodes in a vertical path of the tree. </p><p>An optional second argument, <code>ignore_if</code>, can be used to overrule the constraint in case any of the rules on the <code>ignore_if</code> list are present. </p><p>Below we will define the constraint <code>ForbiddenSequence([plus, one], ignore_if=[times])</code>. It forbids an <code>1</code> after an <code>+</code> unless an <code>*</code> disrupts the sequence.</p><p>This constraint will <strong>forbid</strong> the following programs:</p><ul><li><p>x + 1</p></li><li><p>x + -1</p></li><li><p>x + -(-1)</p></li><li><p>x + (x + 1)</p></li><li><p>x * (x + 1)</p></li></ul><p>But it will <strong>allow</strong> the following program (as * disrupts the sequence):</p><ul><li><p>x + (x * 1)</p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    constraint_2 = ForbiddenSequence([plus, one], ignore_if=[times])\n    addconstraint!(grammar, constraint_2)\n    iter_8 = BFSIterator(grammar, :Int, max_size=3)\n    \n    for program ∈ iter_8\n        println(rulenode2expr(program, grammar))\n    end\n    \nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3>Custom Constraint</h3><p>To implement a new constraint, we need to define two structs: an <code>AbstractGrammarConstraint</code> and an <code>AbstractLocalConstraint</code>.</p><p>A <strong>grammar constraint</strong> is a high-level constraint on the grammar itself and does not refer to a location in the tree. For example, the <code>Forbidden</code> constraint is responsible for forbidding a template tree everywhere in the tree. To divide the work of constraint propagation, the grammar constraint will post several local constraints that are responsible for propagating the constraint at each particular location.</p><p>A <strong>local constraint</strong> is a rooted version of a grammar constraint. Each local constraint holds a <code>path</code> field that points to a location in the tree where this constraint applies.</p></div>\n\n\n<div class=\"markdown\"><p>Suppose we want to implement a simple custom constraint that forbids a given <code>rule</code> twice in a row. </p><p>Each time a new AST node is added to a tree, the <code>on_new_node</code> function is called to notify that an unseen node has been added to the tree at path <code>path</code>. Our grammar constraint has the opportunity to react to this event. In this example, we will post a new local constraint at the new location using the <code>post!</code> function.</p><p>(Don't worry about the <code>HerbConstraints.</code> prefixes. Normally, constraints are defined within the HerbConstraints repository, so there is no need to specify the namespace)</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    \"\"\"\n    Forbids the consecutive application of the specified rule.\n    For example, CustomConstraint(4) forbids the tree 4(1, 4(1, 1)) as it applies rule 4 twice in a row.\n    \"\"\"\n    struct ForbidConsecutive &lt;: AbstractGrammarConstraint\n        rule::Int\n    end\n    \n    \"\"\"\n    Post a local constraint on each new node that appears in the tree\n    \"\"\"\n    function HerbConstraints.on_new_node(solver::Solver, constraint::ForbidConsecutive, path::Vector{Int})\n        HerbConstraints.post!(solver, LocalForbidConsecutive(path, constraint.rule))\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Next, we will define our local constraint. This constraint is responsible for propagating the constraint at a given path. The <code>propagate!</code> method can use several solver functions to manipulate the tree. The following <strong>tree manipulations</strong> can be used to remove rules from the domain of a hole at a given path:</p><ul><li><p><code>remove!(solver::Solver, path::Vector{Int}, rule_index::Int)</code></p></li><li><p><code>remove!(solver::Solver, path::Vector{Int}, rules::Vector{Int})</code></p></li><li><p><code>remove_all_but!(solver::Solver, path::Vector{Int}, new_domain::BitVector)</code></p></li><li><p><code>remove_above!(solver::Solver, path::Vector{Int}, rule_index::Int)</code></p></li><li><p><code>remove_below!(solver::Solver, path::Vector{Int}, rule_index::Int)</code></p></li><li><p><code>make_equal!(solver::Solver, node1::AbstractRuleNode, node2::AbstractRuleNode)</code> (a high level manipulation that requires <code>node1</code> and <code>node2</code> to be in the tree)</p></li></ul><p>In addition to tree manipulations, the following solver functions can be used to communicate new information to the solver:</p><ul><li><p><code>set_infeasible!(solver)</code>. If a propagator detects an inconsistency, the solver should be notified and cancel any other scheduled propagators.</p></li><li><p><code>deactivate!(solver, constraint)</code>.  If a constraint is satisfied, it should deactivate itself to prevent re-propagation.</p></li><li><p><code>post!(solver, constraint)</code>  A constraint is allowed to post new local constraints. This might be helpful if a constraint can be reduced to a smaller constraint.</p></li></ul><p>The solver manages all constraints and the program tree we propagate on. Applying tree manipulations might cause a chain reaction of other propagators, so the shape of the tree might update as we propagate. The get the latest information about the tree, we should use the following getter functions:</p><ul><li><p><code>get_tree(solver)</code> returns the root node of the current (partial) program tree</p></li><li><p><code>isfeasible(solver)</code> returns the a flag indicating if the solver is not violating any (other) constraints.</p></li><li><p><code>get_path(solver, node)</code> returns the path at which the node is located.</p></li><li><p><code>get_node_at_location(solver, path)</code> returns the node that is currently at the given path (be aware that this instance might be replaced by manipulations).</p></li><li><p><code>get_hole_at_location(solver, path)</code> same as get node at location, but asserts the node is a hole (domain size &gt;= 2).</p></li></ul><p>To get information about a node, we can use the following getter functions:</p><ul><li><p><code>isfilled(node)</code>. Returns true if the node is a <code>RuleNode</code> or has domain size 1.</p></li><li><p><code>get_rule(node)</code>. Get the rule of a filled node.</p></li><li><p><code>get_children(node)</code>. Get the children of a node.</p></li><li><p><code>node.domain[rule]</code>. Given the node is a hole, return true if <code>rule</code> is in the domain.</p></li></ul><p>Finally, another useful function for propagators is <code>pattern_match(node1, node2)</code>. This function compares two trees and returns a <code>PatternMatchResult</code> that indicates if the nodes match, and potentially indicate which holes need to be filled to complete the match.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    \"\"\"\n    Forbids the consecutive application of the specified rule at path `path`.\n    \"\"\"\n    struct LocalForbidConsecutive &lt;: AbstractLocalConstraint\n        path::Vector{Int}\n        rule::Int\n    end\n    \n    \"\"\"\n    Propagates the constraints by preventing a consecutive application of the specified rule.\n    \"\"\"\n    function HerbConstraints.propagate!(solver::Solver, constraint::LocalForbidConsecutive)\n        node = get_node_at_location(solver, constraint.path)\n        if isfilled(node)\n            if get_rule(node) == constraint.rule\n                #the specified rule is used, make sure the rule will not be used by any of the children\n                for (i, child) ∈ enumerate(get_children(node))\n                    if isfilled(child)\n                        if get_rule(child) == constraint.rule\n                            #the specified rule was used twice in a row, which is violating the constraint\n                            set_infeasible!(solver)\n                            return\n                        end\n                    elseif child.domain[constraint.rule]\n                        child_path = push!(copy(constraint.path), i)\n                        remove!(solver, child_path, constraint.rule) # remove the rule from the domain of the child\n                    end\n                end\n            end\n        elseif node.domain[constraint.rule]\n            #our node is a hole with the specified rule in its domain\n            #we will now check if any of the children already uses the specified rule\n            softfail = false\n            for (i, child) ∈ enumerate(get_children(node))\n                if isfilled(child)\n                    if get_rule(child) == constraint.rule\n                        #the child holds the specified rule, so the parent cannot have this rule\n                        remove!(solver, constraint.path, constraint.rule)\n                    end\n                elseif child.domain[constraint.rule]\n                    #the child is a hole and contains the specified node. since there are 2 holes involved, we will softfail.\n                    softfail = true\n                end\n            end\n            if softfail\n                #we cannot deactivate the constraint, because it needs to be repropagated\n                return\n            end\n        end\n    \n        #the constraint is satisfied and can be deactivated\n        HerbConstraints.deactivate!(solver, constraint)\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Posting a local constraint will trigger the initial propagation. To re-propagate, the constraint needs to be rescheduled for propagation.</p><p>Whenever the tree is manipulated, we will make a <code>shouldschedule</code> check to see if our constraint needs to be rescheduled for propagation based on the manipulation.</p><p>In our case, we want to repropagate if either:</p><ul><li><p>a tree manipulation occurred at the <code>constraint.path</code></p></li><li><p>a tree manipulation occurred at the child of the <code>constraint.path</code></p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>\n\"\"\"\nGets called whenever an tree manipulation occurs at the given `path`.\nReturns true iff the `constraint` should be rescheduled for propagation.\n\"\"\"\nfunction HerbConstraints.shouldschedule(solver::Solver, constraint::LocalForbidConsecutive, path::Vector{Int})::Bool\n    return (path == constraint.path) || (path == constraint.path[1:end-1])\nend\n</code></pre>\n\n\n\n<div class=\"markdown\"><p>With all the components implemented, we can do a constrained enumeration using our new <code>ForbidConsecutive</code> constraint.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n    \n    addconstraint!(grammar, ForbidConsecutive(minus))\n    addconstraint!(grammar, ForbidConsecutive(plus))\n    addconstraint!(grammar, ForbidConsecutive(times))\n    \n    iter = BFSIterator(grammar, :Int, max_size=6)\n    \n    for program ∈ iter\n        println(rulenode2expr(program, grammar))\n    end\nend</code></pre>\n\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/getting_started_with_constraints/","page":"Getting started with Constraints","title":"Getting started with Constraints","text":"EditURL = \"https://github.com/Herb-AI/Herb.jl/blob/main/docs/src/tutorials/getting_started_with_constraints.jl\"","category":"page"},{"location":"HerbInterpret/#HerbInterpret_docs","page":"HerbInterpret.jl","title":"HerbInterpret.jl Documentation","text":"","category":"section"},{"location":"HerbInterpret/","page":"HerbInterpret.jl","title":"HerbInterpret.jl","text":"CurrentModule=HerbInterpret","category":"page"},{"location":"HerbInterpret/","page":"HerbInterpret.jl","title":"HerbInterpret.jl","text":"Modules = [HerbInterpret]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbInterpret/#HerbInterpret.evaluate_program-Tuple{RuleNode, Vector{<:IOExample}, AbstractGrammar, Function}","page":"HerbInterpret.jl","title":"HerbInterpret.evaluate_program","text":"evaluate_program(program::RuleNode, examples::Vector{<:IOExample}, grammar::AbstractGrammar, evaluation_function::Function)\n\nRuns a program on the examples and returns tuples of actual desired output and the program's output\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{AbstractGrammar, RuleNode, Dict{Symbol, T}}} where T","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_input","text":"execute_on_input(grammar::AbstractGrammar, program::RuleNode, input::Dict{Symbol, T})::Any where T\n\nConverts a RuleNode program into an expression using a given grammar, then evaluates this expression with a single input dictionary input and a symbol table derived from the grammar using execute_on_input(tab::SymbolTable, expr::Any, input::Dict{Symbol, T}).\n\nArguments\n\ngrammar::AbstractGrammar: A grammar object used to convert the RuleNode into an executable expression.\nprogram::RuleNode: The program, represented as a RuleNode, to be converted and evaluated.\ninput::Dict{Symbol, T}: A dictionary providing input values for symbols used in the generated expression.\n\nReturns\n\nAny: The result of evaluating the generated expression with the given input dictionary.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{AbstractGrammar, RuleNode, Vector{T}}} where T<:(Dict{Symbol})","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_input","text":"execute_on_input(grammar::AbstractGrammar, program::RuleNode, input::Vector{T})::Vector{Any} where T <: Dict{Symbol, <:Any}\n\nConverts a RuleNode program into an expression using a given grammar, then evaluates this expression for each input dictionary in a vector input and a symbol table derived from the grammar using execute_on_input(tab::SymbolTable, expr::Any, input::Dict{Symbol, T}).\n\nArguments\n\ngrammar::AbstractGrammar: A grammar object used to convert the RuleNode into an executable expression.\nprogram::RuleNode: The program, represented as a RuleNode, to be converted and evaluated.\ninput::Vector{T}: A vector of dictionaries, each providing input values for symbols used in the generated expression.\n\nReturns\n\nVector{Any}: A vector containing the results of evaluating the generated expression for each input dictionary.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{Dict{Symbol, Any}, Any, Dict{Symbol, T}}} where T","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_input","text":"execute_on_input(tab::SymbolTable, expr::Any, input::Dict{Symbol, T})::Any where T\n\nEvaluates an expression expr within the context of a symbol table tab and a single input dictionary input.  The input dictionary keys should match the symbols used in the expression, and their values are used during the expression's evaluation.\n\nArguments\n\ntab::SymbolTable: A symbol table containing predefined symbols and their associated values or functions.\nexpr::Any: The expression to be evaluated. Can be any Julia expression that is valid within the context of the provided symbol table and input.\ninput::Dict{Symbol, T}: A dictionary where each key is a symbol used in the expression, and the value is the corresponding value to be used in the expression's evaluation. The type T can be any type.\n\nReturns\n\nAny: The result of evaluating the expression with the given symbol table and input dictionary.\n\nwarning: Warning\nThis function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{Dict{Symbol, Any}, Any, Vector{T}}} where T<:(Dict{Symbol})","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_input","text":"execute_on_input(tab::SymbolTable, expr::Any, input::Vector{T})::Vector{<:Any} where T <: Dict{Symbol, <:Any}\n\nWrapper around execute_on_input to execute all inputs given as an array.\n\nArguments\n\ntab::SymbolTable: A symbol table containing predefined symbols and their associated values or functions.\nexpr::Any: The expression to be evaluated for each input dictionary.\ninputs::Vector{T}: A vector of dictionaries, each serving as an individual set of inputs for the expression's evaluation.\n\nReturns\n\nVector{<:Any}: A vector containing the results of evaluating the expression for each input dictionary.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.interpret-Tuple{Dict{Symbol, Any}, Any}","page":"HerbInterpret.jl","title":"HerbInterpret.interpret","text":"interpret(tab::SymbolTable, ex::Expr)\n\nEvaluates an expression without compiling it. Uses AST and symbol lookups. Only supports :call and :(=) expressions at the moment.\n\nExample usage:\n\ntab = SymbolTable(:f => f, :x => x)\nex = :(f(x))\ninterpret(tab, ex)\n\nWARNING: This function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.test_all_examples-Tuple{Dict{Symbol, Any}, Any, Vector{IOExample}}","page":"HerbInterpret.jl","title":"HerbInterpret.test_all_examples","text":"test_all_examples(tab::SymbolTable, expr::Any, examples::Vector{IOExample})::Vector{Bool}\n\nwarning: Warning\nThis function is deprecated. Please use execute_on_input instead.\n\nRuns the interpreter on all examples with the given input table and expression.  The symbol table defines everything (functions, symbols) that are not input variables to the program to be synthesised. Returns a list of true/false values indicating if the expression satisfies the corresponding example. WARNING: This function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.test_examples-Tuple{Dict{Symbol, Any}, Any, Vector{IOExample}}","page":"HerbInterpret.jl","title":"HerbInterpret.test_examples","text":"test_examples(tab::SymbolTable, expr::Any, examples::Vector{IOExample})::Bool\n\nwarning: Warning\nThis function is deprecated. Please use execute_on_input instead.\n\nEvaluates all examples and returns true iff all examples pass. Shortcircuits as soon as an example is found for which the program doesn't work.  Returns false if one of the examples produces an error.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#Index","page":"HerbInterpret.jl","title":"Index","text":"","category":"section"},{"location":"HerbInterpret/","page":"HerbInterpret.jl","title":"HerbInterpret.jl","text":"","category":"page"},{"location":"tutorials/getting_started_with_herb/","page":"A more verbose getting started with Herb.jl","title":"A more verbose getting started with Herb.jl","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"23f1b9e657e98a182aa3a400472634ac1e30abf3e8b119d102426e9fa1d43ffb\"\n    julia_version = \"1.11.3\"\n-->\n\n<div class=\"markdown\"><h1>Search</h1><p>This notebook describes how you can search a program space as defined by a grammar. Specifically, we will look at example-based search, where the goal is to find a program that is able to transform the inputs of every example to the corresponding output.</p></div>\n\n\n<div class=\"markdown\"><h3>Setup</h3><p>First, we start with the setup. We need access to all the function in the Herb.jl framework.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><h3>Defining the program space</h3><p>Next, we start by creating a grammar. We define a context-free grammar as a <a href=\"@ref\"><code>HerbGrammar.ContextSpecificGrammar</code></a> without any constraints. A context-free grammar is just a simple set of production rules for defining combinations of terminal symbols (in our case integers). </p><p>Alternatively we could define a context-sensitive grammar, when the production rules only hold in a certain context. For more information on this, please see our tutorial on <a href=\"defining_grammars.md\">defining grammars</a>.</p><p>For now, we specify a simple grammar (using the <code>@csgrammar</code> macro) for dealing with integers and explain all the rules individually:</p><ol><li><p>First, we specify our number values and constrain them to being positive even integers.</p></li><li><p>Then, we can also use the variable <code>x</code> to hold an integer.</p></li><li><p>The third rule determines we can add two integers.</p></li><li><p>The fourth rule determines we can subtract an integer from another.</p></li><li><p>Finally, we also allow the multiplication of two integers.</p></li></ol><p>If you run this cell, you can see all the rules rolled out.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g = HerbGrammar.@csgrammar begin\n    Number = 0|2|4|6|8\n    Number = x\n    Number = Number + Number\n    Number = Number - Number\n    Number = Number * Number\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g\">1: Number = 0\n2: Number = 2\n3: Number = 4\n4: Number = 6\n5: Number = 8\n6: Number = x\n7: Number = Number + Number\n8: Number = Number - Number\n9: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><h3>Defining the problem</h3></div>\n\n\n<div class=\"markdown\"><p>As mentioned before, we are looking at example-based search.  This means that the problem is defined by a set of input-output examples.  A single example hence consists of an input and an output. The input is defined as a dictionary, with a value assigned to each variable in the grammar. It is important to write the variable name as a <code>Symbol</code> instead of a string. A <code>Symbol</code> in Julia is written with a colon prefix, i.e. <code>:x</code>.  The output of the input-output example is just a single value for this specific grammar, but could possibly relate to e.g. arrays of values, too.</p><p>In the cell below we automatically generate some examples for <code>x</code> assigning values <code>1-5</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'># Create input-output examples\nexamples = [HerbSpecification.IOExample(Dict(:x =&gt; x), 4x + 6) for x ∈ 1:5]</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples\">5-element Vector{IOExample{Int64, Int64}}:\n IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10)\n IOExample{Int64, Int64}(Dict(:x =&gt; 2), 14)\n IOExample{Int64, Int64}(Dict(:x =&gt; 3), 18)\n IOExample{Int64, Int64}(Dict(:x =&gt; 4), 22)\n IOExample{Int64, Int64}(Dict(:x =&gt; 5), 26)</pre>\n\n\n<div class=\"markdown\"><p>Now that we have some input-output examples, we can define the problem.  Next to the examples, a problem also contains a name meant to link to the file path, which can be used to keep track of current examples.  For now, this is irrelevant, and you can give the program any name you like.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>problem_1 = HerbSpecification.Problem(\"example\", examples)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-problem_1\">Problem{Vector{IOExample{Int64, Int64}}}(\"example\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 14), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 18), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 22), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 26)])</pre>\n\n\n<div class=\"markdown\"><h3>Searching</h3><p>Now that we have defined the search space and the goal of the search, we can start the search. </p><p>Of course, our problem is underdefined as there might be multiple programs that satisfy our examples.  Let us consider the case where we also have a ternary if-then-else operator and standard boolean operators in our grammar: we could synthesize the program <code>x ≤ 5 ? 3x+5 : 0</code>.  This program satisfies all our examples, but we don't expect it to generalize very well.</p><p>To search through a program space, we first need to define a <a href=\"@ref\"><code>HerbSearch.ProgramIterator</code></a>, which can be instantiated with different iterators, for now we use a simple <a href=\"@ref\"><code>HerbSearch.BFSIterator</code></a>. For more advanced search methods check out our tutorial on <a href=\".advanced_search.md\">advanced search</a>. For more information about iterators, check out our tutorial on <a href=\".working_with_interpreters.md\">working with interpreters</a>. </p><p>In general, we assume that a smaller program is more general than a larger program.  Therefore, we search for the smallest program in our grammar that satisfies our examples.  This can be done using a breadth-first search over the program/search space.</p><p>This search is very basic; it makes use of an enumeration technique, where we enumerate programs one-by-one until we find a program that matches our examples. The search procedure has a built-in default evaluator to verify the candidate programs with the given input. The search procedure also has a built-in search procedure using breadth-first search. </p><p>So, we only need to give our grammar and the problem to our search procedure, along with a starting <code>Symbol</code>, in our case a <code>Number</code>. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator_1 = BFSIterator(g, :Number)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_1\">BFSIterator(GenericSolver(1: Number = 0\n2: Number = 2\n3: Number = 4\n4: Number = 6\n5: Number = 8\n6: Number = x\n7: Number = Number + Number\n8: Number = Number - Number\n9: Number = Number * Number\n, SolverState(hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, true, false, 9223372036854775807, 9223372036854775807))</pre>\n\n<pre class='language-julia'><code class='language-julia'>synth(problem_1, iterator_1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash471578\">(7{9{6,3},4}, optimal_program)</pre>\n\n\n<div class=\"markdown\"><p>As you can see, the search procedure found the correct program!</p></div>\n\n\n<div class=\"markdown\"><h3>Defining the search procedure</h3><p>In the previous case, we used the built-ins of the search procedure. However, we can also give a custom enumerator to the search procedure and define a few more values.</p><p>We first define a new problem to test with, we are looking for the programs that can compute the value <code>168</code>. We immediately pass the examples to the problem and then set up the new search.</p><p>Search is done by passing the grammar, the problem and the starting point like before. We now also specify the enumeration function to be used, and now we use depth-first search. Then, we give the maximum depth of the programs we want to search for <code>(3)</code>, the maximum number of nodes in the Abstract Syntax Tree that exists during search <code>(10)</code>, and the maximum time in seconds allowed for the search.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    problem_2 = HerbSpecification.Problem(\"example2\", [HerbSpecification.IOExample(Dict(:x =&gt; x), 168) for x ∈ 1:5])\n    iterator_2 = HerbSearch.BFSIterator(g, :Number, max_depth=4, max_size=30)\n    expr_2, flag_2 = HerbSearch.synth(problem_2, iterator_2)\n    println(expr_2)\n    program_2 = rulenode2expr(expr_2, g)\n    println(program_2)\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>We see that our synthesizer can find a program to construct the value <code>168</code>, though a fun experiment would be trying to get the value <code>167</code>, what do you think would happen? You can try below, using the same iterator.</p><p>In any case, this concludes our first introduction to the <code>Herb.jl</code> program synthesis framework. You can see more examples in this repository, or explore yourself. Enjoy!</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    problem_3 = HerbSpecification.Problem(\"example3\", [HerbSpecification.IOExample(Dict(:x =&gt; x), 167) for x ∈ 1:5])\n    expr_3, flag_3 = HerbSearch.synth(problem_3, iterator_2)\n    println(expr_3)\n    program_3 = rulenode2expr(expr_3, g)\n    println(program_3)\nend</code></pre>\n\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/getting_started_with_herb/","page":"A more verbose getting started with Herb.jl","title":"A more verbose getting started with Herb.jl","text":"EditURL = \"https://github.com/Herb-AI/Herb.jl/blob/main/docs/src/tutorials/getting_started_with_herb.jl\"","category":"page"},{"location":"get_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"You can either paste this code into the Julia REPL or into a separate file, e.g. get_started.jl. If using a separate file you can execute using julia get_started.jl or julia --project=. get_started.jl depending on whether you installed Herb.jl globally or in a project.","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"To begin, we need to import Herb.","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"using Herb","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"To define a program synthesis problem, we need a grammar and specification. ","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"First, a grammar can be constructed using the @csgrammar macro included in HerbGrammar. ","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"Here, we describe a simple integer arithmetic example, that can add and multiply an input variable x or the integers 1,2, using","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"g = @csgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"Second, the problem specification can be provided using e.g. input/output examples using HerbSpecification. Inputs are provided as a Dict assigning values to variables, and outputs as arbitrary values. The problem itself is then a list of IOExamples using","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"problem = Problem([IOExample(Dict(:x => x), 2x+1) for x ∈ 1:5])","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"The problem is given now, let us search for a solution with HerbSearch. For now, we will just use the default parameters searching for a satisfying program over the grammar, given the problem and a starting symbol using","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"iterator = BFSIterator(g, :Number, max_depth=5)\nsolution, flag = synth(problem, iterator)\nprintln(solution)","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"There are various ways to adapt the search technique to your needs. Please have a look at the synth documentation.","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"Eventually, we want to test our solution on some other inputs using HerbInterpret. We transform our grammar g to a Julia expression with Symboltable(g), add our solution and the input, assigning the value 6 to the variable x.","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"program = rulenode2expr(solution, g) # should yield 2*6+1\nprintln(program)\n\noutput = execute_on_input(SymbolTable(g), program, Dict(:x => 6)) \nprintln(output)","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"If you run the completed code it will output both the generated Julia expression and the result from assigning value.","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"Just like that we tackled (almost) all modules of Herb.jl.","category":"page"},{"location":"get_started/#Where-to-go-from-here?","page":"Getting Started","title":"Where to go from here?","text":"","category":"section"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"See our other tutorials!","category":"page"},{"location":"get_started/#The-full-code-example","page":"Getting Started","title":"The full code example","text":"","category":"section"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"using Herb\n\n# define our very simple context-free grammar\n# Can add and multiply an input variable x or the integers 1,2.\ng = @csgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend\n\nproblem = Problem([IOExample(Dict(:x => x), 2x+1) for x ∈ 1:5])\niterator = BFSIterator(g, :Number, max_depth=5)\n\nsolution, flag = synth(problem, iterator)\nprogram = rulenode2expr(solution, g) # should yield 2*6 +1 \nprintln(program)\n\noutput = execute_on_input(SymbolTable(g), program, Dict(:x => 6)) \nprintln(output)\n","category":"page"},{"location":"tutorials/defining_grammars/","page":"Defining Grammars in Herb.jl","title":"Defining Grammars in Herb.jl","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"0330d4bbe9d6758f53e868ee4a11842e6f7d415387d452eb5952462d1c51c12a\"\n    julia_version = \"1.11.3\"\n-->\n\n<div class=\"markdown\"><h1>Defining Grammars in Herb.jl using HerbGrammar</h1><p>The program space in Herb.jl is defined using a grammar.  This notebook demonstrates how such a grammar can be created.  There are multiple kinds of grammars, but they can all be defined in a very similar way.</p></div>\n\n\n<div class=\"markdown\"><h3>Setup</h3><p>First, we import the necessary Herb packages.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><h3>Creating a simple grammar</h3><p>This cell contains a very simple arithmetic grammar.  The grammar is defined using the <code>@csgrammar</code> macro.  This macro converts the grammar definition in the form of a Julia expression into Herb's internal grammar representation.  Macro's are executed during compilation. If you want to load a grammar during execution, have a look at the <code>HerbGrammar.expr2csgrammar</code> function.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g₁ = HerbGrammar.@csgrammar begin\n    Int = 1\n    Int = 2\n    Int = 3\n    Int = Int * Int\n    Int = Int + Int\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g₁\">1: Int = 1\n2: Int = 2\n3: Int = 3\n4: Int = Int * Int\n5: Int = Int + Int\n</pre>\n\n\n<div class=\"markdown\"><p>Defining every integer one-by-one can be quite tedious. Therefore, it is also possible to use the following syntax that makes use of a Julia iterator:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g₂ = HerbGrammar.@csgrammar begin\n    Int = |(0:9)\n    Int = Int * Int\n    Int = Int + Int\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g₂\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = Int + Int\n</pre>\n\n\n<div class=\"markdown\"><p>You can do the same with lists:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g₃ = HerbGrammar.@csgrammar begin\n    Int = |([0, 2, 4, 6, 8])\n    Int = Int * Int\n    Int = Int + Int\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g₃\">1: Int = 0\n2: Int = 2\n3: Int = 4\n4: Int = 6\n5: Int = 8\n6: Int = Int * Int\n7: Int = Int + Int\n</pre>\n\n\n<div class=\"markdown\"><p>Variables can also be added to the grammar by just using the variable name:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g₄ = HerbGrammar.@csgrammar begin\n    Int = |(0:9)\n    Int = Int * Int\n    Int = Int + Int\n    Int = x\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g₄\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = Int + Int\n13: Int = x\n</pre>\n\n\n<div class=\"markdown\"><p>Grammars can also work with functions.  After all, <code>+</code> and <code>*</code> are just infix operators for Julia's identically-named functions. You can use functions that are provided by Julia, or functions that you wrote yourself:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    f(a) = a + 1\n    \n    g₅ = HerbGrammar.@csgrammar begin\n        Int = |(0:9)\n        Int = Int * Int\n        Int = Int + Int\n        Int = f(Int)\n        Int = x\n    end\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-f\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = Int + Int\n13: Int = f(Int)\n14: Int = x\n</pre>\n\n\n<div class=\"markdown\"><p>Similarly, we can also define the operator times (x) manually.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    ×(a, b) = a * b\n    \n    g₆ = HerbGrammar.@csgrammar begin\n        Int = |(0:9)\n        Int = a\n        Int = Int + Int\n        Int = Int × Int\n    end\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g₆\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = a\n12: Int = Int + Int\n13: Int = Int × Int\n</pre>\n\n\n<div class=\"markdown\"><h3>Working with grammars</h3><p>If you want to implement something using these grammars, it is useful to know about the functions that you can use to manipulate grammars and extract information.  This section is not complete, but it aims to give an overview of the most important functions. </p><p>It is recommended to also read up on <a href=\"https://docs.julialang.org/en/v1/manual/metaprogramming/\">Julia metaprogramming</a> if you are not already familiar with the concept.</p><p>One of the most important things about grammars is that each rule has an index associated with it:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    g₇ = HerbGrammar.@csgrammar begin\n        Int = |(0:9)\n        Int = Int + Int\n        Int = Int * Int\n        Int = x\n    end\n    \n    collect(enumerate(g₇.rules))\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g₇\">13-element Vector{Tuple{Int64, Any}}:\n (1, 0)\n (2, 1)\n (3, 2)\n (4, 3)\n (5, 4)\n (6, 5)\n (7, 6)\n (8, 7)\n (9, 8)\n (10, 9)\n (11, :(Int + Int))\n (12, :(Int * Int))\n (13, :x)</pre>\n\n\n<div class=\"markdown\"><p>We can use this index to extract information from the grammar.</p></div>\n\n\n<div class=\"markdown\"><h3>isterminal</h3><p><code>isterminal</code> returns <code>true</code> if a rule is terminal, i.e. it cannot be expanded. For example, rule 1 is terminal, but rule 11 is not, since it contains the non-terminal symbol <code>:Int</code>. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.isterminal(g₇, 1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash594982\">true</pre>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.isterminal(g₇, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash518469\">false</pre>\n\n\n<div class=\"markdown\"><h3>return_type</h3><p>This function is rather obvious; it returns the non-terminal symbol that corresponds to a certain rule. The return type for all rules in our grammar is <code>:Int</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.return_type(g₇, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash167108\">:Int</pre>\n\n\n<div class=\"markdown\"><h3>child_types</h3><p><code>child_types</code> returns the types of the nonterminal children of a rule in a vector. If you just want to know how many children a rule has, and not necessarily which types they have, you can use <code>nchildren</code></p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.child_types(g₇, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash141241\">2-element Vector{Symbol}:\n :Int\n :Int</pre>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.nchildren(g₇, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash151878\">2</pre>\n\n\n<div class=\"markdown\"><h3>nonterminals</h3><p>The <code>nonterminals</code> function can be used to obtain a list of all nonterminals in the grammar.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.nonterminals(g₇)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash115023\">1-element Vector{Symbol}:\n :Int</pre>\n\n\n<div class=\"markdown\"><h3>Adding rules</h3><p>It is also possible to add rules to a grammar during execution. This can be done using the <code>add_rule!</code> function. The exclamation mark is a Julia convention and is appended to name if a function modifies its arguments (in our example the grammar).</p><p>A rule can be provided in the same syntax as is used in the grammar definition. The rule should be of the <code>Expr</code> type, which is a built-in type for representing expressions.  An easy way of creating <code>Expr</code> values in Julia is to encapsulate it in brackets and use a colon as prefix:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.add_rule!(g₇, :(Int = Int - Int))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash700556\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n14: Int = Int - Int\n</pre>\n\n\n<div class=\"markdown\"><h3>Removing rules</h3><p>It is also possible to remove rules in Herb.jl, however, this is a bit more involved.  As said before, rules have an index associated with them.  The internal representation of programs that are defined by the grammar makes use of those indices for efficiency. Blindly removing a rule would shift the indices of other rules, and this could mean that existing programs get a different meaning or become invalid. </p><p>Therefore, there are two functions for removing rules:</p><ul><li><p><code>remove_rule!</code> removes a rule from the grammar, but fills its place with a placeholder. Therefore, the indices stay the same, and only programs that use the removed rule become invalid.</p></li><li><p><code>cleanup_removed_rules!</code> removes all placeholders and shifts the indices of the other rules.</p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.remove_rule!(g₇, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash501182\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: nothing = nothing\n12: Int = Int * Int\n13: Int = x\n14: Int = Int - Int\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.cleanup_removed_rules!(g₇)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash168833\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = x\n13: Int = Int - Int\n</pre>\n\n","category":"page"},{"location":"tutorials/defining_grammars/#Context-sensitive-grammars","page":"Defining Grammars in Herb.jl","title":"Context-sensitive grammars","text":"","category":"section"},{"location":"tutorials/defining_grammars/","page":"Defining Grammars in Herb.jl","title":"Defining Grammars in Herb.jl","text":"<div class=\"markdown\">\n<p>Context-sensitive grammars introduce additional constraints compared to context-free grammars (like the simple grammar examples above). As before, we use the <code>@csgrammar</code> macro:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g₈ = HerbGrammar.@csgrammar begin\n    Int = |(0:9)\n    Int = Int + Int\n    Int = Int * Int\n    Int = x\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g₈\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n</pre>\n\n\n<div class=\"markdown\"><p>Constraints can be added using the <code>addconstraint!</code> function, which takes a context-sensitive grammar and a constraint and adds the constraint to the grammar.</p><p>For example, we can add a `<code>constraint to enforce that the input symbol</code>x` (rule 13) appears at least once in the program, to avoid programs that are just a constant.  </p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.addconstraint!(g₈, Contains(13))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash105069\">1-element Vector{AbstractConstraint}:\n Contains(13)</pre>\n\n\n<div class=\"markdown\"><p>There is a dedicated tutorial for constraints in Herb.jl and how to work with them.</p></div>\n\n\n<div class=\"markdown\"><h3>Probabilistic grammars</h3><p>Herb.jl also supports probabilistic grammars.  These grammars allow the user to assign a probability to each rule in the grammar. A probabilistic grammar can be defined in a very similar way to a standard grammar, but has some slightly different syntax:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    g₉ = HerbGrammar.@pcsgrammar begin\n        0.4 : Int = |(0:9)\n        0.2 : Int = Int + Int\n        0.1 : Int = Int * Int\n        0.3 : Int = x\n    end\n    \n    for r ∈ 1:length(g₃.rules)\n        p = HerbGrammar.probability(g₈, r)\n    \n        println(\"$p : $r\")\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>The numbers before each rule represent the probability assigned to that rule. The total probability for each return type should add up to 1.0. If this isn't the case, Herb.jl will normalize the probabilities.</p><p>If a single line in the grammar definition represents multiple rules, such as <code>0.4 : Int = |(0:9)</code>, the probability will be evenly divided over all these rules.</p></div>\n\n","category":"page"},{"location":"tutorials/defining_grammars/#File-writing","page":"Defining Grammars in Herb.jl","title":"File writing","text":"","category":"section"},{"location":"tutorials/defining_grammars/","page":"Defining Grammars in Herb.jl","title":"Defining Grammars in Herb.jl","text":"<div class=\"markdown\">\n<h3>Saving &amp; loading context-free grammars</h3><p>If you want to store a grammar on the disk, you can use the <code>store_csg</code>, <code>read_csg</code> and functions to store and read grammars respectively.  The <code>store_csg</code> grammar can also be used to store probabilistic grammars. To read probabilistic grammars, use <code>read_pcsg</code>. The stored grammar files can also be opened using a text editor to be modified, as long as the contents of the file doesn't violate the syntax for defining grammars.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.store_csg(g₇, \"demo.txt\")</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.read_csg(\"demo.txt\")</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash174505\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = x\n13: Int = Int - Int\n</pre>\n\n\n<div class=\"markdown\"><h3>Saving &amp; loading context-sensitive grammars</h3><p>Saving and loading context-sensitive grammars is very similar to how it is done with context-free grammars. The only difference is that an additional file is created for the constraints.  The file that contains the grammars can be edited and can also be read using the reader for context-free grammars. The file that contains the constraints cannot be edited.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.store_csg( g₈, \"demo.grammar\", \"demo.constraints\")</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>g₈, g₈.constraints</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash136301\">(1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n, AbstractConstraint[Contains(13)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>g₁₀  = HerbGrammar.read_csg(\"demo.grammar\", \"demo.constraints\")</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g₁₀\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>g₁₀, g₁₀.constraints</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash688383\">(1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n, AbstractConstraint[Contains(13)])</pre>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/defining_grammars/","page":"Defining Grammars in Herb.jl","title":"Defining Grammars in Herb.jl","text":"EditURL = \"https://github.com/Herb-AI/Herb.jl/blob/main/docs/src/tutorials/defining_grammars.jl\"","category":"page"},{"location":"tutorials/TopDown/#Building-Herb-Iterators","page":"Top Down Iterator","title":"Building Herb Iterators","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The core building block in Herb is a program iterator. A program iterator represents a walk through the program space; different iterators provide different ways of iterating through program space.  From the program synthesis point of view, program iterators actually represent program spaces.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"    flowchart TD\n    id1((13)) ---\n    id2((6))\n    id1 --- id3((12))\n    id4((11))\n    id5((4))\n    id3 --- id4\n    id3 --- id5","category":"page"},{"location":"tutorials/TopDown/#Iterator-hierarchy","page":"Top Down Iterator","title":"Iterator hierarchy","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Program iterators are organised in a hierarchy. The top-level abstract type is ProgramIterator.  At the next level of the hierarchy lie commonly used search families:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"TopDownIterator for top-down traversals\nStochasticSearachIterator for traversals with stochastic search\nBottomUpIterator for bottom-up search","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Stochastic search further provides specific iterators:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"MHSearchIterator for program traversal with Metropolis-Hastings algorithm\nVLNSearchIterator for traversals with Very Large Neighbourhood Search\nSASearchIterator for Simulated Annealing","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"We provide generic and customisable implementations of each of these iterators, so that users can easily tweak them by through multiple dispatch. Keep reading!","category":"page"},{"location":"tutorials/TopDown/#Iterator-design","page":"Top Down Iterator","title":"Iterator design","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Program iterators follow the standard Julia Iterator interface. That is, every iterator should implement two functions:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"iterate(<:ProgramIterator)::(RuleNode,Any) to get the first program. The function takes a program iterator as an input, returning the first program and a state (which can be anything)\niterate(<:ProgramIterator,Any)::(RuleNode,Any) to get the consecutive programs. The function takes the program iterator and the state from the previous iteration, and return the next program and the next state.","category":"page"},{"location":"tutorials/TopDown/#Top-Down-iterator","page":"Top Down Iterator","title":"Top Down iterator","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"We illustrate how to build iterators with a Top Down iterator. The top Down iterator is build as a best-first iterator: it maintains a priority queue of programs and always pops the first element of the queue.  The iterator is customisable through the following functions:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"priority_function: dictating the order of programs in the priority queue\nderivation_heuristic: dictating in which order to explore the derivations rules within a single hole\nhole_heuristic: dictating which hole to expand next","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The first call to iterate(iter::TopDownIterator):","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"function Base.iterate(iter::TopDownIterator)\n    # Priority queue with `SolverState`s (for variable shaped trees) and `UniformIterator`s (for fixed shaped trees)\n    pq :: PriorityQueue{Union{SolverState, UniformIterator}, Union{Real, Tuple{Vararg{Real}}}} = PriorityQueue()\n\n    solver = iter.solver\n\n    if isfeasible(solver)\n        enqueue!(pq, get_state(solver), priority_function(iter, get_grammar(solver), get_tree(solver), 0, false))\n    end\n    return _find_next_complete_tree(iter.solver, pq, iter)\nend","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The first call steps everything up: it initiates the priority queue, the constraint solver (more on that later), and return the first program. The function _find_next_complete_tree(iter.solver, pq, iter) does a lot of heavy lifting here; we will cover it later, but the only important thing is that it finds the next complete program in the priority queue (because, in case of top down enumeration, the queue also contains partial programs which we only want to expand, but not return to the user).","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The subsequent call to iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue) are quite simple: all that is needed is to find the next complete program in the priority queue:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"function Base.iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue)\n    return _find_next_complete_tree(iter.solver, pq, iter)\nend","category":"page"},{"location":"tutorials/TopDown/#Modifying-the-provided-iterator","page":"Top Down Iterator","title":"Modifying the provided iterator","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"If you would like to, for example, modify the priority function, you don't have to implement the iterator from scratch. You simply need to create a new type and inherit from the TopDownIterator:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"abstract type MyTopDown <: TopDownIterator end.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"What is left is to implement the priority function, multiple-dispatching it over the new type.  For example, to do a random order:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"function priority_function(\n    ::MyTopDown, \n    ::AbstractGrammar, \n    ::AbstractRuleNode, \n    ::Union{Real, Tuple{Vararg{Real}}},\n    ::Bool\n)\n    Random.rand();\nend","category":"page"},{"location":"tutorials/TopDown/#A-note-on-data-structures","page":"Top Down Iterator","title":"A note on data structures","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"As you have probably noticed, the priority queue some strange data structures: SolverState and UniformIterator; the top down iterator never puts RuleNodes into the queue. In fact, the iterator never directly manipulates RuleNodes itself, but that is rather delegated to the constraint solver. The constraint solver will do a lot of work to reduce the number of programs we have to consider. The SolverState and UniformIterator are specialised data structure to improve the efficiency and memory usage. ","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Herb uses a data structure of UniformTrees to represent all programs with an AST of the same shape, where each node has the same type. the UniformIterator is an iterator efficiently iterating over that structure.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The SolverState represents non-uniform trees – ASTs whose shape we haven't completely determined yet. SolverState is used as an intermediate representation before we reach UniformTrees on which partial constraint propagation is done.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"In principle, you should never construct ASTs yourself directly; you should leave that to the constraint solver.","category":"page"},{"location":"tutorials/TopDown/#Extra:-Find-Next-Complete-Tree-/-Program","page":"Top Down Iterator","title":"Extra: Find Next Complete Tree / Program","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"This function pops an element from the priority queue whilst it is not empty, and then checks what kind of iterator it is.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"function _find_next_complete_tree(\n    solver::Solver,\n    pq::PriorityQueue,\n    iter::TopDownIterator\n)\n    while length(pq) ≠ 0\n        (item, priority_value) = dequeue_pair!(pq)\n","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"If it is a Uniform Iterator, that is an iterator where all the holes have the same shape, then it iterates over the solutions.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"\n        if item isa UniformIterator\n            #the item is a fixed shaped solver, we should get the next solution and re-enqueue it with a new priority value\n            uniform_iterator = item\n            solution = next_solution!(uniform_iterator)\n            if !isnothing(solution)\n                enqueue!(pq, uniform_iterator, priority_function(iter, get_grammar(solver), solution, priority_value, true))\n                return (solution, pq)\n            end\n","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"If it is not a Uniform Iterator, we find a hole to branch on. If the holes are all uniform, a Uniform Iterator is created, and is enqueued. If iterating on the holes would exceed a maximum depth, nothing new is enqueued. Lastly, if the holes aren't the same shape, we branch / partition on the holes, to create new partial domains to enqueue.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"        elseif item isa SolverState\n            #the item is a solver state, we should find a variable shaped hole to branch on\n            state = item\n            load_state!(solver, state)\n\n            hole_res = hole_heuristic(iter, get_tree(solver), get_max_depth(solver))\n            if hole_res ≡ already_complete\n                uniform_solver = UniformSolver(get_grammar(solver), get_tree(solver), with_statistics=solver.statistics)\n                uniform_iterator = UniformIterator(uniform_solver, iter)\n                solution = next_solution!(uniform_iterator)\n                if !isnothing(solution)\n                    enqueue!(pq, uniform_iterator, priority_function(iter, get_grammar(solver), solution, priority_value, true))\n                    return (solution, pq)\n                end\n            elseif hole_res ≡ limit_reached\n                # The maximum depth is reached\n                continue\n            elseif hole_res isa HoleReference\n                # Variable Shaped Hole was found\n                (; hole, path) = hole_res\n        \n                partitioned_domains = partition(hole, get_grammar(solver))\n                number_of_domains = length(partitioned_domains)\n                for (i, domain) ∈ enumerate(partitioned_domains)\n                    if i < number_of_domains\n                        state = save_state!(solver)\n                    end\n                    @assert isfeasible(solver) \"Attempting to expand an infeasible tree: $(get_tree(solver))\"\n                    remove_all_but!(solver, path, domain)\n                    if isfeasible(solver)\n                        enqueue!(pq, get_state(solver), priority_function(iter, get_grammar(solver), get_tree(solver), priority_value, false))\n                    end\n                    if i < number_of_domains\n                        load_state!(solver, state)\n                    end\n                end\n            end\n\n","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Otherwise, throw an exception, because we came across an unexpected iterator type.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"        else\n            throw(\"BadArgument: PriorityQueue contains an item of unexpected type '$(typeof(item))'\")\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"CurrentModule=Herb","category":"page"},{"location":"#[Herb.jl](https://github.com/Herb-AI/Herb.jl)","page":"Herb.jl","title":"Herb.jl","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"A library for defining and efficiently solving program synthesis tasks in Julia.","category":"page"},{"location":"#Why-Herb.jl?","page":"Herb.jl","title":"Why Herb.jl?","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"When writing research software we almost always investigate highly specific properties or algorithms of our domain, leading to us building the tools from scratch over and over again. The very same holds for the field of program synthesis: Tools are hard to run, benchmarks are hard to get and prepare, and it is hard to adapt our existing code to a novel idea.","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl will take care of this for you and helps you in defining, solving and extending your program synthesis problems.","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl provides...","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"a unified and universal framework for program synthesis\nHerb.jl allows you to describe all sorts of program synthesis problems using context-free grammars\na number of state-of-the-art benchmarks and solvers already implemented and usable out-of-the-box","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl's sub-packages provide fast and easily extendable implementations of ","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"various static and dynamic search strategies,\nlearning search strategies, sampling techniques and more,\nconstraint formulation and propagation, \neasy grammar formulation and usage,\nwide-range of usable program interpreters and languages + the possibility to use your own, and \nefficient data formulation.","category":"page"},{"location":"#Why-Julia?","page":"Herb.jl","title":"Why Julia?","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Julia is a perfect fit for program synthesis due to numerous reasons. Starting from scientific reasons like speed of execution and composability over to practical reasons like speed of writing Julia code. For a full ode on why to use Julia, please see the WhyJulia manifesto.","category":"page"},{"location":"#Sub-Modules","page":"Herb.jl","title":"Sub-Modules","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb's functionality is distributed among several sub-packages:","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"HerbCore.jl: The core of Herb.jl defining abstract concepts,\nHerbGrammar.jl: Functionality for declaring grammars,\nHerbSpecification.jl: For describing user intent as specifications,\nHerbInterpret.jl: For running programs in different languages and environments,\nHerbConstraints.jl: For defining and effectively propagating and managing constraints during search, and\nHerbSearch.jl: For actually searching for solutions.","category":"page"},{"location":"#Basics","page":"Herb.jl","title":"Basics","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Pages = [\"install.md\", \"get_started.md\", \"concepts.md\"]","category":"page"},{"location":"#Advanced-content","page":"Herb.jl","title":"Advanced content","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Pages = [p * \"/index.md\" for p in readdir(joinpath(dirname(@__FILE__), \"..\", \"src\")) if occursin(\"Herb\", p)]\nDepth = 1","category":"page"},{"location":"#Tutorials","page":"Herb.jl","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"To familiarize yourself with Herb, we have created several tutorials:","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"A more verbose getting started with Herb.jl\nDefining Grammars in Herb.jl\nAdvanced Search Procedures\nTop Down Iterator\nGetting started with Constraints\nWorking with custom interpreters\nAbstract Syntax Trees","category":"page"},{"location":"tutorials/abstract_syntax_trees/","page":"Abstract Syntax Trees","title":"Abstract Syntax Trees","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"459960ee6b238f7172802171583f096837da3de02aab0edc980ce41e705c202b\"\n    julia_version = \"1.11.3\"\n-->\n\n<div class=\"markdown\"><h1>Herb tutorial: Abstract syntax trees</h1></div>\n\n\n<div class=\"markdown\"><p>In this tutorial, you will learn</p><ul><li><p>How to represent a computer program as an abstract syntax tree  in Herb.</p></li><li><p>How to replace parts of the tree to modify the program.</p></li></ul></div>\n\n","category":"page"},{"location":"tutorials/abstract_syntax_trees/#Abstract-syntax-trees","page":"Abstract Syntax Trees","title":"Abstract syntax trees","text":"","category":"section"},{"location":"tutorials/abstract_syntax_trees/","page":"Abstract Syntax Trees","title":"Abstract Syntax Trees","text":"<div class=\"markdown\">\n<p>The syntactic structure of a computer program can be represented in a hierarchical tree structure, a so-called <em>Abstract Syntax Tree (AST)</em>. The syntax of a programming language is typically defined using a formal grammar, a set of rules on how valid programs can be constructed. ASTs are derived from the grammar, but are abstractions in the sense that they omit details such as parenthesis, semicolons, etc. and only retain what's necessary to capture the program structure. </p><p>In the context of program synthesis, ASTs are often used to define the space of all possible programs which is searched to find one that satisfies the given specifications. During the search process, different ASTs, each corresponding to a different program, are generated and evaluated until a suitable one is found.</p><p>Each <em>node</em> of the AST represents a construct in the program (e.g., a variable, an operator, a statement, or a function) and this construct corresponds to a rule in the formal grammar.  An <em>edge</em> describes the relationship between constructs, and the tree structure captures the nesting of constructs. </p></div>\n\n","category":"page"},{"location":"tutorials/abstract_syntax_trees/#A-simple-example-program","page":"Abstract Syntax Trees","title":"A simple example program","text":"","category":"section"},{"location":"tutorials/abstract_syntax_trees/","page":"Abstract Syntax Trees","title":"Abstract Syntax Trees","text":"<div class=\"markdown\">\n<p>We first consider the simple program 5*(x+3). We will define a grammar that is sufficient to represent this program and use it to construct a AST for our program.</p></div>\n\n\n<div class=\"markdown\"><h3>Define the grammar</h3></div>\n\n\n\n\n\n\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>grammar = @csgrammar begin\n        Number = |(0:9)\n        Number = x\n        Number = Number + Number\n        Number = Number * Number\n    end</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grammar\">1: Number = 0\n2: Number = 1\n3: Number = 2\n4: Number = 3\n5: Number = 4\n6: Number = 5\n7: Number = 6\n8: Number = 7\n9: Number = 8\n10: Number = 9\n11: Number = x\n12: Number = Number + Number\n13: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><h3>Construct the syntax tree</h3></div>\n\n\n<div class=\"markdown\"><p>The AST of this program is shown in the diagram below. The number in each node refers to the index of the corresponding rule in our grammar. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>Diagram(:mermaid, \"\"\"\nflowchart TD\n    id1((13)) ---\n    id2((6))\n    id1 --- id3((12))\n    id4((11))\n    id5((4))\n    id3 --- id4\n    id3 --- id5\n\"\"\")</code></pre>\n<img src=\"data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0iZmxvd2NoYXJ0LXYyIiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgdmlld0JveD0iMCAwIDE1NC4yNTc4MTI1IDIwNC40MjE4NzUiIGhlaWdodD0iMjA0LjQyMTg3NSIgY2xhc3M9ImZsb3djaGFydCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTU0LjI1NzgxMjUiIGlkPSJjb250YWluZXIiPjxzdHlsZT4jY29udGFpbmVye2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTZweDtmaWxsOiMzMzM7fSNjb250YWluZXIgLmVycm9yLWljb257ZmlsbDojNTUyMjIyO30jY29udGFpbmVyIC5lcnJvci10ZXh0e2ZpbGw6IzU1MjIyMjtzdHJva2U6IzU1MjIyMjt9I2NvbnRhaW5lciAuZWRnZS10aGlja25lc3Mtbm9ybWFse3N0cm9rZS13aWR0aDoxcHg7fSNjb250YWluZXIgLmVkZ2UtdGhpY2tuZXNzLXRoaWNre3N0cm9rZS13aWR0aDozLjVweDt9I2NvbnRhaW5lciAuZWRnZS1wYXR0ZXJuLXNvbGlke3N0cm9rZS1kYXNoYXJyYXk6MDt9I2NvbnRhaW5lciAuZWRnZS10aGlja25lc3MtaW52aXNpYmxle3N0cm9rZS13aWR0aDowO2ZpbGw6bm9uZTt9I2NvbnRhaW5lciAuZWRnZS1wYXR0ZXJuLWRhc2hlZHtzdHJva2UtZGFzaGFycmF5OjM7fSNjb250YWluZXIgLmVkZ2UtcGF0dGVybi1kb3R0ZWR7c3Ryb2tlLWRhc2hhcnJheToyO30jY29udGFpbmVyIC5tYXJrZXJ7ZmlsbDojMzMzMzMzO3N0cm9rZTojMzMzMzMzO30jY29udGFpbmVyIC5tYXJrZXIuY3Jvc3N7c3Ryb2tlOiMzMzMzMzM7fSNjb250YWluZXIgc3Zne2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTZweDt9I2NvbnRhaW5lciBwe21hcmdpbjowO30jY29udGFpbmVyIC5sYWJlbHtmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Y29sb3I6IzMzMzt9I2NvbnRhaW5lciAuY2x1c3Rlci1sYWJlbCB0ZXh0e2ZpbGw6IzMzMzt9I2NvbnRhaW5lciAuY2x1c3Rlci1sYWJlbCBzcGFue2NvbG9yOiMzMzM7fSNjb250YWluZXIgLmNsdXN0ZXItbGFiZWwgc3BhbiBwe2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7fSNjb250YWluZXIgLmxhYmVsIHRleHQsI2NvbnRhaW5lciBzcGFue2ZpbGw6IzMzMztjb2xvcjojMzMzO30jY29udGFpbmVyIC5ub2RlIHJlY3QsI2NvbnRhaW5lciAubm9kZSBjaXJjbGUsI2NvbnRhaW5lciAubm9kZSBlbGxpcHNlLCNjb250YWluZXIgLm5vZGUgcG9seWdvbiwjY29udGFpbmVyIC5ub2RlIHBhdGh7ZmlsbDojRUNFQ0ZGO3N0cm9rZTojOTM3MERCO3N0cm9rZS13aWR0aDoxcHg7fSNjb250YWluZXIgLnJvdWdoLW5vZGUgLmxhYmVsIHRleHQsI2NvbnRhaW5lciAubm9kZSAubGFiZWwgdGV4dCwjY29udGFpbmVyIC5pbWFnZS1zaGFwZSAubGFiZWwsI2NvbnRhaW5lciAuaWNvbi1zaGFwZSAubGFiZWx7dGV4dC1hbmNob3I6bWlkZGxlO30jY29udGFpbmVyIC5ub2RlIC5rYXRleCBwYXRoe2ZpbGw6IzAwMDtzdHJva2U6IzAwMDtzdHJva2Utd2lkdGg6MXB4O30jY29udGFpbmVyIC5yb3VnaC1ub2RlIC5sYWJlbCwjY29udGFpbmVyIC5ub2RlIC5sYWJlbCwjY29udGFpbmVyIC5pbWFnZS1zaGFwZSAubGFiZWwsI2NvbnRhaW5lciAuaWNvbi1zaGFwZSAubGFiZWx7dGV4dC1hbGlnbjpjZW50ZXI7fSNjb250YWluZXIgLm5vZGUuY2xpY2thYmxle2N1cnNvcjpwb2ludGVyO30jY29udGFpbmVyIC5yb290IC5hbmNob3IgcGF0aHtmaWxsOiMzMzMzMzMhaW1wb3J0YW50O3N0cm9rZS13aWR0aDowO3N0cm9rZTojMzMzMzMzO30jY29udGFpbmVyIC5hcnJvd2hlYWRQYXRoe2ZpbGw6IzMzMzMzMzt9I2NvbnRhaW5lciAuZWRnZVBhdGggLnBhdGh7c3Ryb2tlOiMzMzMzMzM7c3Ryb2tlLXdpZHRoOjIuMHB4O30jY29udGFpbmVyIC5mbG93Y2hhcnQtbGlua3tzdHJva2U6IzMzMzMzMztmaWxsOm5vbmU7fSNjb250YWluZXIgLmVkZ2VMYWJlbHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7dGV4dC1hbGlnbjpjZW50ZXI7fSNjb250YWluZXIgLmVkZ2VMYWJlbCBwe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt9I2NvbnRhaW5lciAuZWRnZUxhYmVsIHJlY3R7b3BhY2l0eTowLjU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO2ZpbGw6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt9I2NvbnRhaW5lciAubGFiZWxCa2d7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwgMjMyLCAyMzIsIDAuNSk7fSNjb250YWluZXIgLmNsdXN0ZXIgcmVjdHtmaWxsOiNmZmZmZGU7c3Ryb2tlOiNhYWFhMzM7c3Ryb2tlLXdpZHRoOjFweDt9I2NvbnRhaW5lciAuY2x1c3RlciB0ZXh0e2ZpbGw6IzMzMzt9I2NvbnRhaW5lciAuY2x1c3RlciBzcGFue2NvbG9yOiMzMzM7fSNjb250YWluZXIgZGl2Lm1lcm1haWRUb29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyO21heC13aWR0aDoyMDBweDtwYWRkaW5nOjJweDtmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjEycHg7YmFja2dyb3VuZDpoc2woODAsIDEwMCUsIDk2LjI3NDUwOTgwMzklKTtib3JkZXI6MXB4IHNvbGlkICNhYWFhMzM7Ym9yZGVyLXJhZGl1czoycHg7cG9pbnRlci1ldmVudHM6bm9uZTt6LWluZGV4OjEwMDt9I2NvbnRhaW5lciAuZmxvd2NoYXJ0VGl0bGVUZXh0e3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6MThweDtmaWxsOiMzMzM7fSNjb250YWluZXIgcmVjdC50ZXh0e2ZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MDt9I2NvbnRhaW5lciAuaWNvbi1zaGFwZSwjY29udGFpbmVyIC5pbWFnZS1zaGFwZXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7dGV4dC1hbGlnbjpjZW50ZXI7fSNjb250YWluZXIgLmljb24tc2hhcGUgcCwjY29udGFpbmVyIC5pbWFnZS1zaGFwZSBwe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTtwYWRkaW5nOjJweDt9I2NvbnRhaW5lciAuaWNvbi1zaGFwZSByZWN0LCNjb250YWluZXIgLmltYWdlLXNoYXBlIHJlY3R7b3BhY2l0eTowLjU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO2ZpbGw6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt9I2NvbnRhaW5lciA6cm9vdHstLW1lcm1haWQtZm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO308L3N0eWxlPjxnPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjgiIG1hcmtlcldpZHRoPSI4IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjUiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQtdjIiIGlkPSJjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAwIDAgTCAxMCA1IEwgMCAxMCB6Ij48L3BhdGg+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iOCIgbWFya2VyV2lkdGg9IjgiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNSIgcmVmWD0iNC41IiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludFN0YXJ0Ij48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAwIDUgTCAxMCAxMCBMIDEwIDAgeiI+PC9wYXRoPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjExIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNSIgcmVmWD0iMTEiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQtdjIiIGlkPSJjb250YWluZXJfZmxvd2NoYXJ0LXYyLWNpcmNsZUVuZCI+PGNpcmNsZSBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgcj0iNSIgY3k9IjUiIGN4PSI1Ij48L2NpcmNsZT48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9Ii0xIiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1jaXJjbGVTdGFydCI+PGNpcmNsZSBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgcj0iNSIgY3k9IjUiIGN4PSI1Ij48L2NpcmNsZT48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUuMiIgcmVmWD0iMTIiIHZpZXdCb3g9IjAgMCAxMSAxMSIgY2xhc3M9Im1hcmtlciBjcm9zcyBmbG93Y2hhcnQtdjIiIGlkPSJjb250YWluZXJfZmxvd2NoYXJ0LXYyLWNyb3NzRW5kIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAyOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAxLDEgbCA5LDkgTSAxMCwxIGwgLTksOSI+PC9wYXRoPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjExIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNS4yIiByZWZYPSItMSIgdmlld0JveD0iMCAwIDExIDExIiBjbGFzcz0ibWFya2VyIGNyb3NzIGZsb3djaGFydC12MiIgaWQ9ImNvbnRhaW5lcl9mbG93Y2hhcnQtdjItY3Jvc3NTdGFydCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMjsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiPjwvcGF0aD48L21hcmtlcj48ZyBjbGFzcz0icm9vdCI+PGcgY2xhc3M9ImNsdXN0ZXJzIj48L2c+PGcgY2xhc3M9ImVkZ2VQYXRocyI+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQxX2lkMl8wIiBkPSJNNDcuNzU0LDMzLjc1Nkw0My4wOSwzOC42MTdDMzguNDI1LDQzLjQ3OCwyOS4wOTUsNTMuMiwyNC40Myw2Mi4wODhDMTkuNzY2LDcwLjk3NywxOS43NjYsNzkuMDMxLDE5Ljc2Niw4My4wNTlMMTkuNzY2LDg3LjA4NiI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMV9pZDNfMSIgZD0iTTY4LjQ3MiwzMy43NTZMNzMuMTM3LDM4LjYxN0M3Ny44MDIsNDMuNDc4LDg3LjEzMSw1My4yLDkxLjc5Niw2MS41NjFDOTYuNDYxLDY5LjkyMiw5Ni40NjEsNzYuOTIyLDk2LjQ2MSw4MC40MjJMOTYuNDYxLDgzLjkyMiI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkM19pZDRfMiIgZD0iTTg2LjE2MywxMTMuNjYxTDgxLjU0LDExOC41MTVDNzYuOTE2LDEyMy4zNjgsNjcuNjY5LDEzMy4wNzUsNjMuMDQ1LDE0MS40MjhDNTguNDIyLDE0OS43ODEsNTguNDIyLDE1Ni43ODEsNTguNDIyLDE2MC4yODFMNTguNDIyLDE2My43ODEiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDNfaWQ1XzMiIGQ9Ik0xMDYuNzU5LDExMy42NjFMMTExLjM4MiwxMTguNTE1QzExNi4wMDYsMTIzLjM2OCwxMjUuMjUzLDEzMy4wNzUsMTI5Ljg3NiwxNDEuODU1QzEzNC41LDE1MC42MzUsMTM0LjUsMTU4LjQ5LDEzNC41LDE2Mi40MTdMMTM0LjUsMTY2LjM0NCI+PC9wYXRoPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVscyI+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZXMiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU4LjExMzI4MTI1LCAyMi45NjA5Mzc1KSIgaWQ9ImZsb3djaGFydC1pZDEtMCIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjE0Ljk2MDkzNzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03LjQ2MDkzNzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxNC45MjE4NzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xMzwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTkuNzY1NjI1LCAxMDIuODUxNTYyNSkiIGlkPSJmbG93Y2hhcnQtaWQyLTEiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS43NjU2MjUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjI2NTYyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjguNTMxMjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD42PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5Ni40NjA5Mzc1LCAxMDIuODUxNTYyNSkiIGlkPSJmbG93Y2hhcnQtaWQzLTMiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNC45Mjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNy40Mjk2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTQuODU5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTI8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU4LjQyMTg3NSwgMTgyLjEwMTU2MjUpIiBpZD0iZmxvd2NoYXJ0LWlkNC00IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuMzIwMzEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYuODIwMzEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEzLjY0MDYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjExPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzQuNSwgMTgyLjEwMTU2MjUpIiBpZD0iZmxvd2NoYXJ0LWlkNS01IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNzU3ODEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuMjU3ODEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjguNTE1NjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+NDwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjwvZz48L2c+PC9zdmc+\"/>\n\n\n<div class=\"markdown\"><p>In <code>Herb.jl</code>, the <code>HerbCore.RuleNode</code> is used to represent both an individual node, but also entire ASTs or sub-trees. This is achieved by nesting instances of <code>RuleNode</code>. A <code>RuleNode</code> can be instantiated by providing the index of the grammar rule that the node represents and a vector of child nodes. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>syntaxtree = HerbGrammar.RuleNode(13, [RuleNode(6), RuleNode(12, [RuleNode(11), RuleNode(4)])])</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-syntaxtree\">13{6,12{11,4}}</pre>\n\n\n<div class=\"markdown\"><p>We can confirm that our AST is correct by displaying it in a more human-readable way, using <code>HerbGrammar.rulenode2expr</code> and by testing it on a few input examples using <code>HerbInterpret.execute_on_input</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>rulenode2expr(syntaxtree, grammar)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash642064\">:(5 * (x + 3))</pre>\n\n<pre class='language-julia'><code class='language-julia'># test solution on inputs\nexecute_on_input(grammar, syntaxtree, Dict(:x =&gt; 10))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash156207\">65</pre>\n\n","category":"page"},{"location":"tutorials/abstract_syntax_trees/#Another-example:-FizzBuzz","page":"Abstract Syntax Trees","title":"Another example: FizzBuzz","text":"","category":"section"},{"location":"tutorials/abstract_syntax_trees/","page":"Abstract Syntax Trees","title":"Abstract Syntax Trees","text":"<div class=\"markdown\">\n<p>Let's look at a more interesting example.  The program <code>fizzbuzz()</code> is based on the popular <em>FizzBuzz</em> problem. Given an integer number, the program simply returns a <code>String</code> of that number, but replace numbers divisible by 3 with <code>\"Fizz\"</code>, numbers divisible by 5 with <code>\"Buzz\"</code>, and number divisible by both 3 and 5 with <code>\"FizzBuzz\"</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function fizzbuzz(x)\n    if x % 5 == 0 && x % 3 == 0\n        return \"FizzBuzz\"\n    else\n        if x % 3 == 0\n            return  \"Fizz\"\n        else\n            if x % 5 == 0\n                return \"Buzz\"\n            else\n                return string(x)\n            end\n        end\n    end\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-fizzbuzz\">fizzbuzz (generic function with 1 method)</pre>\n\n\n<div class=\"markdown\"><h3>Define the grammar</h3><p>Let's define a grammar with all the rules that we need.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>grammar_fizzbuzz = @csgrammar begin\n    Int = input1\n    Int = 0 | 3 | 5\n    String = \"Fizz\" | \"Buzz\" | \"FizzBuzz\"\n    String = string(Int)\n    Return = String\n    Int = Int % Int\n    Bool = Int == Int\n    Int = Bool ? Int : Int\n    Bool = Bool && Bool\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grammar_fizzbuzz\">1: Int = input1\n2: Int = 0\n3: Int = 3\n4: Int = 5\n5: String = Fizz\n6: String = Buzz\n7: String = FizzBuzz\n8: String = string(Int)\n9: Return = String\n10: Int = Int % Int\n11: Bool = Int == Int\n12: Int = if Bool\n    Int\nelse\n    Int\nend\n13: Bool = Bool &amp;&amp; Bool\n</pre>\n\n\n<div class=\"markdown\"><h3>Construct the syntax tree</h3></div>\n\n\n<div class=\"markdown\"><p>Given the grammar, the AST of <code>fizzbuzz()</code> looks like this:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>Diagram(:mermaid, \"\"\"\nflowchart TD\n    id1((12)) --- id21((13))\n    id1--- id22((9))\n    id1--- id23((12))\n\n    id21 --- id31((11))\n    id21 --- id32((11))\n\n    id31 --- id41((10))\n    id31 --- id42((2))\n\n    id41 --- id51((1))\n    id41 --- id52((4))\n\n    id32 --- id43((10)) \n    id32 --- id44((2))\n\n    id43 --- id53((1))\n    id43 --- id54((3))\n\n    id22 --- id33((7))\n    id23 --- id34((11))\n\n    id34 --- id45((10))\n    id34 --- id46((2))\n\n    id45 --- id55((1))\n    id45 --- id56((3))\n\n    id23 --- id35((9))\n    id35 --- id47((5))\n\n    id23 --- id36((12))\n    id36 --- id48((11))\n    id48 --- id57((10))\n    id57 --- id61((1))\n    id57 --- id62((4))\n    id48 --- id58((2))\n\n    id36 --- id49((9))\n    id49 --- id59((6))\n\n    id36 --- id410((9))\n    id410 --- id510((8))\n    id510 --- id63((1))\n\"\"\")</code></pre>\n<img src=\"data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0iZmxvd2NoYXJ0LXYyIiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgdmlld0JveD0iMCAwIDc5Ny4xODM1OTM3NSA0NDEuMTE3MTg3NSIgaGVpZ2h0PSI0NDEuMTE3MTg3NSIgY2xhc3M9ImZsb3djaGFydCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNzk3LjE4MzU5Mzc1IiBpZD0iY29udGFpbmVyIj48c3R5bGU+I2NvbnRhaW5lcntmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7ZmlsbDojMzMzO30jY29udGFpbmVyIC5lcnJvci1pY29ue2ZpbGw6IzU1MjIyMjt9I2NvbnRhaW5lciAuZXJyb3ItdGV4dHtmaWxsOiM1NTIyMjI7c3Ryb2tlOiM1NTIyMjI7fSNjb250YWluZXIgLmVkZ2UtdGhpY2tuZXNzLW5vcm1hbHtzdHJva2Utd2lkdGg6MXB4O30jY29udGFpbmVyIC5lZGdlLXRoaWNrbmVzcy10aGlja3tzdHJva2Utd2lkdGg6My41cHg7fSNjb250YWluZXIgLmVkZ2UtcGF0dGVybi1zb2xpZHtzdHJva2UtZGFzaGFycmF5OjA7fSNjb250YWluZXIgLmVkZ2UtdGhpY2tuZXNzLWludmlzaWJsZXtzdHJva2Utd2lkdGg6MDtmaWxsOm5vbmU7fSNjb250YWluZXIgLmVkZ2UtcGF0dGVybi1kYXNoZWR7c3Ryb2tlLWRhc2hhcnJheTozO30jY29udGFpbmVyIC5lZGdlLXBhdHRlcm4tZG90dGVke3N0cm9rZS1kYXNoYXJyYXk6Mjt9I2NvbnRhaW5lciAubWFya2Vye2ZpbGw6IzMzMzMzMztzdHJva2U6IzMzMzMzMzt9I2NvbnRhaW5lciAubWFya2VyLmNyb3Nze3N0cm9rZTojMzMzMzMzO30jY29udGFpbmVyIHN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7fSNjb250YWluZXIgcHttYXJnaW46MDt9I2NvbnRhaW5lciAubGFiZWx7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2NvbG9yOiMzMzM7fSNjb250YWluZXIgLmNsdXN0ZXItbGFiZWwgdGV4dHtmaWxsOiMzMzM7fSNjb250YWluZXIgLmNsdXN0ZXItbGFiZWwgc3Bhbntjb2xvcjojMzMzO30jY29udGFpbmVyIC5jbHVzdGVyLWxhYmVsIHNwYW4gcHtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O30jY29udGFpbmVyIC5sYWJlbCB0ZXh0LCNjb250YWluZXIgc3BhbntmaWxsOiMzMzM7Y29sb3I6IzMzMzt9I2NvbnRhaW5lciAubm9kZSByZWN0LCNjb250YWluZXIgLm5vZGUgY2lyY2xlLCNjb250YWluZXIgLm5vZGUgZWxsaXBzZSwjY29udGFpbmVyIC5ub2RlIHBvbHlnb24sI2NvbnRhaW5lciAubm9kZSBwYXRoe2ZpbGw6I0VDRUNGRjtzdHJva2U6IzkzNzBEQjtzdHJva2Utd2lkdGg6MXB4O30jY29udGFpbmVyIC5yb3VnaC1ub2RlIC5sYWJlbCB0ZXh0LCNjb250YWluZXIgLm5vZGUgLmxhYmVsIHRleHQsI2NvbnRhaW5lciAuaW1hZ2Utc2hhcGUgLmxhYmVsLCNjb250YWluZXIgLmljb24tc2hhcGUgLmxhYmVse3RleHQtYW5jaG9yOm1pZGRsZTt9I2NvbnRhaW5lciAubm9kZSAua2F0ZXggcGF0aHtmaWxsOiMwMDA7c3Ryb2tlOiMwMDA7c3Ryb2tlLXdpZHRoOjFweDt9I2NvbnRhaW5lciAucm91Z2gtbm9kZSAubGFiZWwsI2NvbnRhaW5lciAubm9kZSAubGFiZWwsI2NvbnRhaW5lciAuaW1hZ2Utc2hhcGUgLmxhYmVsLCNjb250YWluZXIgLmljb24tc2hhcGUgLmxhYmVse3RleHQtYWxpZ246Y2VudGVyO30jY29udGFpbmVyIC5ub2RlLmNsaWNrYWJsZXtjdXJzb3I6cG9pbnRlcjt9I2NvbnRhaW5lciAucm9vdCAuYW5jaG9yIHBhdGh7ZmlsbDojMzMzMzMzIWltcG9ydGFudDtzdHJva2Utd2lkdGg6MDtzdHJva2U6IzMzMzMzMzt9I2NvbnRhaW5lciAuYXJyb3doZWFkUGF0aHtmaWxsOiMzMzMzMzM7fSNjb250YWluZXIgLmVkZ2VQYXRoIC5wYXRoe3N0cm9rZTojMzMzMzMzO3N0cm9rZS13aWR0aDoyLjBweDt9I2NvbnRhaW5lciAuZmxvd2NoYXJ0LWxpbmt7c3Ryb2tlOiMzMzMzMzM7ZmlsbDpub25lO30jY29udGFpbmVyIC5lZGdlTGFiZWx7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO3RleHQtYWxpZ246Y2VudGVyO30jY29udGFpbmVyIC5lZGdlTGFiZWwgcHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7fSNjb250YWluZXIgLmVkZ2VMYWJlbCByZWN0e29wYWNpdHk6MC41O2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTtmaWxsOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7fSNjb250YWluZXIgLmxhYmVsQmtne2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsIDIzMiwgMjMyLCAwLjUpO30jY29udGFpbmVyIC5jbHVzdGVyIHJlY3R7ZmlsbDojZmZmZmRlO3N0cm9rZTojYWFhYTMzO3N0cm9rZS13aWR0aDoxcHg7fSNjb250YWluZXIgLmNsdXN0ZXIgdGV4dHtmaWxsOiMzMzM7fSNjb250YWluZXIgLmNsdXN0ZXIgc3Bhbntjb2xvcjojMzMzO30jY29udGFpbmVyIGRpdi5tZXJtYWlkVG9vbHRpcHtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcjttYXgtd2lkdGg6MjAwcHg7cGFkZGluZzoycHg7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMnB4O2JhY2tncm91bmQ6aHNsKDgwLCAxMDAlLCA5Ni4yNzQ1MDk4MDM5JSk7Ym9yZGVyOjFweCBzb2xpZCAjYWFhYTMzO2JvcmRlci1yYWRpdXM6MnB4O3BvaW50ZXItZXZlbnRzOm5vbmU7ei1pbmRleDoxMDA7fSNjb250YWluZXIgLmZsb3djaGFydFRpdGxlVGV4dHt0ZXh0LWFuY2hvcjptaWRkbGU7Zm9udC1zaXplOjE4cHg7ZmlsbDojMzMzO30jY29udGFpbmVyIHJlY3QudGV4dHtmaWxsOm5vbmU7c3Ryb2tlLXdpZHRoOjA7fSNjb250YWluZXIgLmljb24tc2hhcGUsI2NvbnRhaW5lciAuaW1hZ2Utc2hhcGV7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO3RleHQtYWxpZ246Y2VudGVyO30jY29udGFpbmVyIC5pY29uLXNoYXBlIHAsI2NvbnRhaW5lciAuaW1hZ2Utc2hhcGUgcHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7cGFkZGluZzoycHg7fSNjb250YWluZXIgLmljb24tc2hhcGUgcmVjdCwjY29udGFpbmVyIC5pbWFnZS1zaGFwZSByZWN0e29wYWNpdHk6MC41O2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTtmaWxsOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7fSNjb250YWluZXIgOnJvb3R7LS1tZXJtYWlkLWZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjt9PC9zdHlsZT48Zz48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSI4IiBtYXJrZXJXaWR0aD0iOCIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSI1IiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMCAwIEwgMTAgNSBMIDAgMTAgeiI+PC9wYXRoPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjgiIG1hcmtlcldpZHRoPSI4IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjQuNSIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgaWQ9ImNvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRTdGFydCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMCA1IEwgMTAgMTAgTCAxMCAwIHoiPjwvcGF0aD48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjExIiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1jaXJjbGVFbmQiPjxjaXJjbGUgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHI9IjUiIGN5PSI1IiBjeD0iNSI+PC9jaXJjbGU+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSItMSIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgaWQ9ImNvbnRhaW5lcl9mbG93Y2hhcnQtdjItY2lyY2xlU3RhcnQiPjxjaXJjbGUgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHI9IjUiIGN5PSI1IiBjeD0iNSI+PC9jaXJjbGU+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1LjIiIHJlZlg9IjEyIiB2aWV3Qm94PSIwIDAgMTEgMTEiIGNsYXNzPSJtYXJrZXIgY3Jvc3MgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1jcm9zc0VuZCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMjsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiPjwvcGF0aD48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUuMiIgcmVmWD0iLTEiIHZpZXdCb3g9IjAgMCAxMSAxMSIgY2xhc3M9Im1hcmtlciBjcm9zcyBmbG93Y2hhcnQtdjIiIGlkPSJjb250YWluZXJfZmxvd2NoYXJ0LXYyLWNyb3NzU3RhcnQiPjxwYXRoIHN0eWxlPSJzdHJva2Utd2lkdGg6IDI7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBkPSJNIDEsMSBsIDksOSBNIDEwLDEgbCAtOSw5Ij48L3BhdGg+PC9tYXJrZXI+PGcgY2xhc3M9InJvb3QiPjxnIGNsYXNzPSJjbHVzdGVycyI+PC9nPjxnIGNsYXNzPSJlZGdlUGF0aHMiPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMV9pZDIxXzAiIGQ9Ik0zMTAuNjM5LDI2LjY2N0wyODcuMzExLDMyLjY5OUMyNjMuOTgyLDM4LjczMSwyMTcuMzI1LDUwLjc5NSwxOTMuOTk3LDYwLjMyN0MxNzAuNjY4LDY5Ljg1OSwxNzAuNjY4LDc2Ljg1OSwxNzAuNjY4LDgwLjM1OUwxNzAuNjY4LDgzLjg1OSI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMV9pZDIyXzEiIGQ9Ik0zMjUuMDk0LDM3Ljg1OUwzMjUuMDk0LDQyLjAyNkMzMjUuMDk0LDQ2LjE5MywzMjUuMDk0LDU0LjUyNiwzMjUuMDk0LDYyLjczNkMzMjUuMDk0LDcwLjk0NSwzMjUuMDk0LDc5LjAzMSwzMjUuMDk0LDgzLjA3NEwzMjUuMDk0LDg3LjExNyI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMV9pZDIzXzIiIGQ9Ik0zMzkuNzAyLDI2LjAxM0wzNjguNzk5LDMyLjE1NEMzOTcuODk2LDM4LjI5NSw0NTYuMDkxLDUwLjU3Nyw0ODUuMTg4LDYwLjIyM0M1MTQuMjg1LDY5Ljg3LDUxNC4yODUsNzYuODgsNTE0LjI4NSw4MC4zODVMNTE0LjI4NSw4My44OTEiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDIxX2lkMzFfMyIgZD0iTTE1Ny4zOTMsMTA5LjcyTDE0Ni43OSwxMTUuMjNDMTM2LjE4OCwxMjAuNzQsMTE0Ljk4MiwxMzEuNzYxLDEwNC4zOCwxNDAuODczQzkzLjc3NywxNDkuOTg0LDkzLjc3NywxNTcuMTg4LDkzLjc3NywxNjAuNzg5TDkzLjc3NywxNjQuMzkxIj48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQyMV9pZDMyXzQiIGQ9Ik0xODMuOTQzLDEwOS43MkwxOTQuNTQ2LDExNS4yM0MyMDUuMTQ4LDEyMC43NCwyMjYuMzUzLDEzMS43NjEsMjM2Ljk1NiwxNDAuODczQzI0Ny41NTksMTQ5Ljk4NCwyNDcuNTU5LDE1Ny4xODgsMjQ3LjU1OSwxNjAuNzg5TDI0Ny41NTksMTY0LjM5MSI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMzFfaWQ0MV81IiBkPSJNODMuODQ1LDE5My4wMjdMNzkuMDkzLDE5Ny45NjJDNzQuMzQxLDIwMi44OTgsNjQuODM2LDIxMi43NjksNjAuMDg0LDIyMS4yMDVDNTUuMzMyLDIyOS42NDEsNTUuMzMyLDIzNi42NDEsNTUuMzMyLDI0MC4xNDFMNTUuMzMyLDI0My42NDEiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDMxX2lkNDJfNiIgZD0iTTEwMy43MSwxOTMuMDI3TDEwOC40NjIsMTk3Ljk2MkMxMTMuMjE0LDIwMi44OTgsMTIyLjcxOCwyMTIuNzY5LDEyNy40NzEsMjIxLjg2NkMxMzIuMjIzLDIzMC45NjQsMTMyLjIyMywyMzkuMjg2LDEzMi4yMjMsMjQzLjQ0OEwxMzIuMjIzLDI0Ny42MDkiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDQxX2lkNTFfNyIgZD0iTTQ1LjAxNCwyNzQuNTQyTDQwLjY3MywyNzkuMzY5QzM2LjMzMiwyODQuMTk1LDI3LjY1LDI5My44NDcsMjMuMzEsMzAyLjkxN0MxOC45NjksMzExLjk4NywxOC45NjksMzIwLjQ3NCwxOC45NjksMzI0LjcxN0wxOC45NjksMzI4Ljk2MSI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkNDFfaWQ1Ml84IiBkPSJNNjYuMjU2LDI3My45NjhMNzEuMTksMjc4Ljg5Qzc2LjEyNCwyODMuODEyLDg1Ljk5MSwyOTMuNjU2LDkwLjkyNSwzMDIuNjlDOTUuODU5LDMxMS43MjQsOTUuODU5LDMxOS45NDgsOTUuODU5LDMyNC4wNkw5NS44NTksMzI4LjE3MiI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMzJfaWQ0M185IiBkPSJNMjM3LjYyNiwxOTMuMDI3TDIzMi44NzQsMTk3Ljk2MkMyMjguMTIyLDIwMi44OTgsMjE4LjYxOCwyMTIuNzY5LDIxMy44NjUsMjIxLjIwNUMyMDkuMTEzLDIyOS42NDEsMjA5LjExMywyMzYuNjQxLDIwOS4xMTMsMjQwLjE0MUwyMDkuMTEzLDI0My42NDEiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDMyX2lkNDRfMTAiIGQ9Ik0yNTcuNDkxLDE5My4wMjdMMjYyLjI0MywxOTcuOTYyQzI2Ni45OTUsMjAyLjg5OCwyNzYuNSwyMTIuNzY5LDI4MS4yNTIsMjIxLjg2NkMyODYuMDA0LDIzMC45NjQsMjg2LjAwNCwyMzkuMjg2LDI4Ni4wMDQsMjQzLjQ0OEwyODYuMDA0LDI0Ny42MDkiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDQzX2lkNTNfMTEiIGQ9Ik0xOTguMTksMjczLjk2OEwxOTMuMjU2LDI3OC44OUMxODguMzIyLDI4My44MTIsMTc4LjQ1NCwyOTMuNjU2LDE3My41MiwzMDIuODIxQzE2OC41ODYsMzExLjk4NywxNjguNTg2LDMyMC40NzQsMTY4LjU4NiwzMjQuNzE3TDE2OC41ODYsMzI4Ljk2MSI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkNDNfaWQ1NF8xMiIgZD0iTTIyMC4wNTUsMjczLjk1TDIyNS4wMDgsMjc4Ljg3NUMyMjkuOTYxLDI4My44LDIzOS44NjcsMjkzLjY1LDI0NC44MiwzMDIuNzMxQzI0OS43NzMsMzExLjgxMywyNDkuNzczLDMyMC4xMjUsMjQ5Ljc3MywzMjQuMjgxTDI0OS43NzMsMzI4LjQzOCI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMjJfaWQzM18xMyIgZD0iTTMyNS4wOTQsMTE0LjUyM0wzMjUuMDk0LDExOS4yMzNDMzI1LjA5NCwxMjMuOTQzLDMyNS4wOTQsMTMzLjM2MiwzMjUuMDk0LDE0Mi4yMTdDMzI1LjA5NCwxNTEuMDczLDMyNS4wOTQsMTU5LjM2NSwzMjUuMDk0LDE2My41MUwzMjUuMDk0LDE2Ny42NTYiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDIzX2lkMzRfMTQiIGQ9Ik01MDAuMjEsMTA3LjhMNDgzLjczMiwxMTMuNjNDNDY3LjI1NCwxMTkuNDYsNDM0LjI5NywxMzEuMTIxLDQxNy44MTgsMTQwLjU1M0M0MDEuMzQsMTQ5Ljk4NCw0MDEuMzQsMTU3LjE4OCw0MDEuMzQsMTYwLjc4OUw0MDEuMzQsMTY0LjM5MSI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMzRfaWQ0NV8xNSIgZD0iTTM5MS40MDcsMTkzLjAyN0wzODYuNjU1LDE5Ny45NjJDMzgxLjkwMywyMDIuODk4LDM3Mi4zOTksMjEyLjc2OSwzNjcuNjQ3LDIyMS4yMDVDMzYyLjg5NSwyMjkuNjQxLDM2Mi44OTUsMjM2LjY0MSwzNjIuODk1LDI0MC4xNDFMMzYyLjg5NSwyNDMuNjQxIj48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQzNF9pZDQ2XzE2IiBkPSJNNDExLjI3MiwxOTMuMDI3TDQxNi4wMjQsMTk3Ljk2MkM0MjAuNzc3LDIwMi44OTgsNDMwLjI4MSwyMTIuNzY5LDQzNS4wMzMsMjIxLjg2NkM0MzkuNzg1LDIzMC45NjQsNDM5Ljc4NSwyMzkuMjg2LDQzOS43ODUsMjQzLjQ0OEw0MzkuNzg1LDI0Ny42MDkiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDQ1X2lkNTVfMTciIGQ9Ik0zNTEuOTUzLDI3My45NUwzNDcsMjc4Ljg3NUMzNDIuMDQ3LDI4My44LDMzMi4xNDEsMjkzLjY1LDMyNy4xODgsMzAyLjgxOEMzMjIuMjM0LDMxMS45ODcsMzIyLjIzNCwzMjAuNDc0LDMyMi4yMzQsMzI0LjcxN0wzMjIuMjM0LDMyOC45NjEiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDQ1X2lkNTZfMTgiIGQ9Ik0zNzYuNDUxLDI3MC40MzhMMzg2LjU5LDI3NS45NDhDMzk2LjcyOSwyODEuNDU5LDQxNy4wMDcsMjkyLjQ3OSw0MjcuMTQ2LDMwMi4xNDZDNDM3LjI4NSwzMTEuODEzLDQzNy4yODUsMzIwLjEyNSw0MzcuMjg1LDMyNC4yODFMNDM3LjI4NSwzMjguNDM4Ij48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQyM19pZDM1XzE5IiBkPSJNNTE0LjI4NSwxMTcuNzVMNTE0LjI4NSwxMjEuOTIyQzUxNC4yODUsMTI2LjA5NCw1MTQuMjg1LDEzNC40MzgsNTE0LjI4NSwxNDIuNjQ3QzUxNC4yODUsMTUwLjg1Nyw1MTQuMjg1LDE1OC45MzIsNTE0LjI4NSwxNjIuOTdMNTE0LjI4NSwxNjcuMDA4Ij48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQzNV9pZDQ3XzIwIiBkPSJNNTE0LjI4NSwxOTQuNDE0TDUxNC4yODUsMTk5LjExOEM1MTQuMjg1LDIwMy44MjMsNTE0LjI4NSwyMTMuMjMyLDUxNC4yODUsMjIyLjA4OUM1MTQuMjg1LDIzMC45NDUsNTE0LjI4NSwyMzkuMjUsNTE0LjI4NSwyNDMuNDAyTDUxNC4yODUsMjQ3LjU1NSI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMjNfaWQzNl8yMSIgZD0iTTUyOC44OTIsMTA1LjkxTDU1Ny45NDIsMTEyLjA1NUM1ODYuOTkyLDExOC4yMDEsNjQ1LjA5MSwxMzAuNDkxLDY3NC4xNDEsMTQwLjEzNkM3MDMuMTkxLDE0OS43ODEsNzAzLjE5MSwxNTYuNzgxLDcwMy4xOTEsMTYwLjI4MUw3MDMuMTkxLDE2My43ODEiPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDM2X2lkNDhfMjIiIGQ9Ik02ODkuMTE5LDE4Ny42OThMNjcyLjY4NiwxOTMuNTIyQzY1Ni4yNTMsMTk5LjM0Niw2MjMuMzg2LDIxMC45OTMsNjA2Ljk1MywyMjAuNTAyQzU5MC41MiwyMzAuMDEsNTkwLjUyLDIzNy4zOCw1OTAuNTIsMjQxLjA2NUw1OTAuNTIsMjQ0Ljc1Ij48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ0OF9pZDU3XzIzIiBkPSJNNTgwLjU5OCwyNzMuMzk3TDU3NS43NzgsMjc4LjQxNEM1NzAuOTU3LDI4My40MzEsNTYxLjMxNywyOTMuNDY2LDU1Ni40OTYsMzAxLjk4M0M1NTEuNjc2LDMxMC41LDU1MS42NzYsMzE3LjUsNTUxLjY3NiwzMjFMNTUxLjY3NiwzMjQuNSI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkNTdfaWQ2MV8yNCIgZD0iTTU0MS4zNTgsMzU1LjQwMkw1MzcuMDE3LDM2MC4yMjhDNTMyLjY3NiwzNjUuMDU0LDUyMy45OTQsMzc0LjcwNyw1MTkuNjUzLDM4My4xNjVDNTE1LjMxMywzOTEuNjIyLDUxNS4zMTMsMzk4Ljg4NSw1MTUuMzEzLDQwMi41MTdMNTE1LjMxMyw0MDYuMTQ4Ij48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ1N19pZDYyXzI1IiBkPSJNNTY1LjI3OSwzNTEuMjExTDU3NS42MDEsMzU2LjczNkM1ODUuOTIzLDM2Mi4yNiw2MDYuNTY3LDM3My4zMSw2MTYuODg5LDM4Mi4zMzVDNjI3LjIxMSwzOTEuMzU5LDYyNy4yMTEsMzk4LjM1OSw2MjcuMjExLDQwMS44NTlMNjI3LjIxMSw0MDUuMzU5Ij48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ0OF9pZDU4XzI2IiBkPSJNNjAwLjMzNCwyNzMuNDk5TDYwNS4wMzksMjc4LjQ5OUM2MDkuNzQ0LDI4My40OTksNjE5LjE1NSwyOTMuNSw2MjMuODYxLDMwMi42NjFDNjI4LjU2NiwzMTEuODIzLDYyOC41NjYsMzIwLjE0Niw2MjguNTY2LDMyNC4zMDdMNjI4LjU2NiwzMjguNDY5Ij48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQzNl9pZDQ5XzI3IiBkPSJNNzAzLjM0LDE5Ny42NEw3MDMuMzgyLDIwMS44MDdDNzAzLjQyNCwyMDUuOTczLDcwMy41MDcsMjE0LjMwNyw3MDMuNTQ4LDIyMi41OTVDNzAzLjU5LDIzMC44ODMsNzAzLjU5LDIzOS4xMjUsNzAzLjU5LDI0My4yNDZMNzAzLjU5LDI0Ny4zNjciPjwvcGF0aD48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI2NvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDQ5X2lkNTlfMjgiIGQ9Ik03MDMuNTksMjc0Ljc3M0w3MDMuNTksMjc5LjU2MUM3MDMuNTksMjg0LjM0OSw3MDMuNTksMjkzLjkyNCw3MDMuNTksMzAyLjgyM0M3MDMuNTksMzExLjcyMSw3MDMuNTksMzE5Ljk0Myw3MDMuNTksMzI0LjA1M0w3MDMuNTksMzI4LjE2NCI+PC9wYXRoPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMzZfaWQ0MTBfMjkiIGQ9Ik03MTYuMzMzLDE4OS43OTVMNzI2LjQ4OSwxOTUuMjY5QzczNi42NDYsMjAwLjc0Myw3NTYuOTU4LDIxMS42OTIsNzY3LjExNCwyMjEuMjg3Qzc3Ny4yNywyMzAuODgzLDc3Ny4yNywyMzkuMTI1LDc3Ny4yNywyNDMuMjQ2TDc3Ny4yNywyNDcuMzY3Ij48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ0MTBfaWQ1MTBfMzAiIGQ9Ik03NzcuMjcsMjc0Ljc3M0w3NzcuMjcsMjc5LjU2MUM3NzcuMjcsMjg0LjM0OSw3NzcuMjcsMjkzLjkyNCw3NzcuMjcsMzAyLjc5OEM3NzcuMjcsMzExLjY3Miw3NzcuMjcsMzE5Ljg0NCw3NzcuMjcsMzIzLjkzTDc3Ny4yNywzMjguMDE2Ij48L3BhdGg+PHBhdGggbWFya2VyLWVuZD0idXJsKCNjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ1MTBfaWQ2M18zMSIgZD0iTTc3Ny4yNywzNTUuODQ0TDc3Ny4yNywzNjAuNTk2Qzc3Ny4yNywzNjUuMzQ5LDc3Ny4yNywzNzQuODU0LDc3Ny4yNywzODMuMjM4Qzc3Ny4yNywzOTEuNjIyLDc3Ny4yNywzOTguODg1LDc3Ny4yNyw0MDIuNTE3TDc3Ny4yNyw0MDYuMTQ4Ij48L3BhdGg+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWxzIj48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48ZyBjbGFzcz0ibm9kZXMiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMyNS4wOTM3NSwgMjIuOTI5Njg3NSkiIGlkPSJmbG93Y2hhcnQtaWQxLTAiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNC45Mjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNy40Mjk2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTQuODU5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTI8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE3MC42Njc5Njg3NSwgMTAyLjgyMDMxMjUpIiBpZD0iZmxvd2NoYXJ0LWlkMjEtMSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjE0Ljk2MDkzNzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03LjQ2MDkzNzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxNC45MjE4NzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xMzwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzI1LjA5Mzc1LCAxMDIuODIwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQyMi0zIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNzAzMTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC4yMDMxMjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI4LjQwNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+OTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTE0LjI4NTE1NjI1LCAxMDIuODIwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQyMy01IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuOTI5Njg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcuNDI5Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjE0Ljg1OTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjEyPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5My43NzczNDM3NSwgMTgyLjcxMDkzNzUpIiBpZD0iZmxvd2NoYXJ0LWlkMzEtNyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjE0LjMyMDMxMjUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02LjgyMDMxMjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxMy42NDA2MjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xMTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjQ3LjU1ODU5Mzc1LCAxODIuNzEwOTM3NSkiIGlkPSJmbG93Y2hhcnQtaWQzMi05IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuMzIwMzEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYuODIwMzEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEzLjY0MDYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjExPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1NS4zMzIwMzEyNSwgMjYzLjA3MDMxMjUpIiBpZD0iZmxvd2NoYXJ0LWlkNDEtMTEiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNS40Mjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNy45Mjk2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTUuODU5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTA8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMi4yMjI2NTYyNSwgMjYzLjA3MDMxMjUpIiBpZD0iZmxvd2NoYXJ0LWlkNDItMTMiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS40NjA5Mzc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy45NjA5Mzc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iNy45MjE4NzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4yPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOC45Njg3NSwgMzQzLjkyOTY4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNTEtMTUiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMC45Njg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMuNDY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI2LjkzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5NS44NTkzNzUsIDM0My45Mjk2ODc1KSIgaWQ9ImZsb3djaGFydC1pZDUyLTE3IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNzU3ODEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuMjU3ODEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjguNTE1NjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+NDwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjA5LjExMzI4MTI1LCAyNjMuMDcwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQ0My0xOSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjE1LjQyOTY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03LjkyOTY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxNS44NTkzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xMDwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjg2LjAwMzkwNjI1LCAyNjMuMDcwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQ0NC0yMSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjQ2MDkzNzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjk2MDkzNzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI3LjkyMTg3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjI8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE2OC41ODU5Mzc1LCAzNDMuOTI5Njg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ1My0yMyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjEwLjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy40Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjYuOTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI0OS43NzM0Mzc1LCAzNDMuOTI5Njg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ1NC0yNSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjQ5MjE4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjk5MjE4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI3Ljk4NDM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjM8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMyNS4wOTM3NSwgMTgyLjcxMDkzNzUpIiBpZD0iZmxvd2NoYXJ0LWlkMzMtMjciIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS4wNTQ2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy41NTQ2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iNy4xMDkzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD43PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MDEuMzM5ODQzNzUsIDE4Mi43MTA5Mzc1KSIgaWQ9ImZsb3djaGFydC1pZDM0LTI5IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuMzIwMzEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYuODIwMzEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEzLjY0MDYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjExPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNjIuODk0NTMxMjUsIDI2My4wNzAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDQ1LTMxIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTUuNDI5Njg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcuOTI5Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjE1Ljg1OTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjEwPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MzkuNzg1MTU2MjUsIDI2My4wNzAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDQ2LTMzIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNDYwOTM3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMuOTYwOTM3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjcuOTIxODc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MjwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzIyLjIzNDM3NSwgMzQzLjkyOTY4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNTUtMzUiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMC45Njg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMuNDY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI2LjkzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0MzcuMjg1MTU2MjUsIDM0My45Mjk2ODc1KSIgaWQ9ImZsb3djaGFydC1pZDU2LTM3IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNDkyMTg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMuOTkyMTg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjcuOTg0Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MzwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTE0LjI4NTE1NjI1LCAxODIuNzEwOTM3NSkiIGlkPSJmbG93Y2hhcnQtaWQzNS0zOSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjcwMzEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuMjAzMTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC40MDYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjk8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUxNC4yODUxNTYyNSwgMjYzLjA3MDMxMjUpIiBpZD0iZmxvd2NoYXJ0LWlkNDctNDEiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS41MTU2MjUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjAxNTYyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjguMDMxMjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD41PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3MDMuMTkxNDA2MjUsIDE4Mi43MTA5Mzc1KSIgaWQ9ImZsb3djaGFydC1pZDM2LTQzIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuOTI5Njg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcuNDI5Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjE0Ljg1OTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjEyPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1OTAuNTE5NTMxMjUsIDI2My4wNzAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDQ4LTQ1IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuMzIwMzEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYuODIwMzEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEzLjY0MDYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjExPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1NTEuNjc1NzgxMjUsIDM0My45Mjk2ODc1KSIgaWQ9ImZsb3djaGFydC1pZDU3LTQ3IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTUuNDI5Njg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcuOTI5Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjE1Ljg1OTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjEwPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MTUuMzEyNSwgNDIxLjExNzE4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNjEtNDkiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMC45Njg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMuNDY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI2LjkzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MjcuMjEwOTM3NSwgNDIxLjExNzE4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNjItNTEiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS43NTc4MTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC4yNTc4MTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC41MTU2MjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD40PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2MjguNTY2NDA2MjUsIDM0My45Mjk2ODc1KSIgaWQ9ImZsb3djaGFydC1pZDU4LTUzIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNDYwOTM3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMuOTYwOTM3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjcuOTIxODc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MjwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzAzLjU4OTg0Mzc1LCAyNjMuMDcwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQ0OS01NSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjcwMzEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuMjAzMTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC40MDYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjk8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDcwMy41ODk4NDM3NSwgMzQzLjkyOTY4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNTktNTciIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS43NjU2MjUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjI2NTYyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjguNTMxMjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD42PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NzcuMjY5NTMxMjUsIDI2My4wNzAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDQxMC01OSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjcwMzEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuMjAzMTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC40MDYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjk8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDc3Ny4yNjk1MzEyNSwgMzQzLjkyOTY4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNTEwLTYxIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuOTE0MDYyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuNDE0MDYyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjguODI4MTI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+ODwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzc3LjI2OTUzMTI1LCA0MjEuMTE3MTg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ2My02MyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjEwLjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy40Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjYuOTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjwvZz48L2c+PC9nPjwvc3ZnPg==\"/>\n\n\n<div class=\"markdown\"><p>As before, we use nest instanced of <code>RuleNode</code> to implement the AST.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>fizzbuzz_syntaxtree = RuleNode(12, [\n               RuleNode(13, [\n                   RuleNode(11, [\n                       RuleNode(10, [\n                           RuleNode(1),\n                           RuleNode(4)\n                       ]),\n                       RuleNode(2)\n                   ]),\n                   RuleNode(11, [\n                       RuleNode(10, [\n                           RuleNode(1),\n                           RuleNode(3)\n                       ]),\n                       RuleNode(2)\n                   ])\n               ]),\n               RuleNode(9, [\n                   RuleNode(7)\n               \n               ]),\n               RuleNode(12, [\n                   RuleNode(11, [\n                       RuleNode(10, [\n                           RuleNode(1),\n                           RuleNode(3),\n                       ]),\n                       RuleNode(2)\n                   ]),\n                   RuleNode(9, [\n                       RuleNode(5)\n                   ]),\n                   RuleNode(12, [\n                       RuleNode(11, [\n                           RuleNode(10, [\n                               RuleNode(1),\n                               RuleNode(4)\n                           ]),\n                           RuleNode(2)\n                       ]),\n                       RuleNode(9, [\n                           RuleNode(6)\n                       ]),\n                       RuleNode(9, [\n                           RuleNode(8, [\n                                RuleNode(1)\n                            ])\n                       ])\n                   ])\n               ]) \n    ])</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-fizzbuzz_syntaxtree\">12{13{11{10{1,4},2},11{10{1,3},2}},9{7},12{11{10{1,3},2},9{5},12{11{10{1,4},2},9{6},9{8{1}}}}}</pre>\n\n\n<div class=\"markdown\"><p>And we check our syntax tree is correct:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>rulenode2expr(fizzbuzz_syntaxtree, grammar_fizzbuzz)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash153198\">:(if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0\n      \"FizzBuzz\"\n  else\n      if input1 % 3 == 0\n          \"Fizz\"\n      else\n          if input1 % 5 == 0\n              \"Buzz\"\n          else\n              string(input1)\n          end\n      end\n  end)</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    # test solution on inputs\n    input = [Dict(:input1 =&gt; 3), Dict(:input1 =&gt; 5), Dict(:input1 =&gt;15), Dict(:input1 =&gt; 22)]\n    output1 = execute_on_input(grammar_fizzbuzz, fizzbuzz_syntaxtree, input)\n    output1\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-output1\">4-element Vector{Any}:\n \"Fizz\"\n \"Buzz\"\n \"FizzBuzz\"\n \"22\"</pre>\n\n\n<div class=\"markdown\"><h3>Modify the AST/program</h3><p>There are several ways to modify an AST and hence, a program. You can</p><ul><li><p>directly replace a node with <code>HerbCore.swap_node()</code></p></li><li><p>insert a rule node with <code>insert!</code></p></li></ul><p>Let's modify our example such that if the input number is divisible by 3, the program returns \"Buzz\" instead of \"Fizz\".  We use <code>swap_node()</code> to replace the node of the AST that corresponds to rule 5 in the grammar (<code>String = Fizz</code>) with rule 6 (<code>String = Buzz</code>). To do so, <code>swap_node()</code> needs the tree that contains the node we want to modify, the new node we want to replace the node with, and the path to that node.</p><p>Note that <code>swap_node()</code> modifies the tree, hence we make a deep copy of it first.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    modified_fizzbuzz_syntaxtree = deepcopy(fizzbuzz_syntaxtree)\n    newnode = RuleNode(6)\n    path = [3, 2, 1]\n    swap_node(modified_fizzbuzz_syntaxtree, newnode, path)\n    rulenode2expr(modified_fizzbuzz_syntaxtree, grammar_fizzbuzz)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-newnode\">:(if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0\n      \"FizzBuzz\"\n  else\n      if input1 % 3 == 0\n          \"Buzz\"\n      else\n          if input1 % 5 == 0\n              \"Buzz\"\n          else\n              string(input1)\n          end\n      end\n  end)</pre>\n\n\n<div class=\"markdown\"><p>Let's confirm that we modified the AST, and hence the program, correctly:</p></div>\n\n<pre class='language-julia'><code class='language-julia'># test solution on same inputs as before\nexecute_on_input(grammar_fizzbuzz, modified_fizzbuzz_syntaxtree, input)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash144804\">4-element Vector{Any}:\n \"Buzz\"\n \"Buzz\"\n \"FizzBuzz\"\n \"22\"</pre>\n\n\n<div class=\"markdown\"><p>An alternative way to modify the AST is by using <code>insert!()</code>. This requires to provide the location of the node that we want to as <code>NodeLoc</code>. <code>NodeLoc</code> points to a node in the tree and consists of the parent and the child index of the node. Again, we make a deep copy of the original AST first.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    anothermodified_fizzbuzz_syntaxtree = deepcopy(fizzbuzz_syntaxtree)\n    # get the node we want to modify and instantiate a NodeLoc from it.\n    node = get_node_at_location(anothermodified_fizzbuzz_syntaxtree, [3, 2, 1])\n    nodeloc = NodeLoc(node, 0)\n    # replace the node\n    insert!(node, nodeloc, newnode)\n    rulenode2expr(anothermodified_fizzbuzz_syntaxtree, grammar_fizzbuzz)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-anothermodified_fizzbuzz_syntaxtree\">:(if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0\n      \"FizzBuzz\"\n  else\n      if input1 % 3 == 0\n          \"Buzz\"\n      else\n          if input1 % 5 == 0\n              \"Buzz\"\n          else\n              string(input1)\n          end\n      end\n  end)</pre>\n\n\n<div class=\"markdown\"><p>Again, we check that we modified the program as intended:</p></div>\n\n<pre class='language-julia'><code class='language-julia'># test on same inputs as before\nexecute_on_input(grammar_fizzbuzz, anothermodified_fizzbuzz_syntaxtree, input)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash112966\">4-element Vector{Any}:\n \"Buzz\"\n \"Buzz\"\n \"FizzBuzz\"\n \"22\"</pre>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/abstract_syntax_trees/","page":"Abstract Syntax Trees","title":"Abstract Syntax Trees","text":"EditURL = \"https://github.com/Herb-AI/Herb.jl/blob/main/docs/src/tutorials/abstract_syntax_trees.jl\"","category":"page"}]
}
