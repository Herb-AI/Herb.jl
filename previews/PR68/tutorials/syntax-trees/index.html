<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Herb tutorial: Abstract syntax trees · Herb.jl</title><meta name="title" content="Herb tutorial: Abstract syntax trees · Herb.jl"/><meta property="og:title" content="Herb tutorial: Abstract syntax trees · Herb.jl"/><meta property="twitter:title" content="Herb tutorial: Abstract syntax trees · Herb.jl"/><meta name="description" content="Documentation for Herb.jl."/><meta property="og:description" content="Documentation for Herb.jl."/><meta property="twitter:description" content="Documentation for Herb.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Herb.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../">Herb.jl</a></li><li><a class="tocitem" href="../../install/">Installation Guide</a></li><li><a class="tocitem" href="../../get_started/">Getting Started</a></li><li><a class="tocitem" href="../../concepts/">Architecture and core concepts</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_herb/">A more verbose getting started with Herb.jl</a></li><li><a class="tocitem" href="../defining_grammars/">Defining Grammars in Herb.jl</a></li><li><a class="tocitem" href="../advanced_search/">Advanced Search Procedures</a></li><li><a class="tocitem" href="../TopDown/">Top Down Iterator</a></li><li><a class="tocitem" href="../getting_started_with_constraints/">Getting started with Constraints</a></li><li><a class="tocitem" href="../working_with_interpreters/">Working with custom interpreters</a></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../../HerbCore/">HerbCore.jl</a></li><li><a class="tocitem" href="../../HerbGrammar/">HerbGrammar.jl</a></li><li><a class="tocitem" href="../../HerbSpecification/">HerbSpecification.jl</a></li><li><a class="tocitem" href="../../HerbInterpret/">HerbInterpret.jl</a></li><li><a class="tocitem" href="../../HerbConstraints/">HerbConstraints.jl</a></li><li><a class="tocitem" href="../../HerbSearch/">HerbSearch.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Herb tutorial: Abstract syntax trees</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Herb tutorial: Abstract syntax trees</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl/blob/master/docs/src/tutorials/syntax-trees.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Herb-tutorial:-Abstract-syntax-trees"><a class="docs-heading-anchor" href="#Herb-tutorial:-Abstract-syntax-trees">Herb tutorial: Abstract syntax trees</a><a id="Herb-tutorial:-Abstract-syntax-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Herb-tutorial:-Abstract-syntax-trees" title="Permalink"></a></h1><p>In this tutorial, you will learn</p><ul><li>How to represent a computer program as an abstract syntax tree  in Herb.</li><li>How to replace parts of the tree to modify the program.</li></ul><h2 id="Abstract-syntax-trees"><a class="docs-heading-anchor" href="#Abstract-syntax-trees">Abstract syntax trees</a><a id="Abstract-syntax-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-syntax-trees" title="Permalink"></a></h2><p>The syntactic structure of a computer program can be represented in a hierarchical tree structure, a so-called <em>Abstract Syntax Tree (AST)</em>. The syntax of a programming language is typically defined using a formal grammar, a set of rules on how valid programs can be constructed. ASTs are derived from the grammar, but are abstractions in the sense that they omit details such as parenthesis, semicolons, etc. and only retain what&#39;s necessary to capture the program structure. </p><p>In the context of program synthesis, ASTs are often used to define the space of all possible programs which is searched to find one that satisfies the given specifications. During the search process, different ASTs, each corresponding to a different program, are generated and evaluated until a suitable one is found.</p><p>Each <em>node</em> of the AST represents a construct in the program (e.g., a variable, an operator, a statement, or a function) and this construct corresponds to a rule in the formal grammar.  An <em>edge</em> describes the relationship between constructs, and the tree structure captures the nesting of constructs. </p><h2 id="A-simple-example-program"><a class="docs-heading-anchor" href="#A-simple-example-program">A simple example program</a><a id="A-simple-example-program-1"></a><a class="docs-heading-anchor-permalink" href="#A-simple-example-program" title="Permalink"></a></h2><p>We first consider the simple program 5*(x+3). We will define a grammar that is sufficient to represent this program and use it to construct a AST for our program.</p><h3 id="Define-the-grammar"><a class="docs-heading-anchor" href="#Define-the-grammar">Define the grammar</a><a id="Define-the-grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-grammar" title="Permalink"></a></h3><pre><code class="language-julia hljs">using HerbCore, HerbGrammar, HerbInterpret

grammar = @csgrammar begin
    Number = |(0:9)
    Number = x
    Number = Number + Number
    Number = Number * Number
end
</code></pre><pre><code class="nohighlight hljs">1: Number = 0
2: Number = 1
3: Number = 2
4: Number = 3
5: Number = 4
6: Number = 5
7: Number = 6
8: Number = 7
9: Number = 8
10: Number = 9
11: Number = x
12: Number = Number + Number
13: Number = Number * Number</code></pre><h3 id="Construct-the-syntax-tree"><a class="docs-heading-anchor" href="#Construct-the-syntax-tree">Construct the syntax tree</a><a id="Construct-the-syntax-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-the-syntax-tree" title="Permalink"></a></h3><p>The AST of this program is shown in the diagram below. The number in each node refers to the index of the corresponding rule in our grammar. </p><pre><code class="language-mermaid hljs">    flowchart 
    id1((13)) ---
    id2((6))
    id1 --- id3((12))
    id4((11))
    id5((4))
    id3 --- id4
    id3 --- id5</code></pre><p>In <code>Herb.jl</code>, the <code>HerbCore.RuleNode</code> is used to represent both an individual node, but also entire ASTs or sub-trees. This is achieved by nesting instances of <code>RuleNode</code>. A <code>RuleNode</code> can be instantiated by providing the index of the grammar rule that the node represents and a vector of child nodes. </p><pre><code class="language-julia hljs">syntaxtree = RuleNode(13, [RuleNode(6), RuleNode(12, [RuleNode(11), RuleNode(4)])])</code></pre><pre><code class="nohighlight hljs">13{6,12{11,4}}</code></pre><p>We can confirm that our AST is correct by displaying it in a more human-readable way, using <code>HerbGrammar.rulenode2expr</code> and by testing it on a few input examples using <code>HerbInterpret.execute_on_input</code>.</p><pre><code class="language-julia hljs">program = rulenode2expr(syntaxtree, grammar)
println(program)</code></pre><pre><code class="nohighlight hljs">5 * (x + 3)</code></pre><pre><code class="language-julia hljs"># test solution on inputs
output = execute_on_input(grammar, syntaxtree, Dict(:x =&gt; 10))</code></pre><pre><code class="nohighlight hljs">65</code></pre><h2 id="Another-example:-FizzBuzz"><a class="docs-heading-anchor" href="#Another-example:-FizzBuzz">Another example: FizzBuzz</a><a id="Another-example:-FizzBuzz-1"></a><a class="docs-heading-anchor-permalink" href="#Another-example:-FizzBuzz" title="Permalink"></a></h2><p>Let&#39;s look at a more interesting example.  The program <code>fizbuzz()</code> is based on the popular <em>FizzBuzz</em> problem. Given an integer number, the program simply returns a <code>String</code> of that number, but replace numbers divisible by 3 with <code>&quot;Fizz&quot;</code>, numbers divisible by 5 with <code>&quot;Buzz&quot;</code>, and number divisible by both 3 and 5 with <code>&quot;FizzBuzz&quot;</code>.</p><pre><code class="language-julia hljs">function fizzbuzz(x)
    if x % 5 == 0 &amp;&amp; x % 3 == 0
        return &quot;FizzBuzz&quot;
    else
        if x % 3 == 0
            return  &quot;Fizz&quot;
        else
            if x % 5 == 0
                return &quot;Buzz&quot;
            else
                return string(x)
            end
        end
    end
end</code></pre><pre><code class="nohighlight hljs">fizzbuzz (generic function with 1 method)</code></pre><h3 id="Define-the-grammar-2"><a class="docs-heading-anchor" href="#Define-the-grammar-2">Define the grammar</a><a class="docs-heading-anchor-permalink" href="#Define-the-grammar-2" title="Permalink"></a></h3><p>Let&#39;s define a grammar with all the rules that we need.</p><pre><code class="language-julia hljs">grammar_fizzbuzz = @csgrammar begin
    Int = input1
    Int = 0 | 3 | 5
    String = &quot;Fizz&quot; | &quot;Buzz&quot; | &quot;FizzBuzz&quot;
    String = string(Int)
    Return = String
    Int = Int % Int
    Bool = Int == Int
    Int = Bool ? Int : Int
    Bool = Bool &amp;&amp; Bool
end</code></pre><pre><code class="nohighlight hljs">1: Int = input1
2: Int = 0
3: Int = 3
4: Int = 5
5: String = Fizz
6: String = Buzz
7: String = FizzBuzz
8: String = string(Int)
9: Return = String
10: Int = Int % Int
11: Bool = Int == Int
12: Int = if Bool
    Int
else
    Int
end
13: Bool = Bool &amp;&amp; Bool</code></pre><h3 id="Construct-the-syntax-tree-2"><a class="docs-heading-anchor" href="#Construct-the-syntax-tree-2">Construct the syntax tree</a><a class="docs-heading-anchor-permalink" href="#Construct-the-syntax-tree-2" title="Permalink"></a></h3><p>Given the grammar, the AST of <code>fizzbuzz()</code> looks like this:</p><pre><code class="language-mermaid hljs">flowchart 
    id1((12)) --- id21((13))
    id1--- id22((9))
    id1--- id23((12))

    id21 --- id31((11))
    id21 --- id32((11))

    id31 --- id41((10))
    id31 --- id42((2))

    id41 --- id51((1))
    id41 --- id52((4))

    id32 --- id43((10)) 
    id32 --- id44((2))

    id43 --- id53((1))
    id43 --- id54((3))

    id22 --- id33((7))
    id23 --- id34((11))

    id34 --- id45((10))
    id34 --- id46((2))

    id45 --- id55((1))
    id45 --- id56((3))

    id23 --- id35((9))
    id35 --- id47((5))

    id23 --- id36((12))
    id36 --- id48((11))
    id48 --- id57((10))
    id57 --- id61((1))
    id57 --- id62((4))
    id48 --- id58((2))

    id36 --- id49((9))
    id49 --- id59((6))

    id36 --- id410((9))
    id410 --- id510((8))
    id510 --- id63((1))
    
    
    </code></pre><p>As before, we use nest instanced of <code>RuleNode</code> to implement the AST.</p><pre><code class="language-julia hljs">fizzbuzz_syntaxtree = RuleNode(12, [
               RuleNode(13, [
                   RuleNode(11, [
                       RuleNode(10, [
                           RuleNode(1),
                           RuleNode(4)
                       ]),
                       RuleNode(2)
                   ]),
                   RuleNode(11, [
                       RuleNode(10, [
                           RuleNode(1),
                           RuleNode(3)
                       ]),
                       RuleNode(2)
                   ])
               ]),
               RuleNode(9, [
                   RuleNode(7)
               
               ]),
               RuleNode(12, [
                   RuleNode(11, [
                       RuleNode(10, [
                           RuleNode(1),
                           RuleNode(3),
                       ]),
                       RuleNode(2)
                   ]),
                   RuleNode(9, [
                       RuleNode(5)
                   ]),
                   RuleNode(12, [
                       RuleNode(11, [
                           RuleNode(10, [
                               RuleNode(1),
                               RuleNode(4)
                           ]),
                           RuleNode(2)
                       ]),
                       RuleNode(9, [
                           RuleNode(6)
                       ]),
                       RuleNode(9, [
                           RuleNode(8, [
                                RuleNode(1)
                            ])
                       ])
                   ])
               ]) 
    ])</code></pre><pre><code class="nohighlight hljs">12{13{11{10{1,4}2}11{10{1,3}2}}9{7}12{11{10{1,3}2}9{5}12{11{10{1,4}2}9{6}9{8{1}}}}}</code></pre><p>And we check our syntax tree is correct:</p><pre><code class="language-julia hljs">program = rulenode2expr(fizzbuzz_syntaxtree, grammar_fizzbuzz)
println(program)</code></pre><pre><code class="nohighlight hljs">if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0
    &quot;FizzBuzz&quot;
else
    if input1 % 3 == 0
        &quot;Fizz&quot;
    else
        if input1 % 5 == 0
            &quot;Buzz&quot;
        else
            string(input1)
        end
    end
end</code></pre><pre><code class="language-julia hljs"># test solution on inputs
input = [Dict(:input1 =&gt; 3), Dict(:input1 =&gt; 5), Dict(:input1 =&gt;15), Dict(:input1 =&gt; 22)]
output = execute_on_input(grammar_fizzbuzz, fizzbuzz_syntaxtree, input)</code></pre><pre><code class="nohighlight hljs">4-element Vector{Any}:
 &quot;Fizz&quot;
 &quot;Buzz&quot;
 &quot;FizzBuzz&quot;
 &quot;22&quot;</code></pre><h3 id="Modify-the-AST/program"><a class="docs-heading-anchor" href="#Modify-the-AST/program">Modify the AST/program</a><a id="Modify-the-AST/program-1"></a><a class="docs-heading-anchor-permalink" href="#Modify-the-AST/program" title="Permalink"></a></h3><p>There are several ways to modify an AST and hence, a program. You can</p><ul><li>directly replace a node with <code>HerbCore.swap_node()</code></li><li>insert a rule node with <code>insert!</code></li></ul><p>Let&#39;s modify our example such that if the input number is divisible by 3, the program returns &quot;Buzz&quot; instead of &quot;Fizz&quot;.  We use <code>swap_node()</code> to replace the node of the AST that corresponds to rule 5 in the grammar (<code>String = Fizz</code>) with rule 6 (<code>String = Buzz</code>). To do so, <code>swap_node()</code> needs the tree that contains the node we want to modify, the new node we want to replace the node with, and the path to that node.</p><p>Note that <code>swap_node()</code> modifies the tree, hence we make a deep copy of it first.</p><pre><code class="language-julia hljs">modified_fizzbuzz_syntaxtree = deepcopy(fizzbuzz_syntaxtree)
newnode = RuleNode(6)
path = [3, 2, 1]
swap_node(modified_fizzbuzz_syntaxtree, newnode, path)</code></pre><pre><code class="nohighlight hljs">6,</code></pre><p>Let&#39;s confirm that we modified the AST, and hence the program, correctly:</p><pre><code class="language-julia hljs">program = rulenode2expr(modified_fizzbuzz_syntaxtree, grammar_fizzbuzz)
println(program)</code></pre><pre><code class="nohighlight hljs">if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0
    &quot;FizzBuzz&quot;
else
    if input1 % 3 == 0
        &quot;Buzz&quot;
    else
        if input1 % 5 == 0
            &quot;Buzz&quot;
        else
            string(input1)
        end
    end
end</code></pre><pre><code class="language-julia hljs"># test solution on same inputs as before
output = execute_on_input(grammar_fizzbuzz, modified_fizzbuzz_syntaxtree, input)</code></pre><pre><code class="nohighlight hljs">4-element Vector{Any}:
 &quot;Buzz&quot;
 &quot;Buzz&quot;
 &quot;FizzBuzz&quot;
 &quot;22&quot;</code></pre><p>An alternative way to modify the AST is by using <code>insert!()</code>. This requires to provide the location of the node that we want to as <code>NodeLoc</code>. <code>NodeLoc</code> points to a node in the tree and consists of the parent and the child index of the node. Again, we make a deep copy of the original AST first.</p><pre><code class="language-julia hljs">modified_fizzbuzz_syntaxtree = deepcopy(fizzbuzz_syntaxtree)
# get the node we want to modify and instantiate a NodeLoc from it.
node = get_node_at_location(modified_fizzbuzz_syntaxtree, [3, 2, 1])
nodeloc = NodeLoc(node, 0)
# replace the node
insert!(node, nodeloc, newnode)</code></pre><pre><code class="nohighlight hljs">6,</code></pre><p>Again, we check that we modified the program as intended:</p><pre><code class="language-julia hljs">program = rulenode2expr(modified_fizzbuzz_syntaxtree, grammar_fizzbuzz)
println(program)</code></pre><pre><code class="nohighlight hljs">if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0
    &quot;FizzBuzz&quot;
else
    if input1 % 3 == 0
        &quot;Buzz&quot;
    else
        if input1 % 5 == 0
            &quot;Buzz&quot;
        else
            string(input1)
        end
    end
end</code></pre><pre><code class="language-julia hljs"># test on same inputs as before
output = execute_on_input(grammar_fizzbuzz, modified_fizzbuzz_syntaxtree, input)</code></pre><pre><code class="nohighlight hljs">4-element Vector{Any}:
 &quot;Buzz&quot;
 &quot;Buzz&quot;
 &quot;FizzBuzz&quot;
 &quot;22&quot;</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 9 July 2024 11:18">Tuesday 9 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
