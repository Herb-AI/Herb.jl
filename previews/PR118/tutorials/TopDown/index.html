<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Top Down Iterator · Herb.jl</title><meta name="title" content="Top Down Iterator · Herb.jl"/><meta property="og:title" content="Top Down Iterator · Herb.jl"/><meta property="twitter:title" content="Top Down Iterator · Herb.jl"/><meta name="description" content="Documentation for Herb.jl."/><meta property="og:description" content="Documentation for Herb.jl."/><meta property="twitter:description" content="Documentation for Herb.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Herb.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../">Herb.jl</a></li><li><a class="tocitem" href="../../install/">Installation Guide</a></li><li><a class="tocitem" href="../../get_started/">Getting Started</a></li><li><a class="tocitem" href="../../concepts/">Architecture and core concepts</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_herb/">A more verbose getting started with Herb.jl</a></li><li><a class="tocitem" href="../defining_grammars/">Defining Grammars in Herb.jl</a></li><li><a class="tocitem" href="../advanced_search/">Advanced Search Procedures</a></li><li class="is-active"><a class="tocitem" href>Top Down Iterator</a><ul class="internal"><li><a class="tocitem" href="#Top-Down-iterator"><span>Top Down iterator</span></a></li><li class="toplevel"><a class="tocitem" href="#Modifying-the-provided-iterator"><span>Modifying the provided iterator</span></a></li><li class="toplevel"><a class="tocitem" href="#A-note-on-data-structures"><span>A note on data structures</span></a></li><li class="toplevel"><a class="tocitem" href="#Extra:-Find-Next-Complete-Tree-/-Program"><span>Extra: Find Next Complete Tree / Program</span></a></li></ul></li><li><a class="tocitem" href="../getting_started_with_constraints/">Getting started with Constraints</a></li><li><a class="tocitem" href="../working_with_interpreters/">Working with custom interpreters</a></li><li><a class="tocitem" href="../abstract_syntax_trees/">Abstract Syntax Trees</a></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../../HerbCore/">HerbCore.jl</a></li><li><a class="tocitem" href="../../HerbGrammar/">HerbGrammar.jl</a></li><li><a class="tocitem" href="../../HerbSpecification/">HerbSpecification.jl</a></li><li><a class="tocitem" href="../../HerbInterpret/">HerbInterpret.jl</a></li><li><a class="tocitem" href="../../HerbConstraints/">HerbConstraints.jl</a></li><li><a class="tocitem" href="../../HerbSearch/">HerbSearch.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Top Down Iterator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Top Down Iterator</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl/blob/master/docs/src/tutorials/TopDown.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Building-Herb-Iterators"><a class="docs-heading-anchor" href="#Building-Herb-Iterators">Building Herb Iterators</a><a id="Building-Herb-Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Herb-Iterators" title="Permalink"></a></h1><p>The core building block in Herb is a program iterator. A program iterator represents a walk through the program space; different iterators provide different ways of iterating through program space.  From the program synthesis point of view, program iterators actually represent program spaces.</p><pre><code class="language-mermaid hljs">    flowchart TD
    id1((13)) ---
    id2((6))
    id1 --- id3((12))
    id4((11))
    id5((4))
    id3 --- id4
    id3 --- id5</code></pre><h3 id="Iterator-hierarchy"><a class="docs-heading-anchor" href="#Iterator-hierarchy">Iterator hierarchy</a><a id="Iterator-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Iterator-hierarchy" title="Permalink"></a></h3><p>Program iterators are organised in a hierarchy. The top-level abstract type is <code>ProgramIterator</code>.  At the next level of the hierarchy lie commonly used search families:</p><ul><li><code>TopDownIterator</code> for top-down traversals</li><li><code>StochasticSearachIterator</code> for traversals with stochastic search</li><li><code>BottomUpIterator</code> for bottom-up search</li></ul><p>Stochastic search further provides specific iterators:</p><ul><li><code>MHSearchIterator</code> for program traversal with Metropolis-Hastings algorithm</li><li><code>VLNSearchIterator</code> for traversals with Very Large Neighbourhood Search</li><li><code>SASearchIterator</code> for Simulated Annealing</li></ul><p>We provide generic and customisable implementations of each of these iterators, so that users can easily tweak them by through multiple dispatch. Keep reading!</p><h3 id="Iterator-design"><a class="docs-heading-anchor" href="#Iterator-design">Iterator design</a><a id="Iterator-design-1"></a><a class="docs-heading-anchor-permalink" href="#Iterator-design" title="Permalink"></a></h3><p>Program iterators follow the standard Julia <code>Iterator</code> interface. That is, every iterator should implement two functions:</p><ul><li><code>iterate(&lt;:ProgramIterator)::(RuleNode,Any)</code> to get the first program. The function takes a program iterator as an input, returning the first program and a state (which can be anything)</li><li><code>iterate(&lt;:ProgramIterator,Any)::(RuleNode,Any)</code> to get the consecutive programs. The function takes the program iterator and the state from the previous iteration, and return the next program and the next state.</li></ul><h2 id="Top-Down-iterator"><a class="docs-heading-anchor" href="#Top-Down-iterator">Top Down iterator</a><a id="Top-Down-iterator-1"></a><a class="docs-heading-anchor-permalink" href="#Top-Down-iterator" title="Permalink"></a></h2><p>We illustrate how to build iterators with a Top Down iterator. The top Down iterator is build as a best-first iterator: it maintains a priority queue of programs and always pops the first element of the queue.  The iterator is customisable through the following functions:</p><ul><li>priority_function: dictating the order of programs in the priority queue</li><li>derivation_heuristic: dictating in which order to explore the derivations rules within a single hole</li><li>hole_heuristic: dictating which hole to expand next</li></ul><p>The first call to <code>iterate(iter::TopDownIterator)</code>:</p><pre><code class="language-julia hljs">function Base.iterate(iter::TopDownIterator)
    # Priority queue with `SolverState`s (for variable shaped trees) and `UniformIterator`s (for fixed shaped trees)
    pq :: PriorityQueue{Union{SolverState, UniformIterator}, Union{Real, Tuple{Vararg{Real}}}} = PriorityQueue()

    solver = iter.solver

    if isfeasible(solver)
        enqueue!(pq, get_state(solver), priority_function(iter, get_grammar(solver), get_tree(solver), 0, false))
    end
    return _find_next_complete_tree(iter.solver, pq, iter)
end</code></pre><p>The first call steps everything up: it initiates the priority queue, the constraint solver (more on that later), and return the first program. The function <code>_find_next_complete_tree(iter.solver, pq, iter)</code> does a lot of heavy lifting here; we will cover it later, but the only important thing is that it finds the next complete program in the priority queue (because, in case of top down enumeration, the queue also contains partial programs which we only want to expand, but not return to the user).</p><p>The subsequent call to <code>iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue)</code> are quite simple: all that is needed is to find the next complete program in the priority queue:</p><pre><code class="language-julia hljs">function Base.iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue)
    return _find_next_complete_tree(iter.solver, pq, iter)
end</code></pre><h1 id="Modifying-the-provided-iterator"><a class="docs-heading-anchor" href="#Modifying-the-provided-iterator">Modifying the provided iterator</a><a id="Modifying-the-provided-iterator-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-the-provided-iterator" title="Permalink"></a></h1><p>If you would like to, for example, modify the priority function, you don&#39;t have to implement the iterator from scratch. You simply need to create a new type and inherit from the <code>TopDownIterator</code>:</p><p><code>abstract type MyTopDown &lt;: TopDownIterator end</code>.</p><p>What is left is to implement the priority function, multiple-dispatching it over the new type.  For example, to do a random order:</p><pre><code class="language-julia hljs">function priority_function(
    ::MyTopDown, 
    ::AbstractGrammar, 
    ::AbstractRuleNode, 
    ::Union{Real, Tuple{Vararg{Real}}},
    ::Bool
)
    Random.rand();
end</code></pre><h1 id="A-note-on-data-structures"><a class="docs-heading-anchor" href="#A-note-on-data-structures">A note on data structures</a><a id="A-note-on-data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#A-note-on-data-structures" title="Permalink"></a></h1><p>As you have probably noticed, the priority queue some strange data structures: <code>SolverState</code> and <code>UniformIterator</code>; the top down iterator never puts <code>RuleNode</code>s into the queue. In fact, the iterator never directly manipulates <code>RuleNode</code>s itself, but that is rather delegated to the constraint solver. The constraint solver will do a lot of work to reduce the number of programs we have to consider. The <code>SolverState</code> and <code>UniformIterator</code> are specialised data structure to improve the efficiency and memory usage. </p><p>Herb uses a data structure of <code>UniformTrees</code> to represent all programs with an AST of the same shape, where each node has the same type. the <code>UniformIterator</code> is an iterator efficiently iterating over that structure.</p><p>The <code>SolverState</code> represents non-uniform trees – ASTs whose shape we haven&#39;t completely determined yet. <code>SolverState</code> is used as an intermediate representation before we reach <code>UniformTree</code>s on which partial constraint propagation is done.</p><p>In principle, you should never construct ASTs yourself directly; you should leave that to the constraint solver.</p><h1 id="Extra:-Find-Next-Complete-Tree-/-Program"><a class="docs-heading-anchor" href="#Extra:-Find-Next-Complete-Tree-/-Program">Extra: Find Next Complete Tree / Program</a><a id="Extra:-Find-Next-Complete-Tree-/-Program-1"></a><a class="docs-heading-anchor-permalink" href="#Extra:-Find-Next-Complete-Tree-/-Program" title="Permalink"></a></h1><p>This function pops an element from the priority queue whilst it is not empty, and then checks what kind of iterator it is.</p><pre><code class="language-julia hljs">function _find_next_complete_tree(
    solver::Solver,
    pq::PriorityQueue,
    iter::TopDownIterator
)
    while length(pq) ≠ 0
        (item, priority_value) = dequeue_pair!(pq)
</code></pre><p>If it is a Uniform Iterator, that is an iterator where all the holes have the same shape, then it iterates over the solutions.</p><pre><code class="language-julia hljs">
        if item isa UniformIterator
            #the item is a fixed shaped solver, we should get the next solution and re-enqueue it with a new priority value
            uniform_iterator = item
            solution = next_solution!(uniform_iterator)
            if !isnothing(solution)
                enqueue!(pq, uniform_iterator, priority_function(iter, get_grammar(solver), solution, priority_value, true))
                return (solution, pq)
            end
</code></pre><p>If it is not a Uniform Iterator, we find a hole to branch on. If the holes are all uniform, a Uniform Iterator is created, and is enqueued. If iterating on the holes would exceed a maximum depth, nothing new is enqueued. Lastly, if the holes aren&#39;t the same shape, we branch / partition on the holes, to create new partial domains to enqueue.</p><pre><code class="language-julia hljs">        elseif item isa SolverState
            #the item is a solver state, we should find a variable shaped hole to branch on
            state = item
            load_state!(solver, state)

            hole_res = hole_heuristic(iter, get_tree(solver), get_max_depth(solver))
            if hole_res ≡ already_complete
                uniform_solver = UniformSolver(get_grammar(solver), get_tree(solver), with_statistics=solver.statistics)
                uniform_iterator = UniformIterator(uniform_solver, iter)
                solution = next_solution!(uniform_iterator)
                if !isnothing(solution)
                    enqueue!(pq, uniform_iterator, priority_function(iter, get_grammar(solver), solution, priority_value, true))
                    return (solution, pq)
                end
            elseif hole_res ≡ limit_reached
                # The maximum depth is reached
                continue
            elseif hole_res isa HoleReference
                # Variable Shaped Hole was found
                (; hole, path) = hole_res
        
                partitioned_domains = partition(hole, get_grammar(solver))
                number_of_domains = length(partitioned_domains)
                for (i, domain) ∈ enumerate(partitioned_domains)
                    if i &lt; number_of_domains
                        state = save_state!(solver)
                    end
                    @assert isfeasible(solver) &quot;Attempting to expand an infeasible tree: $(get_tree(solver))&quot;
                    remove_all_but!(solver, path, domain)
                    if isfeasible(solver)
                        enqueue!(pq, get_state(solver), priority_function(iter, get_grammar(solver), get_tree(solver), priority_value, false))
                    end
                    if i &lt; number_of_domains
                        load_state!(solver, state)
                    end
                end
            end

</code></pre><p>Otherwise, throw an exception, because we came across an unexpected iterator type.</p><pre><code class="language-julia hljs">        else
            throw(&quot;BadArgument: PriorityQueue contains an item of unexpected type &#39;$(typeof(item))&#39;&quot;)
        end
    end
    return nothing
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../advanced_search/">« Advanced Search Procedures</a><a class="docs-footer-nextpage" href="../getting_started_with_constraints/">Getting started with Constraints »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 4 December 2024 09:16">Wednesday 4 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
