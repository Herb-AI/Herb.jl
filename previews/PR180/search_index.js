var documenterSearchIndex = {"docs":
[{"location":"install/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Before installing Herb.jl, ensure that you have a running Julia distribution installed (Julia version 1.7 and above were tested). Check below for a more detailed Julia How-To.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Thanks to Julia's package management, installing Herb.jl is very straightforward.  Activate the default Julia REPL using","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"julia","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"or from within one of your projects using","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"julia --project=.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"From the Julia REPL run ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"]\nadd Herb","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"or ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Herb\")","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"to install all dependencies automatically.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"For later convenience we can also add the respective dependencies to our project, so that we do not have to write Herb.HerbGrammar every time.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"] add HerbConstraints HerbCore HerbSpecification HerbInterpret HerbGrammar HerbSearch","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"And just like this you are done! Welcome to Herb.jl!","category":"page"},{"location":"install/#Julia-How-To","page":"Installation Guide","title":"Julia How-To","text":"","category":"section"},{"location":"install/#1.-Install-Julia","page":"Installation Guide","title":"1. Install Julia","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"First, we need to install Julia before we proceed. Head over the Julia downloads page and follow the instructions.","category":"page"},{"location":"install/#Linux-and-MacOS","page":"Installation Guide","title":"Linux & MacOS","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Have a look at the installation page for your distribution or simply paste this into a terminal. ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"install/#Windows","page":"Installation Guide","title":"Windows","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Put this command in Powershell.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"winget install julia -s msstore","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"If winget is not installed install it by checking this link (https://phoenixnap.com/kb/install-winget)","category":"page"},{"location":"install/#Check-Julia-installation","page":"Installation Guide","title":"Check Julia installation","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Open a command prompt/terminal and run julia.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"You should see something similar to this:","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"(Image: image)","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"You will see the start-up message above, including the version number. At the time of writing, this is 1.10.2. You will likely see the latest stable release, listed on the Julia organization's website.","category":"page"},{"location":"install/#Julia-REPL","page":"Installation Guide","title":"Julia REPL","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"What you see right now on the screen is called the Julia REPL (Readâ€“Evalâ€“Print Loop). This is similar to ghci from Haskell and similar to node's REPL too.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Let's try some simple things. Only type the part after julia> without the comment (the part after #)","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"julia> x = 2 # creates a variable called x with value 2\n2            # prints the results \njulia> print(\"hello\",\"julia\")\nhellojulia\njulia> for x in 1:10        # for loop in julia\n           println(x)     \n       end                  # notice how we have to specify end here..\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Now that julia hopefully works, let's clone the repositories. To exit julia use Ctrl+D or simply type exit().","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Typing ? opens a help menu for what the REPL can do.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"help?> \nsearch:  ] [ = $ ; ( @ { \" ) ? . } âŠ½ âŠ¼ âŠ» âŠ‹ âŠŠ âŠ‰ âŠˆ âŠ‡ âŠ† â‰¥ â‰¤ â‰¢ â‰¡ â‰  â‰‰ â‰ˆ âˆª âˆ© âˆœ âˆ› âˆš âˆ˜ âˆŒ âˆ‹ âˆ‰ âˆˆ â„¯ Ï€ Ã· ~ | ^ \\ > < : / - + * ' & % ! && if :: as\n\n  Welcome to Julia 1.10.2. The full manual is available at\n\n  https://docs.julialang.org\n\n  as well as many great tutorials and learning resources:\n\n  https://julialang.org/learning/\n\n  For help on a specific function or macro, type `?` followed by its name, e.g. ?cos, or ?@time, and press enter. Type ; to enter shell\n  mode, ] to enter package mode.\n\n  To exit the interactive session, type CTRL-D (press the control key together with the d key), or type exit(). <- Useful in case you forget how to exit :)","category":"page"},{"location":"install/#2.-Clone-and-install-projects-for-development","page":"Installation Guide","title":"2. Clone and install projects - for development","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Usually, in Julia one would create a script file (something like file.jl) and write his code there. However, Herb consists of packages that other people can use. Think about pip packages or npm packages. ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Thus, the setup will be a bit different from what you see in other programming languages.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"First navigate to the home folder of your operating system. On Linux, this is just cd ~. On Windows open cmd and type cd %userprofile% (This will navigate to C:/Users/your_username). Alternatively, if using PowerShell simply type cd ~.\ntype cd .julia to navigate the folder where Julia keeps the installation things\ntype julia to enter the JULIA REPL. From here we will be able to also install the repositories\ntype ] to enter the \"Package Mode\" of Julia. From here, we can install packages and tasks related to dependency management. After typing ] the REPL should now look like this","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"(Image: image)","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Notice that the colorblueblue color on the left. This indicates that we are in the \"Package Mode\" shell where we do not write code but run commands to manage dependencies or install packages.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"To see what can we do from here, ? is again helpful. Try to read through the output just to get an idea of what options are available.\nType dev HerbSearch Since we want to clone a package for local development we will use the dev or develop command. This will clone the package from Github and store the repository in the ~/.julia/dev folder.\nAfter a lot of packages are installed, you can run st (short for status) to see that HerbSearch was successfully installed.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"The output should look similar to this:","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"(Image: image)","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Exit the terminal (Ctrl+D) and check that a new folder dev appeared using ls (Linux) or dir (Windows)\nNavigate to that folder cd dev. This is the folder where the HerbSearch package was cloned and where we are going to develop our code. If we need to modify the code from other published packages such as HerbData we would have to dev the package locally to change it (e.g. dev HerbData)","category":"page"},{"location":"install/#3.-Setup-IDE-(VSCode)","page":"Installation Guide","title":"3. Setup IDE (VSCode)","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Hopefully, everything has gone smoothly so far ðŸ˜…. Let's set up our IDE to start coding.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Unfortunately, there is no nice JetBrains IDE for Julia like IntelliJ, PyCharm, etc. There is a VSCode extension that is actively developed that works quite well. However, it is sometimes unstable and might crash from time to time (especially if you are on Windows).  This is the extension that we will use.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"If you do not want to use VSCode and want to use vim ðŸ˜‰ check this link.","category":"page"},{"location":"install/#1.-Open-VsCode","page":"Installation Guide","title":"1. Open VsCode","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Assuming vs-code is installed on the system and that you have your terminal still open in the ~/.julia/dev folder you can simply type","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"$ code . ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"To open the folder in VSCode.","category":"page"},{"location":"install/#2.-Install-Julia-extension","page":"Installation Guide","title":"2. Install Julia extension","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Open the extension tab either by clicking or by using the keyboard shortcut (Ctrl+Shift+X) and search for julia and install the first extension. (Image: image)","category":"page"},{"location":"install/#3.-Run-some-example-code","page":"Installation Guide","title":"3. Run some example code","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Create a new file in folder src and give it a name (e.g., getting_started.jl) with .jl as the suffix. Paste the following example code ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"# add all imports\nusing HerbSearch, HerbSpecification, HerbInterpret, HerbGrammar\n\n# define our very simple context-free grammar\n# Can add and multiply an input variable x or the integers 1,2.\ng = @cfgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend\n\n# create a problem with 5 examples by using the function f(x) = 2x + 1\nproblem = Problem([IOExample(Dict(:x => x), 2x+1) for x âˆˆ 1:5])\niterator = BFSIterator(g, :Number, max_depth=5)\n\n# the solution found is a program from the arithmetic grammar above that will pass all examples\nsolution, flag = synth(problem, iterator)\nprogram = rulenode2expr(solution, g) # should yield 2*6 +1 \n\nprintln(\"Found program is: \", program)\nprintln(\"This program should be equiavalent to the function 2x + 1\")\n\n# here we can evaluate our program on with input x = 6\ninput = 6\noutput = execute_on_input(grammar2symboltable(g), program, Dict(:x => input)) ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"To run either click on the Run button in the top right side of the screen and choose Julia: Execute Active file in REPL or press ALT+Enter This will create a window that will spawn the Julia REPL and evaluate the code.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"This will not work because by default VSCode chooses the Julia environment 1.10 to run the code (Think about python virtualenv). We want to run the code in the environment of HerbSearch. To do that we need to tell VSCode to switch to the right environment.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Open the command palette by typing Ctrl+Shift+P and type change environment (Image: image)","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Now Pick a folder -> HerbSearch","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Try again to run the code and it should work now.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"","category":"page"},{"location":"concepts/#Herb-Architecture-and-Core-Concepts","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"","category":"section"},{"location":"concepts/#Architecture-Introduction","page":"Herb Architecture and Core Concepts","title":"Architecture Introduction","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Herb is a program synthesis framework that gives users a great amount of flexibility. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"At its core, program synthesis is trying to search over a space of programs in the attempt to find a program that satisfies a given specification. The specification is most often done as pairs of input/output examples. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Here is a nice picture showing the synthesis process. (Image: image)","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"As you can see from the picture above, there are a few parts that needed in the synthesis process. Namely:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Grammar\nInterpreter\nIterator\nExamples","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Each part will be discussed in detail how it is implemented in Herb, and small code examples will be provided. After reading through this tutorial you should have a basic general understanding of how Herb works and have an overview of important Herb modules (e.g., HerbSearch, HerbCore, HerbSpecification, HerbBenchmarks, HerbCore, etc.)","category":"page"},{"location":"concepts/#1.-HerbGrammar","page":"Herb Architecture and Core Concepts","title":"1. HerbGrammar","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"First of, let's start with how do we define grammars in Herb. Grammars provide a set of rules that are used when creating programs. One could have an arithmetic expression grammar that allows addition, subtraction, multiplication, etc. Another example could be a grammar that allows bit manipulation operations (e.g., shift left, shift right, etc.), string operations (e.g., concat, replace, findindex, etc.).","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Ideally, it should be possible to define any grammar in Herb.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"One possible approach could be to let users write the grammar definition in a file mygrammar in a grammar format (e.g., BNF). For instance, for arithmetic expressions, a user would create a grammar as shown below. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"<expr> ::= <term> \"+\" <expr>\n        |  <term>\n\n<term> ::= <factor> \"*\" <term>\n        |  <factor>\n\n<factor> ::= \"(\" <expr> \")\"\n          |  <const>\n\n<const> ::= integer","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Of course, just having a static grammar in a file is not too interesting. The user would like to create expressions from that grammar and evaluate them. But wait a minuteâ€¦, how can we know how the users want the program to be evaluated from the grammar? Well, in this case, we can infer that he probably means to evaluate arithmetic expressions in the mathematical sense. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Unfortunately, we cannot do this for any user defined grammar.  In general, grammars only provide the rules to create valid programs, but they do not say how to evaluate those programs. What to do then :shrug: ?","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Well, one option is to let the users define both the grammar and the specification on how to evaluate programs. The users will have a great amount of flexibility with this solution. However, they would have to do that for every new grammar that they define. That will definitely be a tedious task. If you think a bit about it, this is just defining your own programming language. You would have both the syntax of the language and the how to evaluate/interpret the syntax. Can't we do better :question:  ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Well, it turns out that we are already programming in Julia. Can't we use the Julia's parser and interpreter to parse the grammar and evaluate programs? If this were possible, we would definitely cut down the work of users since the parser and interpreter will be already be implemented by someone else (Julia's developers).  This is essentially piggybacking on the work of other people :) Programmers are known to be lazy, thus this solution seems to be a good fit.","category":"page"},{"location":"concepts/#Defining-grammars-in-Herb-intro","page":"Herb Architecture and Core Concepts","title":"Defining grammars in Herb - intro","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Julia supports meta-programming, which allows us to invoke the Julia parser and Julia interpreter for our own needs. In our case, we want to use the Julia's parser to parse the grammar definition and use Julia's interpreter to interpret the programs. The advantage of using this approach is that users can write the grammar definition inside the code. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Let's look at a simple example.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"using HerbGrammar # import @csgrammar\n\ngrammar_arithmetic = @csgrammar begin\n    Number = Constant\n    Constant = 1 | 2 | 3 # constant can be 1 or 2 or 3\n    Number = x\n    Number = Number + Number\n    Number = Number - Number\n    Number = Number * Number\nend","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Here, we define a grammar with 6 rules. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"However, if you type this the code above in the Julia's REPL, you will notice something interesting. The given output has more rules :)","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"1: Number = Constant\n2: Constant = 1\n3: Constant = 2\n4: Constant = 3\n5: Number = x\n6: Number = Number + Number\n7: Number = Number - Number\n8: Number = Number * Number","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"This is because the syntax 1 | 2 | 3 is a syntactic sugar for creating 3 independent rules. Thus, in fact, there are 8 rules created. Each item on the left hand of the grammar side is Symbol and the items on the right-hand side are Julia expressions.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"The grammar data structure uses rule indices to access rules. In Julia, array indices start from 1!","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Run the following examples and check that you can follow what the indices do.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"julia> grammar_arithmetic.rules[1] # gives the RHS(expression) of the 1st rule\n:Constant\njulia> grammar_arithmetic.rules[6] # gives the RHS(expression) of the 6th rule\n:(Number + Number)\njulia> grammar_arithmetic.types[6] # gives the LHS (symbol) of the 6th rule \n:Number ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Of course, I am just scratching the surface here... To see all the fields that the Grammar provides from the REPL you can type ? to enter docs mode and type ContextSensitiveGrammar (there is no context free grammar because a context-sensitive grammar can also be context free)","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"help?> ContextSensitiveGrammar\n... useful docs taken from the comments","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Dealing with rule indices is sometimes a low-level task and that is why there are a lot of helper functions made to make it easier to interact with the grammar. For a more comprehensive overview, check this tutorial on Defining Grammars in Herb.jl.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"As you might have guessed, all the things related to grammars are in the HerbGrammar package.","category":"page"},{"location":"concepts/#2.-HerbCore","page":"Herb Architecture and Core Concepts","title":"2. HerbCore","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Looking at the following code, where we sample random grammar rules, you might wonder what is the RuleNode thing doing?","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"for _ in 1:10\n    rulenode_program = rand(RuleNode, complex_grammar, :StartExpression)\n    # print program tree\n    println(\"Rulenode program: \", rulenode_program)\n    # convert prorgam tree to an expression\n    expression_program = rulenode2expr(rulenode_program, complex_grammar)\n    println(\"Program: \",  expression_program)\n    # WARNING: some programs will loop forever and you may need to stop julia\n    # println(\"Eval program: \", eval(expression)) \nend","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"The short answer to what a RuleNode is that is provides the derivation tree (AST tree) of a program in the grammar. The value at each node of the tree is given by the rule index that corresponds to the grammar.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"This definition might be difficult to visualize, that is why we are going to look at some simple examples of how this work.","category":"page"},{"location":"concepts/#Arithmetic-grammar-example","page":"Herb Architecture and Core Concepts","title":"Arithmetic grammar example","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"We are going to return to our simple grammar_arithmetic that we have already seen before.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"grammar_arithmetic = @csgrammar begin\n    Number =  1 | 2 | 3 # constant can be 1 or 2 or 3\n    Number = x\n    Number = Number + Number\n    Number = Number - Number\n    Number = Number * Number\nend","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"How would we represent the expression 1 + 2 * 3 that is taken from this grammar?  We can visualize this expression as an AST Tree like so:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"flowchart TD\n    id1((+)) --- id2((1))\n    id1 --- id3((*))\n    id3 --- id4((2))\n    id3 --- id5((3))","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"We can relate this tree to the derivation rules that the grammar has as shown below: (Image: image)","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"On the left-hand side, you can see that grammar rules and their corresponding indices. On the right-hand side, you can see the corresponding expression tree where next to each node the rule index is shown.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Thus, a RuleNode is just the derivation tree of a program from the grammar. We can now check the definition of the RuleNode in Herb. Again, using typing ? in the REPL and then RuleNode will show us useful information.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"help?> RuleNode\n  RuleNode <: AbstractRuleNode\n\n  A RuleNode represents a node in an expression tree. Each node corresponds to a certain rule in the AbstractGrammar. A RuleNode consists of:\n\n    â€¢  ind: The index of the rule in the AbstractGrammar which this node is representing.\n\n    â€¢  _val: Field for storing immediately evaluated values  <- you can diregard this field, it is not used that often\n\n    â€¢  children: The children of this node in the expression tree\n// other text","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"The HerbCore.RuleNode is defined in HerbCore. The definition is as follows:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"mutable struct RuleNode <: AbstractRuleNode\n    ind::Int # index in grammar\n    _val::Any  #value of _() evals\n    children::Vector{AbstractRuleNode}\nend","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Ignoring the _val field, this definition should make sense and be inline with what we have seen above.","category":"page"},{"location":"concepts/#Manipulating-RuleNodes-directly","page":"Herb Architecture and Core Concepts","title":"Manipulating RuleNodes directly","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"One can convert a RuleNode to a nice expression using the HerbGrammar.rulenode2expr function. Let's create the RuleNode for the expression 1 + 2 * 3 and print it.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"julia> grammar_arithmetic = @csgrammar begin\n           Number =  1 | 2 | 3 # constant can be 1 or 2 or 3\n           Number = x\n           Number = Number + Number\n           Number = Number - Number\n           Number = Number * Number\n       end\n1: Number = 1\n2: Number = 2\n3: Number = 3\n4: Number = x\n5: Number = Number + Number\n6: Number = Number - Number\n7: Number = Number * Number\njulia> rulenode = RuleNode(5,\n           [   RuleNode(1),\n               RuleNode(7, [RuleNode(2), RuleNode(3)])\n           ])  # create the rulenode with indices as shown in the image above\n5{1,7{2,3}}\njulia> rulenode2expr(rulenode,  grammar_arithmetic) # show the expression corresponding to the rulenode\n:(1 + 2 * 3)  # nice it works","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Since RuleNodes are just trees, one can manipulate them as any other tree-like data structure. One can modify the children or grammar index directly since the struct definition is mutable. However, it is important to keep in mind that RuleNodes are very tightly defined to a grammar. A RuleNode without a grammar does not do much on its own.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Let's try to directly change a RuleNode","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"julia> rulenode.ind = 9 # set the root value to use the rule index 9 (But there is no rule index 9 in the grammar)\n9\njulia> rulenode2expr(rulenode,  grammar_arithmetic) # let's try to print the new rulenode \nERROR: BoundsError: attempt to access 7-element Vector{Any} at index [9] # <- Ups error..\nStacktrace:\n [1] getindex\n   @ ./essentials.jl:13 [inlined]\n [2] rulenode2expr(rulenode::RuleNode, grammar::ContextSensitiveGrammar)\n   @ HerbGrammar ~/.julia/dev/HerbGrammar/src/rulenode_operators.jl:181","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"As you can see, there is a hidden dependency between RuleNodes and grammars. The indices of the RuleNode should correspond to valid grammar indices and the number of children for a rule should correspond to the number of children that rule has in the grammar.","category":"page"},{"location":"concepts/#Useful-RuleNode-functions","page":"Herb Architecture and Core Concepts","title":"Useful RuleNode functions","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Some very useful functions to know:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"HerbCoredepth: gets the depth of the tree of the RuleNode\nBase.length or just `length(rulenode) gets the number of nodes in the RuleNode\nHerbGrammar.rulenode2expr converts a RuleNode to a grammar","category":"page"},{"location":"concepts/#3.-Iterators","page":"Herb Architecture and Core Concepts","title":"3. Iterators","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Almost any programming language supports iterators. Julia supports the iterator pattern but in a bit of a different way because it Julia does have OOP. In Java there is an interface Iterator that each class (e.g., Vector, List, Map, etc.) implements.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"In Julia an iterator is a type that implements two methods:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Base.iterator(iterator::MyIterator)\nBase.iterator(iterator::MyIterator,state::MyIteratorState)","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Each of these functions might return nothing if the iterator is done iterating, or it might return a tuple of the actual value that is being iterated (e.g., a number) and the state of the iterator. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Consider a simple Julia for loop:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"for value in iterator\n   println(value)\nend","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"This is translated to:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"# iterator is any type that can be iterated (list,dict,etc)\nit = iterate(iterator) # same as Base.iterate(itearator)\nwhile it !== nothing   # as long as the iterator is not done\n    value, state = it      # get the value and the state\n    # do something with the value of the iterator\n    println(value) \n    it = iterate(iterator, state)  # runs the iterator with the new state\nend ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"What Julia is doing here is that it passes the iterator state to subsequent Base.iterate calls after each for loop iteration. This pattern turns out to be very powerful because the search algorithms can be implemented using iterators. This is also memory efficient because we do not generate all programs at one but generate them one by one. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Thus, the search algorithms (e.g., BFS, DFS, etc.) just provide an order in which they enumerate the search space. ","category":"page"},{"location":"concepts/#Build-own-search-algorithm","page":"Herb Architecture and Core Concepts","title":"Build own search algorithm","text":"","category":"section"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Let's try to create a new search algorithm in Herb from scratch. We will need three ingredients:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"A new iterator type. Let's call it NiceCustomIterator for now.\nA state that the iterator has for each iteration\nImplement Base.iterate(iter::NiceCustomIterator) and implement Base.iterate(iter::NiceCustomIterator, state)","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"We are going to implement an iterator that is quite funny. It will generate random programs for a given amount of time (e.g., 2 seconds) and then just enumerates programs using the BFS iterator for some other given time (e.g., 3 seconds). After that, it will start generating random programs and the process will repeat. When using BFS the enumeration will resume from the previous saved state of the BFS iterator. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"We will tackle each point one by one.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"But before we start coding, let's create a new folder in HerbSearch and call it ouriterator. Inside that folder, let's create a Julia file nicecustom_iterator.jl where we are going to put our code. ","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"First, we need to think about what to store in the iterator. We need to store a grammar in order to sample random programs, and we also need the two configurable timeouts: one for running the random search and one for running the BFS iterator.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Our definition looks like this, for now.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"struct NiceCustomIterator\n    grammar::AbstractGrammar\n    timer_run_random::Float64\n    timer_run_bfs::Float64\nend","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Secondly, we need to know the state of the iterator. We need to keep track of the both running timers to ensure that we switch from random to BFS and vice versa at the right time. A simple way to do this would be to store the start_time_random of the random iterator and then in the iterate function check if the currenttime is bigger than the `starting time + timerrunrandom. We can do the same for BFS using a fieldstarttimebfs. It would also be helpful to know which timer should we check (random or BFS). For that a booleanisrunning_random` can be used.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"The definition we have so far looks like this:","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"struct NiceCustomIteratorState\n    start_time_random::Float64\n    start_time_bfs::Float64\n    is_running_random::Bool # true if we are currently running random search. false if we run BFS\nend","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"Now we need to implement Base.iterate(iterator). This function does not take the state as a parameter because is only run once. We need to return the new program and also new state.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"To simplify things, we will make our algorithm always start randomly.","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"function Base.iterate(iterator::NiceCustomIterator) \n    random_program = rand(RuleNode, iterator.grammar)\n    return random_program, nothing\nend","category":"page"},{"location":"concepts/","page":"Herb Architecture and Core Concepts","title":"Herb Architecture and Core Concepts","text":"","category":"page"},{"location":"HerbSearch/#HerbSearch_docs","page":"HerbSearch.jl","title":"HerbSearch.jl Documentation","text":"","category":"section"},{"location":"HerbSearch/#HerbSearch.AbstractBFSIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractBFSIterator","text":"AbstractBFSIterator <: TopDownIterator\n\nThis is the supertype for all breadth-first search iterators. It inherits all stop-criteria and traversal mechanisms from TopDownIterator.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.AbstractDFSIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractDFSIterator","text":"AbstractDFSIterator <: TopDownIterator\n\nThis is the supertype for all depth-first search iterators. It inherits all stop-criteria and from TopDownIterator, but the traversal mechanism is  implemented to perform a depth-first search.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.AbstractMHSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractMHSearchIterator","text":"AbstractMHSearchIterator <: StochasticSearchIterator\n\nThis is the supertype for all Metropolis Hastings (MH) search iterators. It inherits all behaviour from StochasticSearchIterator.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.AbstractSASearchIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractSASearchIterator","text":"AbstractSASearchIterator <: StochasticSearchIterator\n\nThis is the supertype for all SA search iterators. \n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.AbstractVLSNSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.AbstractVLSNSearchIterator","text":"AbstractVLSNSearchIterator <: StochasticSearchIterator\n\nThis is the supertype for all VLSN search iterators. \n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.BFSIterator","page":"HerbSearch.jl","title":"HerbSearch.BFSIterator","text":"@programiterator BFSIterator() <: TopDownIterator\n\nCreates a breadth-first search iterator for traversing given a grammar, starting from the given symbol. The iterator returns trees in the grammar in increasing order of size.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.DFSIterator","page":"HerbSearch.jl","title":"HerbSearch.DFSIterator","text":"@programiterator DFSIterator() <: AbstractDFSIterator\n\nCreates a depth-first search iterator for traversing a given a grammar, starting from a given symbol. The iterator returns trees in the grammar in decreasing order of size. \n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.ExpandFailureReason","page":"HerbSearch.jl","title":"HerbSearch.ExpandFailureReason","text":"@enum ExpandFailureReason limit_reached=1 already_complete=2\n\nRepresentation of the different reasons why expanding a partial tree failed.  Currently, there are two possible causes of the expansion failing:\n\nlimit_reached: The depth limit or the size limit of the partial tree would   be violated by the expansion\nalready_complete: There is no hole left in the tree, so nothing can be   expanded.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.GeneticSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.GeneticSearchIterator","text":"GeneticSearchIterator{FitnessFunction,CrossOverFunction,MutationFunction,SelectParentsFunction,EvaluationFunction} <: ProgramIterator\n\nDefines an ProgramIterator using genetic search. \n\nConsists of:\n\nexamples::Vector{<:IOExample}: a collection of examples defining the specification \nevaluation_function::EvaluationFunction: interpreter to evaluate the individual programs\npopulation_size::Int64: number of inviduals in the population\nmutation_probability::Float64: probability of mutation for each individual\nmaximum_initial_population_depth::Int64: maximum depth of trees when population is initialized \n\nend\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.MHSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.MHSearchIterator","text":"MHSearchIterator(examples::AbstractArray{<:IOExample}, cost_function::Function, evaluation_function::Function=HerbInterpret.execute_on_input)\n\nThe MHSearchIterator generates programs using the Metropolis-Hastings algorithm.  The search behaviour has the following characteristics:\n\nIt uses random_fill_propose for the propose function.\nThe accept function isprobabilistic`. \nThe temperature of the algorithm remains constant over time, ensuring a stable acceptance probability.\n\nArguments\n\nexamples::AbstractArray{<:IOExample}: An array of input-output examples used to guide the search.\ncost_function::Function: A function to evaluate the cost of the proposed programs.\nevaluation_function::Function=HerbInterpret.execute_on_input: A function that evaluates the generated program generated and produces an output. Defaults to HerbInterpret.execute_on_input.\n\nReturns\n\nAn iterator to generate programs according to the Metropolis Hastings algorithm.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.MLFSIterator","page":"HerbSearch.jl","title":"HerbSearch.MLFSIterator","text":"@programiterator MLFSIterator() <: TopDownIterator\n\nIterator that enumerates expressions in the grammar in decreasing order of probability (Only use this iterator with probabilistic grammars). Inherits all stop-criteria from TopDownIterator.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.ProgramIterator","page":"HerbSearch.jl","title":"HerbSearch.ProgramIterator","text":"abstract type ProgramIterator\n\nGeneric iterator for all possible search strategies.     All iterators are expected to have the following fields:\n\ngrammar::ContextSensitiveGrammar: the grammar to search over\nsym::Symbol: defines the start symbol from which the search should be started \nmax_depth::Int: maximum depth of program trees\nmax_size::Int: maximum number of AbstractRuleNodes of program trees\nmax_time::Int: maximum time the iterator may take\nmax_enumerations::Int: maximum number of enumerations\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.RandomIterator","page":"HerbSearch.jl","title":"HerbSearch.RandomIterator","text":"@programiterator RandomIterator() <: TopDownIterator\n\nIterates trees in the grammar in a random order.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.SASearchIterator","page":"HerbSearch.jl","title":"HerbSearch.SASearchIterator","text":"SASearchIterator(spec, cost_function, initial_temperature=1, temperature_decreasing_factor = 0.99, evaluation_function::Function=HerbInterpret.execute_on_input)\n\nReturns an enumerator that runs according to the Simulated Annealing Search algorithm.\n\nspec : array of examples\ncost_function : cost function to evaluate the programs proposed\ninitial_temperature : the starting temperature of the algorithm\ntemperature_decreasing_factor : the decreasing factor of the temperature of the time\nevaluation_function : evaluation function that evaluates the program generated and produces an output\n\nThe propose function is random_fill_propose (the same as for Metropolis Hastings). The accept function is probabilistic but takes into account the tempeerature too.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.StochasticSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.StochasticSearchIterator","text":" abstract type StochasticSearchIterator <: ProgramIterator\n\nA unified abstract type for the stochastic search algorithms Metropolis Hastings, Very Large Scale Neighbourhood and Simulated Annealing.  Iterators are customisable by overloading the followign functions:\n\nneighbourhood\npropose\ntemperature\naccept. \n\n\n\nFields\n\nexamples::Vector{IOExample} example used to check the program\ncost_function::Function. Returns the cost of the current program. It receives a list of tuples for (expected, found) and gives back a cost. \ninitial_temperature::Real = 1 \nevaluation_function::Function that evaluates the julia expressions\n\nAn iterator over all possible expressions of a grammar up to maxdepth with start symbol sym. Also inherits all stop criteria like `maxdepthfromProgramIterator`.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.SynthResult","page":"HerbSearch.jl","title":"HerbSearch.SynthResult","text":"@enum SynthResult optimal_program=1 suboptimal_program=2\n\nRepresentation of the possible results of the synth procedure.  At the moment there are two possible outcomes:\n\noptimal_program: The synthesized program satisfies the entire program specification.\nsuboptimal_program: The synthesized program does not satisfy the entire program specification, but got the best score from the evaluator.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.TopDownIterator","page":"HerbSearch.jl","title":"HerbSearch.TopDownIterator","text":"mutable struct TopDownIterator <: ProgramIterator\n\nEnumerates a context-free grammar starting at Symbol sym with respect to the grammar up to a given depth and a given size.  The exploration is done using the given priority function for derivations, and the expand function for discovered nodes. Concrete iterators may overload the following methods:\n\npriority_function\nderivation_heuristic\nhole_heuristic\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.UniformIterator","page":"HerbSearch.jl","title":"HerbSearch.UniformIterator","text":"mutable struct UniformIterator\n\nInner iterator that enumerates all candidate programs of a uniform tree.\n\nsolver: the uniform solver.\nouteriter: outer iterator that is responsible for producing uniform trees. This field is used to dispatch on the derivation_heuristic.\nunvisited_branches: for each search-node from the root to the current search-node, a list of unviisted branches.\nnsolutions: number of solutions found so far.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.UniformIterator-Tuple{UniformSolver, Union{Nothing, ProgramIterator}}","page":"HerbSearch.jl","title":"HerbSearch.UniformIterator","text":"UniformIterator(solver::UniformSolver, outeriter::ProgramIterator)\n\nConstructs a new UniformIterator that traverses solutions of the UniformSolver and is an inner iterator of an outer ProgramIterator.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.VLSNSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.VLSNSearchIterator","text":"VLSNSearchIterator(spec, cost_function, enumeration_depth = 2, evaluation_function::Function=HerbInterpret.execute_on_input) = StochasticSearchIterator(\n\nReturns an iterator that runs according to the Very Large Scale Neighbourhood Search algorithm.\n\nspec : array of examples\ncost_function : cost function to evaluate the proposed programs\nvlsn_neighbourhood_depth : the enumeration depth to search for a best program at a time\nevaluation_function : evaluation function that evaluates the program generated and produces an output\n\nThe propose function consists of all possible programs of the given enumeration_depth. The accept function accepts the program with the lowest cost according to the cost_function. The temperature value of the algorithm remains constant over time.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.@programiterator-Tuple{Any, Any}","page":"HerbSearch.jl","title":"HerbSearch.@programiterator","text":"@programiterator\n\nCanonical way of creating a program iterator. The macro automatically declares the expected fields listed in the ProgramIterator documentation. Syntax accepted by the macro is as follows (anything enclosed in square brackets is optional):     @programiterator [mutable] <IteratorName>(         <argâ‚>,         ...,         <argâ‚™>     ) [<: <SupertypeIterator>] Note that the macro emits an assertion that the SupertypeIterator  is a subtype of ProgramIterator which otherwise throws an ArgumentError. If no supertype is given, the new iterator extends ProgramIterator directly. Each <argáµ¢> may be (almost) any expression valid in a struct declaration, and they must be comma separated. One known exception is that an inner constructor must always be given using the extended function <name>(...) ... end syntax. The mutable keyword determines whether the declared struct is mutable.\n\n\n\n\n\n","category":"macro"},{"location":"HerbSearch/#Base.collect-Tuple{TopDownIterator}","page":"HerbSearch.jl","title":"Base.collect","text":"function Base.collect(iter::TopDownIterator)\n\nReturn an array of all programs in the TopDownIterator. \n\nwarning: Warning\nThis requires deepcopying programs from type StateHole to type RuleNode. If it is not needed to save all programs, iterate over the iterator manually.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{GeneticSearchIterator, HerbSearch.GeneticIteratorState}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::GeneticSearchIterator, current_state::GeneticIteratorState)\n\nIterates the search space using a genetic algorithm. Takes the iterator and the current state to mutate and crossover random inviduals. Returns the best program-so-far and the state of the iterator.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{GeneticSearchIterator}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::GeneticSearchIterator)\n\nIterates the search space using a genetic algorithm. First generates a population sampling random programs. Returns the best program-so-far, and the state of the iterator.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{HerbSearch.StochasticSearchIterator, HerbSearch.IteratorState}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::StochasticSearchIterator, current_state::IteratorState)\n\nThe algorithm that constructs the iterator of StochasticSearchIterator. It has the following structure:\n\nget a random node location -> location,dict = neighbourhood(current_program)\ncall propose on the current program getting a list of full programs\niterate through all the proposals and check if the proposed program is \"better\" than the previous one\n\"accept\" the new program by calling the accept\nreturn the new next_program\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{TopDownIterator, Tuple{Vector{<:AbstractRuleNode}, DataStructures.PriorityQueue}}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue)\n\nDescribes the iteration for a given TopDownIterator and a PriorityQueue over the grammar without enqueueing new items to the priority queue. Recursively returns the result for the priority queue.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{TopDownIterator}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::TopDownIterator)\n\nDescribes the iteration for a given TopDownIterator over the grammar. The iteration constructs a PriorityQueue first and then prunes it propagating the active constraints. Recursively returns the result for the priority queue.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.length-Tuple{ProgramIterator}","page":"HerbSearch.jl","title":"Base.length","text":"Base.length(iter::ProgramIterator)\n\nCounts and returns the number of possible programs without storing all the programs. !!! warning: modifies and exhausts the iterator\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.length-Tuple{UniformIterator}","page":"HerbSearch.jl","title":"Base.length","text":"Base.length(iter::UniformIterator)\n\nCounts and returns the number of programs without storing all the programs. !!! warning: modifies and exhausts the iterator\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.rand","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::AbstractGrammar, max_depth::Int=10)\n\nGenerates a random RuleNode of arbitrary type and maximum depth max_depth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#Base.rand-2","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::AbstractGrammar, typ::Symbol, max_depth::Int=10)\n\nGenerates a random RuleNode of return type typ and maximum depth max_depth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#Base.rand-3","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::AbstractGrammar, typ::Symbol, dmap::AbstractVector{Int}, max_depth::Int=10)\n\nGenerates a random RuleNode, i.e. an expression tree, of root type typ and maximum depth max_depth guided by a depth map dmap if possible.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch._calculate_cost-Tuple{Union{StateHole, RuleNode}, Function, AbstractVector{<:IOExample}, AbstractGrammar, Function}","page":"HerbSearch.jl","title":"HerbSearch._calculate_cost","text":"_calculate_cost(program::RuleNode, cost_function::Function, spec::AbstractVector{IOExample}, grammar::AbstractGrammar, evaluation_function::Function)\n\nReturns the cost of the program using the examples and the cost_function. It first convert the program to an expression and evaluates it on all the examples.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch._find_next_complete_tree-Tuple{Solver, DataStructures.PriorityQueue, TopDownIterator}","page":"HerbSearch.jl","title":"HerbSearch._find_next_complete_tree","text":"_find_next_complete_tree(solver::Solver, pq::PriorityQueue, iter::TopDownIterator)::Union{Tuple{RuleNode, Tuple{Vector{AbstractRuleNode}, PriorityQueue}}, Nothing}\n\nTakes a priority queue and returns the smallest AST from the grammar it can obtain from the queue or by (repeatedly) expanding trees that are in the queue. Returns nothing if there are no trees left within the depth limit.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.accept-Tuple{HerbSearch.StochasticSearchIterator, Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.accept","text":"accept(::StochasticSearchIterator, current_cost::Real, next_cost::Real, temperature::Real)\n\nBased on the current program and possible cost and temperature a program is accepted or not. Usually we would always want to accept better programs but we might get stuck if we do so. That is why some implementations of the accept function accept with a probability  costs that are worse.  cost means how different are the outcomes of the program compared to the correct outcomes. The lower the cost the better the program performs on the examples. The cost is provided by the cost_function\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.best_accept-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.best_accept","text":"best_accept(current_cost::Real, next_cost::Real, temperature::Real)\n\nReturns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns false.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature; not used.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.calculate_cost-Union{Tuple{T}, Tuple{T, Union{StateHole, RuleNode}}} where T<:HerbSearch.StochasticSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.calculate_cost","text":"calculate_cost(iter::T, program::Union{RuleNode, StateHole}) where T <: StochasticSearchIterator\n\nWrapper around _calculate_cost.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.const_temperature-Tuple{Real}","page":"HerbSearch.jl","title":"HerbSearch.const_temperature","text":"const_temperature(current_temperature::Real)\n\nReturns the temperature unchanged. This function is used by Metropolis Hastings and Very Large Neighbourhood Search algorithms.\n\nArguments\n\ncurrent_temperature::Real: the current temperature of the search.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.constructNeighbourhood-Tuple{RuleNode, AbstractGrammar}","page":"HerbSearch.jl","title":"HerbSearch.constructNeighbourhood","text":"constructNeighbourhood(current_program::RuleNode, grammar::AbstractGrammar)\n\nThe neighbourhood node location is chosen at random. The dictionary is nothing.\n\nArguments\n\ncurrent_program::RuleNode: the current program.\ngrammar::AbstractGrammar: the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, AbstractGrammar}","page":"HerbSearch.jl","title":"HerbSearch.constructNeighbourhoodRuleSubset","text":"constructNeighbourhoodRuleSubset(current_program::RuleNode, grammar::AbstractGrammar)\n\nThe neighbourhood node location is chosen at random. The dictionary is contains one entry with key \"rule_subset\" and value of type Vector{Any} being a random subset of grammar rules.\n\nArguments\n\ncurrent_program::RuleNode: the current program.\ngrammar::AbstractGrammar: the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.cross_over-Tuple{GeneticSearchIterator, RuleNode, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.cross_over","text":"cross_over(::GeneticSearchIterator, parent_1::RuleNode, parent_2::RuleNode)\n\nCombines the program from two parent individuals to create one or more offspring individuals.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.crossover_swap_children_1","text":"crossover_swap_children_1(parent_1::RuleNode, parent_2::RuleNode)\n\nPerforms a random crossover of two parents of type RuleNode. The subprograms are swapped and only one altered parent program is returned.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.crossover_swap_children_2","text":"crossover_swap_children_2(parent_1::RuleNode, parent_2::RuleNode)\n\nPerforms a random crossover of two parents of type RuleNode. The subprograms are swapped and both altered parent programs are returned.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.decreasing_temperature-Tuple{Real}","page":"HerbSearch.jl","title":"HerbSearch.decreasing_temperature","text":"decreasing_temperature(percentage::Real)\n\nReturns a function that produces a temperature decreased by percentage%. This function is used by the Simmulated Annealing algorithm.\n\nArguments\n\npercentage::Real: the percentage to decrease the temperature by.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.default_fitness-Tuple{Any, Any}","page":"HerbSearch.jl","title":"HerbSearch.default_fitness","text":"default_fitness(program, results)\n\nDefines the default fitness function taking the program and its results. Results are a vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}. As we are looking for individuals with the highest fitness function, the error is inverted. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.derivation_heuristic-Tuple{MLFSIterator, Vector{Int64}}","page":"HerbSearch.jl","title":"HerbSearch.derivation_heuristic","text":"derivation_heuristic(iter::MLFSIterator, domain::Vector{Int})\n\nDefines derivation_heuristic for the iterator type MLFSIterator.  Sorts the indices within a domain, that is grammar rules, by decreasing log_probabilities. \n\nThis will invert the enumeration order if probabilities are equal.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.derivation_heuristic-Tuple{RandomIterator, Vector{Int64}}","page":"HerbSearch.jl","title":"HerbSearch.derivation_heuristic","text":"function derivation_heuristic(::RandomIterator, indices::Vector{Int})\n\nRandomly shuffles the rules.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.derivation_heuristic-Tuple{TopDownIterator, Vector{Int64}}","page":"HerbSearch.jl","title":"HerbSearch.derivation_heuristic","text":"function derivation_heuristic(::TopDownIterator, indices::Vector{Int})\n\nReturns a sorted sublist of the indices, based on which rules are most promising to fill a hole. The underlying solver can change the order within a Hole's domain. We sort the domain to make the enumeration order explicit and more predictable. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.enumerate_neighbours_propose-Tuple{Int64}","page":"HerbSearch.jl","title":"HerbSearch.enumerate_neighbours_propose","text":"enumerate_neighbours_propose(enumeration_depth::Int64)\n\nThe return function is a function that produces a list with all the subprograms with depth at most enumeration_depth.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.evaluate-Tuple{Problem{<:AbstractVector{<:IOExample}}, Any, Dict{Symbol, Any}}","page":"HerbSearch.jl","title":"HerbSearch.evaluate","text":"evaluate(problem::Problem{Vector{IOExample}}, expr::Any, tab::SymbolTable; allow_evaluation_errors::Bool=false)\n\nEvaluate the expression on the examples.\n\nOptional parameters:\n\n- `shortcircuit` - Whether to stop evaluating after finding single example fails, to speed up the [synth](@ref) procedure. If true, the returned score is an underapproximation of the actual score.\n- `allow_evaluation_errors` - Whether the search should continue if an exception is thrown in the evaluation or throw the error\n\nReturns a score in the interval [0, 1]\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.extract_name_from_argument-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.extract_name_from_argument","text":"extract_name_from_argument(ex)\n\nExtracts the name of a field declaration, otherwise throws an ArgumentError. A field declaration is either a simple field name with possible a type attached to it or a keyword argument.\n\nExample\n\nx::Int     -> x  hello      -> hello  x = 4      -> x  x::Int = 3 -> x\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.fitness-Tuple{GeneticSearchIterator, RuleNode, AbstractVector{<:Tuple{Any, Any}}}","page":"HerbSearch.jl","title":"HerbSearch.fitness","text":"fitness(::GeneticSearchIterator, program, results)\n\nAssigns a numerical value (fitness score) to each individual based on how closely it meets the desired objective.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.generate_branches-Tuple{UniformIterator}","page":"HerbSearch.jl","title":"HerbSearch.generate_branches","text":"Returns a vector of disjoint branches to expand the search tree at its current state. Example:\n\n# pseudo code\nHole(domain=[2, 4, 5], children=[\n    Hole(domain=[1, 6]), \n    Hole(domain=[1, 6])\n])\n\nIf we split on the first hole, this function will create three branches.\n\n(firsthole, 2)\n(firsthole, 4)\n(firsthole, 5)\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.get_best_program-Tuple{Array{RuleNode}, GeneticSearchIterator}","page":"HerbSearch.jl","title":"HerbSearch.get_best_program","text":"get_best_program(population::Array{RuleNode}, iter::GeneticSearchIterator)::RuleNode\n\nReturns the best program within the population with respect to the fitness function.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_leftmost","text":"heuristic_leftmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where the left-most hole always gets considered first. Returns a HoleReference once a hole is found. This is the default option for enumerators.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_random","text":"heuristic_random(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where random holes get chosen randomly using random exploration. Returns a HoleReference once a hole is found.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_rightmost","text":"heuristic_rightmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where the right-most hole always gets considered first. Returns a HoleReference once a hole is found. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_smallest_domain","text":"heuristic_smallest_domain(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over all available holes in the unfinished AST, by considering the size of their respective domains. A domain here describes the number of possible derivations with respect to the constraints. Returns a HoleReference once a hole is found. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.hole_heuristic-Tuple{TopDownIterator, AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.hole_heuristic","text":"hole_heuristic(::TopDownIterator, node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over variable shaped holes. Returns a HoleReference once a hole is found.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.is_field_decl-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.is_field_decl","text":"is_field_decl(ex)\n\nCheck if extractname(ex) returns a name.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.is_kwdef-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.is_kwdef","text":"is_kwdeg(ex)\n\nChecks if a field declaration is a keyword argument or not.  This is called when filtering if the user arguments to the program iteartor are keyword arguments or not.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.mean_squared_error-Tuple{AbstractVector{<:Tuple{Number, Number}}}","page":"HerbSearch.jl","title":"HerbSearch.mean_squared_error","text":"mean_squared_error(results::AbstractVector{Tuple{<:Number,<:Number}})\n\nReturns the mean squared error of results.\n\nArguments\n\nresults<:AbstractVector{<:Tuple{Number,Number}}: the vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.misclassification-Tuple{T} where T<:(AbstractVector{<:Tuple{Number, Number}})","page":"HerbSearch.jl","title":"HerbSearch.misclassification","text":"misclassification(results::AbstractVector{Tuple{<:Number,<:Number}})\n\nReturns the amount of misclassified examples, i.e. how many tuples with non-matching entries are there in results.\n\nArguments\n\nresults<:AbstractVector{<:Tuple{Number,Number}}: the vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.mutate!","page":"HerbSearch.jl","title":"HerbSearch.mutate!","text":"mutate!(::GeneticSearchIterator, program::RuleNode, grammar::AbstractGrammar, max_depth::Int = 2)\n\nMutates the program of an invididual.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.mutate_random!","page":"HerbSearch.jl","title":"HerbSearch.mutate_random!","text":"mutate_random!(program::RuleNode, grammar::AbstractGrammar, max_depth::Int64 = 2)\n\nMutates the given program by inserting a randomly generated sub-program at a random location.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.neighbourhood-Tuple{HerbSearch.StochasticSearchIterator, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.neighbourhood","text":"neighbourhood(iter::StochasticSearchIterator, current_program::RuleNode)\n\nReturns a node location from the neighbourhood of the current program. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.next_solution!-Tuple{UniformIterator}","page":"HerbSearch.jl","title":"HerbSearch.next_solution!","text":"next_solution!(iter::UniformIterator)::Union{RuleNode, StateHole, Nothing}\n\nSearches for the next unvisited solution. Returns nothing if all solutions have been found already.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.priority_function-Tuple{HerbSearch.AbstractDFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}, Bool}","page":"HerbSearch.jl","title":"HerbSearch.priority_function","text":"priority_function(::AbstractDFSIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}}, isrequeued::Bool)\n\nAssigns priority such that the search tree is traversed like in a DFS manner. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.priority_function-Tuple{MLFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}, Bool}","page":"HerbSearch.jl","title":"HerbSearch.priority_function","text":"priority_function(::MLFSIterator, grammar::AbstractGrammar, current_program::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}}, isrequeued::Bool)\n\nCalculates the priority function of the MLFSIterator. The priority value of a tree is then the maxrulenodelog_probability within the represented uniform tree. The value is negated as lower priority values are popped earlier.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.priority_function-Tuple{RandomIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}, Bool}","page":"HerbSearch.jl","title":"HerbSearch.priority_function","text":"priority_function(::RandomIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}}, isrequeued::Bool)\n\nAssigns a random priority to each state.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.priority_function-Tuple{TopDownIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}, Bool}","page":"HerbSearch.jl","title":"HerbSearch.priority_function","text":"priority_function(::TopDownIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}}, isrequeued::Bool)\n\nAssigns a priority value to a tree that needs to be considered later in the search. Trees with the lowest priority value are considered first.\n\n``: The first argument is a dispatch argument and is only used to dispatch to the correct priority function\ng: The grammar used for enumeration\ntree: The tree that is about to be stored in the priority queue\nparent_value: The priority value of the parent SolverState\nisrequeued: The same tree shape will be requeued. The next time this tree shape is considered, the UniformSolver will produce the next complete program deriving from this shape.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept","text":"probabilistic_accept(current_cost::Real, next_cost::Real, temperature::Real)\n\nProbabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program. Returns True if the new program is accepted, False otherwise.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature; not used.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept_with_temperature","text":"probabilistic_accept_with_temperature(current_cost::Real, next_cost::Real, temperature::Real)\n\nReturns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns true with the probability equal to: \n\n1  (1 + exp(delta  temperature))\n\nIn any other case, returns false.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature of the search.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept_with_temperature_fraction","text":"probabilistic_accept_with_temperature_fraction(current_cost::Real, program_to_consider_cost::Real, temperature::Real)\n\nProbabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program multiplied by the temperature. Returns True if the new program is accepted, False otherwise.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the current temperature \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.processkwarg!-Tuple{Vector{Expr}, Union{Expr, Symbol}}","page":"HerbSearch.jl","title":"HerbSearch.processkwarg!","text":"processkwarg!(keywords::Vector{Expr}, ex::Union{Expr, Symbol})\n\nChecks if ex has a default value specified, if so it returns only the field declaration,  and pushes ex to keywords. Otherwise it returns ex\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.propose-Tuple{HerbSearch.StochasticSearchIterator, Vector{Int64}, Union{Nothing, Dict{String, Any}}}","page":"HerbSearch.jl","title":"HerbSearch.propose","text":"propose(iter::StochasticSearchIterator, path::Vector{Int}, dict::Union{Nothing,Dict{String,Any}})\n\nProposes a list of programs to fill in the location provided by path and the dict.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.random_fill_propose","page":"HerbSearch.jl","title":"HerbSearch.random_fill_propose","text":"random_fill_propose(solver::Solver, path::Vector{Int}, dict::Union{Nothing,Dict{String,Any}}, nr_random=5)\n\nReturns a list with only one proposed, completely random, subprogram.\n\nArguments\n\nsolver::solver: solver\npath::Vector{Int}: path to the location to be filled.\ndict::Dict{String, Any}: the dictionary with additional arguments; not used.\nnr_random=1 : the number of random subprograms to be generated.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{<:Real}}","page":"HerbSearch.jl","title":"HerbSearch.select_chromosome","text":"select_chromosome(population::Array{RuleNode}, fitness_array::Array{<:Real})::RuleNode\n\nSelects a chromosome (individual) from the population based on a fitness array. The function uses a fitness-proportionate selection strategy, often referred to as \"roulette wheel\" selection. Assumes fitness_array to be normalized already.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{<:Real}}","page":"HerbSearch.jl","title":"HerbSearch.select_fitness_proportional_parents","text":"select_fitness_proportional_parents(population::Array{RuleNode}, fitness_array::Array{<:Real})::Tuple{RuleNode,RuleNode}\n\nSelects two parent chromosomes (individuals) from a population based on fitness-proportionate selection. The selected parents can be used for genetic crossover in the next steps of the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.select_parents-Tuple{GeneticSearchIterator, Array{RuleNode}, Array{<:Real}}","page":"HerbSearch.jl","title":"HerbSearch.select_parents","text":"select_parents(::GeneticSearchIterator, population::Array{RuleNode}, fitness_array::Array{<:Real})\n\nSelects two parents for the crossover.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.set_stateholes!-Tuple{UniformIterator, Union{StateHole, RuleNode}}","page":"HerbSearch.jl","title":"HerbSearch.set_stateholes!","text":"function set_stateholes!(iter::UniformIterator, node::Union{StateHole, RuleNode})::Vector{StateHole}\n\nDoes a dfs to retrieve all unfilled state holes in the program tree and stores them in the stateholes vector.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.synth-Tuple{Problem, ProgramIterator}","page":"HerbSearch.jl","title":"HerbSearch.synth","text":"synth(problem::Problem, iterator::ProgramIterator; shortcircuit::Bool=true, allow_evaluation_errors::Bool=false, mod::Module=Main)::Union{Tuple{RuleNode, SynthResult}, Nothing}\n\nSynthesize a program that satisfies the maximum number of examples in the problem. \t\t- problem                 - The problem definition with IO examples \t\t- iterator                - The iterator that will be used \t\t- shortcircuit            - Whether to stop evaluating after finding a single example that fails, to speed up the synth procedure. If true, the returned score is an underapproximation of the actual score. \t\t- allowevaluationerrors - Whether the search should crash if an exception is thrown in the evaluation \t\t- maxtime                - Maximum time that the iterator will run  \t\t- maxenumerations        - Maximum number of iterations that the iterator will run  \t\t- mod                     - A module containing definitions for the functions in the grammar that do not exist in Main\n\nReturns a tuple of the rulenode representing the solution program and a synthresult that indicates if that program is optimal. synth uses evaluate which returns a score in the interval [0, 1] and checks whether that score reaches 1. If not it will return the best program so far, with the proper flag\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.temperature-Tuple{HerbSearch.StochasticSearchIterator, Real}","page":"HerbSearch.jl","title":"HerbSearch.temperature","text":"temperature(::StochasticSearchIterator, current_temperature::Real)\n\nReturns the new temperature based on the current temperature. A higher temperature means that the algorithm will explore more.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.validate_iterator-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.validate_iterator","text":"validate_iterator(iter)\n\nValidates the parameters of the iterator\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#StatsBase.sample","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(root::RuleNode, typ::Symbol, grammar::AbstractGrammar, maxdepth::Int=typemax(Int))\n\nUniformly samples a random node from the tree limited to maxdepth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-2","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(::Type{NodeLoc}, root::RuleNode, maxdepth::Int=typemax(Int))\n\nUniformly selects a random node in the tree no deeper than maxdepth using reservoir sampling. Returns a NodeLoc that specifies the location using its parent so that the subtree can be replaced.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-3","page":"HerbSearch.jl","title":"StatsBase.sample","text":"StatsBase.sample(::Type{NodeLoc}, root::RuleNode, typ::Symbol, grammar::AbstractGrammar, maxdepth::Int=typemax(Int))\n\nUniformly selects a random node in the tree of a given type, specified using its parent such that the subtree can be replaced. Returns a NodeLoc.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-4","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(root::RuleNode, typ::Symbol, grammar::AbstractGrammar,\n                      maxdepth::Int=typemax(Int))\n\nUniformly selects a random node of the given return type typ limited by maxdepth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"The HerbSearch package takes care of all operations related to searching for the desired program. This includes","category":"page"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"the functionality to sample a certain program given a grammar,\nthe implementation of several heuristic functions,\nsearching for a program that satisfies the specification, and\nimplementations of several search algorithms in terms of how they enumerate the search space\nBreadth-First Search \nDepth-First Search \nMetropolis Hastings \nVery Large Scale Neighbourhood Search \nSimulated Annealing\nGenetic Search","category":"page"},{"location":"HerbSearch/#Index","page":"HerbSearch.jl","title":"Index","text":"","category":"section"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"","category":"page"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"","category":"page"},{"location":"tutorials/working_with_interpreters/","page":"Working with custom interpreters","title":"Working with custom interpreters","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"88ed49dd3eb86fb25d8795d6eaa71634180cbc1261f2cbb3e24a5f6225711b28\"\n    julia_version = \"1.12.1\"\n-->\n<pre class='language-julia'><code class='language-julia'>begin\n    import Pkg\n    Pkg.activate(Base.current_project())\n    Pkg.instantiate()\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><h1 id=\"Using-the-Julia-interpreter\">Using the Julia interpreter</h1><p>To know how good a candidate program is, program synthesisers execute them. The easiest way to execute a program is to rely on Julia itself. To leverage the Julia interpreter, you only have to ensure that your programs are valid Julia expressions. </p><p>For example, assume the following grammar.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g = @csgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g\">1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><p>Let's construct a program <code>x+3</code>, which would correspond to the following <code>RuleNode</code> representation</p></div>\n\n<pre class='language-julia'><code class='language-julia'>myprog = @rulenode 4{3,1}</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-myprog\">4{3,1}</pre>\n\n\n<div class=\"markdown\"><p>To run this program, we have to convert it into a Julia expression, which we can do in the following way:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>myprog_julia = rulenode2expr(myprog, g)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-myprog_julia\">:(x + 1)</pre>\n\n\n<div class=\"markdown\"><p>Now we have a valid Julia expression, but we are still missing one key ingredient: we have to inform the interpreter about the special symbols. In our case, these are <code>:x</code> and <code>:+</code>. To do so, we need to create a symbol table, which is nothing more than a dictionary mapping symbols to their values:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>symboltable = Dict{Symbol,Any}(:x =&gt; 2, :+ =&gt; +)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-symboltable\">Dict{Symbol, Any} with 2 entries:\n  :+ =&gt; +\n  :x =&gt; 2</pre>\n\n\n<div class=\"markdown\"><p>Now we can execute our program through the default interpreter available in <code>HerbInterpret</code>:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>interpret(symboltable, myprog_julia)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash103373\">3</pre>\n\n\n<div class=\"markdown\"><p>And that's it!</p></div>\n\n\n<div class=\"markdown\"><h1 id=\"Defining-a-custom-interpreter\">Defining a custom interpreter</h1><p>A disadvantage of the default Julia interpreter is that it needs to traverse abstract syntax tree twice â€“ once to convert it into a Julia expression, and the second time to execute that expression. Program execution is regularly the most consuming part of the entire pipeline and, by eliminating one of these steps, we can cut the runtime in half.</p><p>We can define an interpreter that works directly over <code>RuleNode</code>s.  Consider the scenario in which we want to write programs for robot navigation: imagine a 2D world in which the robot can move around and pick up a ball. The programs we could write direct the robot to go up, down, left, and right. For convenience, the programming language also offers conditionals and loops:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>grammar_robots = @csgrammar begin\n    Start = Sequence                   #1\n\n    Sequence = Operation                #2\n    Sequence = (Operation; Sequence)    #3\n    Operation = Transformation          #4\n    Operation = ControlStatement        #5\n\n    Transformation = moveRight() | moveDown() | moveLeft() | moveUp() | drop() | grab()     #6\n    ControlStatement = IF(Condition, Sequence, Sequence)        #12\n    ControlStatement = WHILE(Condition, Sequence)               #13\n\n    Condition = atTop() | atBottom() | atLeft() | atRight() | notAtTop() | notAtBottom() | notAtLeft() | notAtRight()      #14\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grammar_robots\">1: Start = Sequence\n2: Sequence = Operation\n3: Sequence = begin\n    Operation\n    Sequence\nend\n4: Operation = Transformation\n5: Operation = ControlStatement\n6: Transformation = moveRight()\n7: Transformation = moveDown()\n8: Transformation = moveLeft()\n9: Transformation = moveUp()\n10: Transformation = drop()\n11: Transformation = grab()\n12: ControlStatement = IF(Condition, Sequence, Sequence)\n13: ControlStatement = WHILE(Condition, Sequence)\n14: Condition = atTop()\n15: Condition = atBottom()\n16: Condition = atLeft()\n17: Condition = atRight()\n18: Condition = notAtTop()\n19: Condition = notAtBottom()\n20: Condition = notAtLeft()\n21: Condition = notAtRight()\n</pre>\n\n\n<div class=\"markdown\"><p>This grammar specifies a simple sequential program with instructions for the robot. A couple of example programs:</p><ul><li><p><code>moveRight(); moveLeft(); drop()</code></p></li><li><p>WHILE(notAtTop(), moveUp())</p></li></ul><p>The idea behind this programming language is that the program specifies a set of transformations over a state of the robot world. Thus, a program can only be executed over a particular state. In this case, the state represents the size of the 2D world, the current position of a robot, the current position of a ball, and whether the robot is currently holding a ball. The execution of a particular instruction acts as a state transformation: each instruction takes a state as an input, transforms it, and passes it to the subsequent instruction. For example, execution of the program <code>moveRight(); moveLeft(); drop()</code> would proceed as:</p><ol><li><p>take an input state, </p></li><li><p>pass it to the <code>moveRight()</code> instruction,</p></li><li><p>pass the output of <code>moveRight()</code> to <code>moveLeft()</code> instructions,</p></li><li><p>pass the output of <code>moveLeft()</code> to <code>drop()</code>,</p></li><li><p>return the output of <code>drop()</code>.</p></li></ol><p>The following is only one possible way to implement a custom interpreter, but it demonstrates a general template that can always be followed.</p><p>We want to implement the following function, which would take in a program in the form of a <code>RuleNode</code>, a grammar, and a starting state, and return the state obtained after executing the program:</p><pre><code>    interpret(prog::AbstractRuleNode, grammar::ContextSensitiveGrammar, state::RobotState)::RobotState</code></pre><p>As <code>RuleNode</code>s only store indices of derivation rules from the grammar, not the functions themselves, we will first pull the function call associated with every derivation rule. In Julia, this is indicated by the top-level symbol of the rules. For example, the top-level symbol for the derivation rule 6 is <code>:moveRight</code>; for rule 12, that is <code>:IF</code>.</p></div>\n\n\n<div class=\"markdown\"><p>The remaining functions follow a similar idea. (You can see the full implementation of this interpreter <a href=\"https://github.com/Herb-AI/HerbBenchmarks.jl/blob/master/src/data/Robots_2020/robots_primitives.jl\">here</a>).</p></div>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/working_with_interpreters/","page":"Working with custom interpreters","title":"Working with custom interpreters","text":"","category":"page"},{"location":"HerbCore/#HerbCore_docs","page":"HerbCore.jl","title":"HerbCore.jl Documentation","text":"","category":"section"},{"location":"HerbCore/#HerbCore.AbstractConstraint","page":"HerbCore.jl","title":"HerbCore.AbstractConstraint","text":"Represents a constraint for a AbstractGrammar. Concrete implementations can be found in HerbConstraints.jl.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.AbstractGrammar","page":"HerbCore.jl","title":"HerbCore.AbstractGrammar","text":"AbstractGrammar\n\nAbstract type representing all grammars. It is assumed that all grammar structs have at least the following attributes:\n\nrules::Vector{Any}: A list of RHS of rules (subexpressions).\ntypes::Vector{Symbol}: A list of LHS of rules (types, all symbols).\nisterminal::BitVector: A bitvector where bit i represents whether rule i is terminal.\niseval::BitVector: A bitvector where bit i represents whether rule i is an eval rule.\nbytype::Dict{Symbol,Vector{Int}}: A dictionary that maps a type to all rules of said type.\ndomains::Dict{Symbol, BitVector}: A dictionary that maps a type to a domain bitvector.  The domain bitvector has bit i set to true iff the ith rule is of this type.\nchildtypes::Vector{Vector{Symbol}}: A list of types of the children for each rule. \n\nIf a rule is terminal, the corresponding list is empty.\n\nlog_probabilities::Union{Vector{Real}, Nothing}: A list of probabilities for each rule. \n\nIf the grammar is non-probabilistic, the list can be nothing.\n\nFor concrete types, see ContextSensitiveGrammar within the HerbGrammar module.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.AbstractHole","page":"HerbCore.jl","title":"HerbCore.AbstractHole","text":"AbstractHole <: AbstractRuleNode\n\nA AbstractHole is a placeholder where certain rules from the grammar can still be applied. The domain of a AbstractHole defines which rules can be applied. The domain is a bitvector, where the ith bit is set to true if the ith rule in the grammar can be applied.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.AbstractRuleNode","page":"HerbCore.jl","title":"HerbCore.AbstractRuleNode","text":"abstract type AbstractRuleNode end\n\nAbstract type for representing expression trees. An AbstractRuleNode is expected to implement the following functions:\n\nisfilled(::AbstractRuleNode)::Bool. True iff the grammar rule this node holds is not ambiguous, i.e. has domain size 1.\nisuniform(::AbstractRuleNode)::Bool. True iff the children of this node are known.\nget_rule(::AbstractRuleNode)::Int. Returns the index of the grammar rule it represents.\nget_children(::AbstractRuleNode)::Vector{AbstractRuleNode}. Returns the children of this node.\n\nExpression trees consist of RuleNodes and AbstractHoles.\n\nA RuleNode represents a certain production rule in the AbstractGrammar.\nA AbstractHole is a placeholder where certain rules in the grammar still can be applied. \n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.AbstractUniformHole","page":"HerbCore.jl","title":"HerbCore.AbstractUniformHole","text":"Hole <: AbstractHole\n\nAn AbstractUniformHole is a placeholder where certain rules from the grammar can still be applied, but all rules in the domain are required to have the same childtypes.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.Hole","page":"HerbCore.jl","title":"HerbCore.Hole","text":"Hole <: AbstractHole\n\ndomain: A bitvector, where the ith bit is set to true if the ith rule in the grammar can be applied.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.HoleReference","page":"HerbCore.jl","title":"HerbCore.HoleReference","text":"HoleReference\n\nContains a hole and the path to the hole from the root of the tree.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.RuleNode","page":"HerbCore.jl","title":"HerbCore.RuleNode","text":"RuleNode <: AbstractRuleNode\n\nA RuleNode represents a node in an expression tree. Each node corresponds to a certain rule in the AbstractGrammar. A RuleNode consists of:\n\nind: The index of the rule in the AbstractGrammar which this node is representing.\n_val: Field for caching evaluations of RuleNodes, preventing multiple unnecessary evaluations. The field can be used to store any needed infromation.\nchildren: The children of this node in the expression tree\n\ncompat: Compat\nEvaluate immediately functionality is not yet supported by most of Herb.jl.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.RuleNode-Tuple{Int64, Any}","page":"HerbCore.jl","title":"HerbCore.RuleNode","text":"RuleNode(ind::Int, _val::Any)\n\nCreate a RuleNode for the AbstractGrammar rule with index ind,  _val as immediately evaluated value and no children\n\nwarning: Warning\nOnly use this constructor if you are absolutely certain that a rule is terminal and cannot have children. Use [RuleNode(ind::Int, grammar::AbstractGrammar)] for rules that might have children. In general, AbstractHoles should be used as a placeholder when the children of a node are not yet known.   \n\ncompat: Compat\nEvaluate immediately functionality is not yet supported by most of Herb.jl.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.RuleNode-Tuple{Int64, Vector{<:AbstractRuleNode}}","page":"HerbCore.jl","title":"HerbCore.RuleNode","text":"RuleNode(ind::Int, children::Vector{AbstractRuleNode})\n\nCreate a RuleNode for the AbstractGrammar rule with index ind and children as subtrees.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.UniformHole","page":"HerbCore.jl","title":"HerbCore.UniformHole","text":"UniformHole <: AbstractHole\n\ndomain: A bitvector, where the ith bit is set to true if the ith rule in the grammar can be applied. All rules in the domain are required to have the same childtypes.\nchildren: The children of this hole in the expression tree.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.@rulenode-Tuple{Union{Expr, Integer}}","page":"HerbCore.jl","title":"HerbCore.@rulenode","text":"@rulenode\n\nConstruct a RuleNode using the shorthand notation RuleNodes and AbstractHoles are printed with using Base.show.\n\nDoes not yet support AbstractHoles defined outside of HerbCore.\n\nnote: Hole domain representation\nAbstractHoles' domains are printed with a Bool[...] surrounding them. The macro accepts the domain with or without the Bool[...]: UniformHole[Bool[1, 1, 0, 0]]{2,3} and UniformHole[1, 1, 0, 0]{2,3} both work.\n\nExamples\n\njulia> @rulenode 1{4{5,6},1{2,3}}\n1{4{5,6},1{2,3}}\n\njulia> @rulenode 1\n1\n\njulia> @rulenode 1{2, 3}\n1{2,3}\n\njulia> @rulenode UniformHole[1, 1, 0, 0]{2,3}\nUniformHole[Bool[1, 1, 0, 0]]{2,3}\n\njulia> @rulenode Hole[1, 1, 0, 0]\nHole[Bool[1, 1, 0, 0]]\n\n\n\n\n\n\n","category":"macro"},{"location":"HerbCore/#Base.isless-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbCore.jl","title":"Base.isless","text":"Base.isless(rnâ‚::AbstractRuleNode, rnâ‚‚::AbstractRuleNode)::Bool\n\nCompares two RuleNodes. Returns true if the left RuleNode is less than the right RuleNode. Order is determined from the index of the RuleNodes. If both RuleNodes have the same index, a depth-first search is performed in both RuleNodes until nodes with a different index are found.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#Base.length-Tuple{AbstractRuleNode}","page":"HerbCore.jl","title":"Base.length","text":"Base.length(root::RuleNode)\n\nReturn the number of nodes in the tree rooted at root.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.contains_hole-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.contains_hole","text":"contains_hole(rn::RuleNode) = any(contains_hole(c) for c âˆˆ rn.children)\n\nChecks if an AbstractRuleNode tree contains a AbstractHole.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.contains_index-Tuple{AbstractRuleNode, Int64}","page":"HerbCore.jl","title":"HerbCore.contains_index","text":"contains_index(rulenode::RuleNode, index::Int)\n\nReturns true if the rulenode contains the index.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.contains_nonuniform_hole-Tuple{AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.contains_nonuniform_hole","text":"contains_nonuniform_hole(rn::RuleNode)\n\nChecks if an AbstractRuleNode tree contains a Hole.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.depth-Tuple{AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.depth","text":"depth(root::RuleNode)::Int\n\nReturn the depth of the AbstractRuleNode tree rooted at root. Holes do count towards the depth.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_children-Tuple{AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.get_children","text":"get_children(rn::AbstractRuleNode)\n\nReturns the children of the given AbstractRuleNode\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_node_at_location-Tuple{AbstractRuleNode, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.get_node_at_location","text":"get_node_at_location(root::AbstractRuleNode, location::Vector{Int})\n\nRetrieves a RuleNode at the given location by reference.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_node_at_location-Tuple{Hole, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.get_node_at_location","text":"get_node_at_location(root::Hole, location::Vector{Int})\n\nRetrieves the current hole, if location is this very hole. Throws error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_path-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.get_path","text":"get_path(root::AbstractRuleNode, node::AbstractRuleNode)\n\nReturns the path from the root to the targetnode. Returns nothing if no path exists.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_rule-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.get_rule","text":"get_rule(rn::AbstractRuleNode)\n\nReturns the index of the rule that this AbstractRuleNode represents\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_rulesequence-Tuple{RuleNode, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.get_rulesequence","text":"get_rulesequence(node::RuleNode, path::Vector{Int})\n\nExtract the derivation sequence from a path (sequence of child indices) and an AbstractRuleNode. If the path is deeper than the deepest node, it returns what it has.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.hasdynamicvalue-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.hasdynamicvalue","text":"function hasdynamicvalue(rn::AbstractRuleNode)::Bool\n\nReturns true iff the rule has a _val field set up.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.have_same_shape-Tuple{Any, Any}","page":"HerbCore.jl","title":"HerbCore.have_same_shape","text":"have_same_shape(node1::AbstractRuleNode, node2::AbstractRuleNode)\n\nReturns true iff node1 and node2 have the same shape Example: RuleNode(3, [ \tRuleNode(1), \tRuleNode(1) ]) and RuleNode(9, [ \tRuleNode(2), \tHole(domain) ]) have the same shape: 1 root with 2 children.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.is_domain_valid","page":"HerbCore.jl","title":"HerbCore.is_domain_valid","text":"is_domain_valid(x, n_rules::Integer)\nis_domain_valid(x, grammar::AbstractGrammar)\n\nCheck if the domain for the given object x (ex: RuleNode, Hole or AbstractConstraint) is valid given the provided grammar or number of rules.\n\nIf isfilled(x) and x has children, it checks if all children are valid.\n\n\n\n\n\n","category":"function"},{"location":"HerbCore/#HerbCore.isfilled-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.isfilled","text":"isfilled(node::AbstractRuleNode)::Bool\n\nReturns whether the [AbstractRuleNode] holds a single rule. This is always the case for RuleNodes. Holes are considered to be \"filled\" iff their domain size is exactly 1.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.issame-Tuple{Any, Any}","page":"HerbCore.jl","title":"HerbCore.issame","text":"issame(a, b)\n\nReturns whether the two given objects a and b (ex: RuleNode, Hole or AbstractConstraint) are the same.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.isuniform-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.isuniform","text":"isuniform(rn::AbstractRuleNode)\n\nReturns true iff the children of the AbstractRuleNode are known.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.node_depth-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbCore.jl","title":"HerbCore.node_depth","text":"node_depth(root::AbstractRuleNode, node::AbstractRuleNode)::Int\n\nReturn the depth of node for an AbstractRuleNode tree rooted at root. Depth is 1 when root == node.\n\nwarning: Warning\nnode must be a subtree of root in order for this function to work.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.number_of_holes-Tuple{RuleNode}","page":"HerbCore.jl","title":"HerbCore.number_of_holes","text":"number_of_holes(rn::AbstractRuleNode)::Int\n\nRecursively counts the number of holes in an AbstractRuleNode\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.rulesoftype","page":"HerbCore.jl","title":"HerbCore.rulesoftype","text":"rulesoftype(node::RuleNode, ruleset::Set{Int}[, ignoreNode::AbstractRuleNode])\nrulesoftype(node::RuleNode, rule_index::Int[, ignoreNode::AbstractRuleNode])\n\nReturns every rule in the ruleset that is also used in the AbstractRuleNode tree, but not in the ignoreNode subtree.\n\nwarning: Warning\nThe ignoreNode must be a subtree of node for it to have an effect.\n\n\n\n\n\n","category":"function"},{"location":"HerbCore/#HerbCore.rulesoftype-2","page":"HerbCore.jl","title":"HerbCore.rulesoftype","text":"rulesoftype(node::RuleNode, grammar::AbstractGrammar, ruletype::Symbol[, ignoreNode::AbstractRuleNode])\n\nReturns every rule of nonterminal symbol ruletype from the grammar that is also used in the AbstractRuleNode tree, but not in the ignoreNode subtree.\n\nwarning: Warning\nThe ignoreNode must be a subtree of node for it to have an effect.\n\n\n\n\n\n","category":"function"},{"location":"HerbCore/#HerbCore.rulesonleft-Tuple{RuleNode, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.rulesonleft","text":"rulesonleft(expr::RuleNode, path::Vector{Int})::Set{Int}\n\nFinds all rules that are used in the left subtree defined by the path.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}","page":"HerbCore.jl","title":"HerbCore.swap_node","text":"swap_node(expr::AbstractRuleNode, new_expr::AbstractRuleNode, path::Vector{Int})\n\nReplace a node in expr, specified by path, with new_expr. Path is a sequence of child indices, starting from the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}","page":"HerbCore.jl","title":"HerbCore.swap_node","text":"swap_node(expr::RuleNode, node::RuleNode, child_index::Int, new_expr::RuleNode)\n\nReplace child i of a node, a part of larger expr, with new_expr.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.update_rule_indices!","page":"HerbCore.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(...)\n\nUpdates the rule indices of the given rule node, hole or grammar constraint when the grammar changes. \n\n\n\n\n\n","category":"function"},{"location":"HerbCore/#HerbCore.update_rule_indices!-Tuple{AbstractHole, Integer, AbstractDict{<:Integer, <:Integer}}","page":"HerbCore.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(hole::AbstractHole, n_rules::Integer, mapping::AbstractDict{<:Integer, <:Integer})\n\nUpdates the domains of hole and its children according to mapping. For AbstractHoles, this updates both the size of the domain BitVector and the rule indices.  Errors if the length of the domain vector exceeds new n_rules.\n\nArguments\n\nhole: The current AbstractHole being processed\nn_rules: The new number of rules in the grammar\nmapping: A dictionary mapping the old rule indices to new ones\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.update_rule_indices!-Tuple{AbstractHole, Integer}","page":"HerbCore.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(node::AbstractHole, n_rules::Integer)\n\nResize the domains of hole and its children. Errors if the length of the domain vector exceeds new n_rules.\n\nArguments\n\nhole: The current AbstractHole being processed\nn_rules: The new number of rules in the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.update_rule_indices!-Tuple{RuleNode, Integer, AbstractDict{<:Integer, <:Integer}}","page":"HerbCore.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(node::RuleNode, n_rules::Integer, mapping::AbstractDict{<:Integer, <:Integer})\n\nRemap the rule indices of node and its children according to the provided mapping. Errors if the rule index exceeds new n_rules.\n\nArguments\n\nnode: The current RuleNode being processed\nn_rules: The new number of rules in the grammar\nmapping: A dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.update_rule_indices!-Tuple{RuleNode, Integer}","page":"HerbCore.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(node::RuleNode, n_rules::Integer)\n\nUpdates the node as required when grammar size changes. Errors if the rule index exceeds new n_rules.\n\nArguments\n\nnode: The current RuleNode being processed\nn_rules: The new number of rules in the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#Index","page":"HerbCore.jl","title":"Index","text":"","category":"section"},{"location":"HerbCore/","page":"HerbCore.jl","title":"HerbCore.jl","text":"","category":"page"},{"location":"HerbCore/","page":"HerbCore.jl","title":"HerbCore.jl","text":"","category":"page"},{"location":"HerbGrammar/#HerbGrammar_docs","page":"HerbGrammar.jl","title":"HerbGrammar.jl Documentation","text":"","category":"section"},{"location":"HerbGrammar/#HerbGrammar.ContextSensitiveGrammar","page":"HerbGrammar.jl","title":"HerbGrammar.ContextSensitiveGrammar","text":"ContextSensitiveGrammar <: AbstractGrammar\n\nRepresents a context-sensitive grammar. Extends AbstractGrammar with constraints.\n\nConsists of:\n\nrules::Vector{Any}: A list of RHS of rules (subexpressions).\ntypes::Vector{Symbol}: A list of LHS of rules (types, all symbols).\nisterminal::BitVector: A bitvector where bit i represents whether rule i is terminal.\niseval::BitVector: A bitvector where bit i represents whether rule i is an eval rule.\nbytype::Dict{Symbol,Vector{Int}}: A dictionary that maps a type to all rules of said type.\ndomains::Dict{Symbol, BitVector}: A dictionary that maps a type to a domain bitvector.  The domain bitvector has bit i set to true iff the ith rule is of this type.\nchildtypes::Vector{Vector{Symbol}}: A list of types of the children for each rule.  If a rule is terminal, the corresponding list is empty.\nbychildtypes::Vector{BitVector}: A bitvector of rules that share the same childtypes for each rule\nlog_probabilities::Union{Vector{Real}, Nothing}: A list of probabilities for each rule.  If the grammar is non-probabilistic, the list can be nothing.\nconstraints::Vector{AbstractConstraint}: A list of constraints that programs in this grammar have to abide.\n\nUse the @csgrammar macro to create a ContextSensitiveGrammar object. Use the @pcsgrammar macro to create a ContextSensitiveGrammar object with probabilities.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.NodeLoc","page":"HerbGrammar.jl","title":"HerbGrammar.NodeLoc","text":"NodeLoc A helper struct that points to a node in the tree via its parent such that the child can be easily swapped out. If i is 0 the node pointed to is the root node and parent is the node itself.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.SymbolTable","page":"HerbGrammar.jl","title":"HerbGrammar.SymbolTable","text":"SymbolTable\n\nType alias for a Dict that maps terminal symbols in the AbstractGrammar to their Julia interpretation.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.@cfgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@cfgrammar","text":"@cfgrammar\n\nThis macro is deprecated and will be removed in future versions. Use @csgrammar instead.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#HerbGrammar.@csgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@csgrammar","text":"@csgrammar\n\nA macro for defining a ContextSensitiveGrammar.  AbstractConstraints can be added afterwards using the addconstraint! function.\n\nExample usage:\n\ngrammar = @csgrammar begin\n\tR = x\n\tR = 1 | 2\n\tR = R + R\nend\n\nSyntax:\n\nLiterals: Symbols that are already defined in Julia are considered literals, such as 1, 2, or Ï€. For example: R = 1.\nVariables: A variable is a symbol that is not a nonterminal symbol and not already defined in Julia. For example: R = x.\nFunctions: Functions and infix operators that are defined in Julia or the Main module can be used  with the default evaluator. For example: R = R + R, R = f(a, b).\nCombinations: Multiple rules can be defined on a single line in the grammar definition using the | symbol. For example: R = 1 | 2 | 3.\nIterators: Another way to define multiple rules is by providing a Julia iterator after a | symbol. For example: R = |(1:9).\n\nRelated:\n\n@pcsgrammar uses a similar syntax to create probabilistic ContextSensitiveGrammars.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#HerbGrammar.@pcsgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@pcsgrammar","text":"@pcsgrammar\n\nA macro for defining a probabilistic ContextSensitiveGrammar. \n\nExample usage:\n\ngrammar = @pcsgrammar begin\n\t0.5 : R = x\n\t0.3 : R = 1 | 2\n\t0.2 : R = R + R\nend\n\nSyntax:\n\nThe syntax of rules is identical to the syntax used by @csgrammar:\n\nLiterals: Symbols that are already defined in Julia are considered literals, such as 1, 2, or Ï€. For example: R = 1.\nVariables: A variable is a symbol that is not a nonterminal symbol and not already defined in Julia. For example: R = x.\nFunctions: Functions and infix operators that are defined in Julia or the Main module can be used  with the default evaluator. For example: R = R + R, R = f(a, b).\nCombinations: Multiple rules can be defined on a single line in the grammar definition using the | symbol. For example: R = 1 | 2 | 3.\nIterators: Another way to define multiple rules is by providing a Julia iterator after a | symbol. For example: R = |(1:9).\n\nEvery rule is also prefixed with a probability. Rules and probabilities are separated using the : symbol. If multiple rules are defined on a single line, the probability is equally divided between the rules. The sum of probabilities for all rules of a certain non-terminal symbol should be equal to 1.  The probabilities are automatically scaled if this isn't the case.\n\nRelated:\n\n@csgrammar uses a similar syntax to create non-probabilistic ContextSensitiveGrammars.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#Base.get-Tuple{AbstractRuleNode, NodeLoc}","page":"HerbGrammar.jl","title":"Base.get","text":"get(root::AbstractRuleNode, loc::NodeLoc) Obtain the node pointed to by loc.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#Base.insert!-Tuple{RuleNode, NodeLoc, RuleNode}","page":"HerbGrammar.jl","title":"Base.insert!","text":"insert!(loc::NodeLoc, rulenode::RuleNode) Replaces the subtree pointed to by loc with the given rulenode.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.add_rule!-Tuple{AbstractGrammar, AbstractRuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.add_rule!","text":"add_rule(grammar, tree)\n\nExtends a given grammar with an AbstractRuleNode. The type of the rule is inferred from the root-type.\n\nArguments\n\ngrammar::AbstractGrammar: the grammar to extend\ntree::RuleNode: the Herb tree\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.add_rule!-Tuple{AbstractGrammar, Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.add_rule!","text":"add_rule!(g::AbstractGrammar, e::Expr)\n\nAdds a rule to the grammar and updates grammar constraints as required. \n\nUsage:\n\n    add_rule!(grammar, :(\"Real = Real + Real\"))\n\nThe syntax is identical to the syntax of @csgrammar and @cfgrammar, but only single rules are supported.\n\nwarning: Warning\nCalls to this function are ignored if a rule is already in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.add_rule!-Tuple{AbstractGrammar, Real, Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.add_rule!","text":"add_rule!(g::AbstractGrammar, p::Real, e::Expr)\n\nAdds a probabilistic derivation rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.addconstraint!-Tuple{ContextSensitiveGrammar, AbstractConstraint}","page":"HerbGrammar.jl","title":"HerbGrammar.addconstraint!","text":"addconstraint!(grammar::ContextSensitiveGrammar, c::AbstractConstraint)\n\nAdds a AbstractConstraint to a ContextSensitiveGrammar. \n\nwarning: Warning\nErrors if the constraint's domain is invalid.\nCalls to this function are ignored if the constraint already exists in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.child_types-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.child_types","text":"child_types(grammar::AbstractGrammar, rule_index::Int)\n\nReturns the types of the children (nonterminals) of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.child_types-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.child_types","text":"child_types(grammar::AbstractGrammar, node::RuleNode)\n\nReturns the list of child types (nonterminal symbols) in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.cleanup_removed_rules!-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.cleanup_removed_rules!","text":"cleanup_removed_rules!(g::AbstractGrammar)\n\nRemoves any placeholders for previously deleted rules.  This means that indices get shifted.\n\nwarning: Warning\nWhen indices are shifted, this grammar can no longer be used to interpret  AbstractRuleNode trees created before the call to this function. These trees become meaningless. \n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.clearconstraints!-Tuple{ContextSensitiveGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.clearconstraints!","text":"Clear all constraints from the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.containedin-Tuple{Vector, Vector}","page":"HerbGrammar.jl","title":"HerbGrammar.containedin","text":"containedin(vec1::Vector, vec2::Vector)\n\nChecks if elements of vec1 are contained in vec2 in the same order (possibly with elements in between)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.contains_returntype","page":"HerbGrammar.jl","title":"HerbGrammar.contains_returntype","text":"contains_returntype(node::RuleNode, grammar::AbstractGrammar, sym::Symbol, maxdepth::Int=typemax(Int))\n\nReturns true if the tree rooted at node contains at least one node at depth less than maxdepth with the given return type or nonterminal symbol.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.expr2csgrammar-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2csgrammar","text":"expr2csgrammar(ex::Expr)::ContextSensitiveGrammar\n\nA function for converting an Expr to a ContextSensitiveGrammar. If the expression is hardcoded, you should use the @csgrammar macro. Only expressions in the correct format (see @csgrammar) can be converted.\n\nExample usage:\n\ngrammar = expr2csgrammar(\n\tbegin\n\t\tR = x\n\t\tR = 1 | 2\n\t\tR = R + R\n\tend\n)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2pcsgrammar-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2pcsgrammar","text":"expr2pcsgrammar(ex::Expr)::ContextSensitiveGrammar\n\nFunction for converting an Expr to a ContextSensitiveGrammar with probabilities. If the expression is hardcoded, you should use the @pcsgrammar macro. Only expressions in the correct format (see @pcsgrammar) can be converted.\n\nExample usage:\n\ngrammar = expr2pcsgrammar(\n\tbegin\n\t\t0.5 : R = x\n\t\t0.3 : R = 1 | 2\n\t\t0.2 : R = R + R\n\tend\n)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2rulenode-Tuple{Expr, AbstractGrammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2rulenode","text":"expr2rulenode(expr::Expr, grammar::AbstractGrammar, startSymbol::Symbol)\n\nConverts an expression into a AbstractRuleNode corresponding to the rule definitions in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2rulenode-Tuple{Expr, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2rulenode","text":"expr2rulenode(expr::Expr, grammar::AbstractGrammar)\n\nConverts an expression into a AbstractRuleNode corresponding to the rule definitions in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2rulenode-Tuple{Symbol, AbstractGrammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2rulenode","text":"expr2rulenode(expr::Symbol, grammar::AbstractGrammar, startSymbol::Symbol)\n\nConverts an expression into a AbstractRuleNode corresponding to the rule definitions in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2rulenode-Tuple{Union{Number, Symbol}, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2rulenode","text":"expr2rulenode(expr::Symbol, grammar::AbstractGrammar)\n\nConverts an expression into a AbstractRuleNode corresponding to the rule definitions in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_childtypes-Tuple{Any, AbstractVector{Symbol}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_childtypes","text":"get_childtypes(rule::Any, types::AbstractVector{Symbol})\n\nReturns the child types/nonterminals of a production rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_domain-Tuple{AbstractGrammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.get_domain","text":"get_domain(g::AbstractGrammar, type::Symbol)::BitVector\n\nReturns the domain for the hole of a certain type as a BitVector of the same length as the number of  rules in the grammar. Bit i is set to true iff rule i is of type type.\n\ninfo: Info\nSince this function can be intensively used when exploring a program space defined by a grammar, the outcomes of this function are precomputed and stored in the domains field in a AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_domain-Tuple{AbstractGrammar, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_domain","text":"get_domain(g::AbstractGrammar, rules::Vector{Int})::BitVector\n\nTakes a domain rules defined as a vector of ints and converts it to a domain defined as a BitVector.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_rulesequence-Tuple{RuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_rulesequence","text":"get_rulesequence(node::RuleNode, path::Vector{Int})\n\nExtract the derivation sequence from a path (sequence of child indices) and an AbstractRuleNode. If the path is deeper than the deepest node, it returns what it has.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.grammar2symboltable","page":"HerbGrammar.jl","title":"HerbGrammar.grammar2symboltable","text":"grammar2symboltable(grammar::AbstractGrammar, mod::Module=Main)\n\nReturns a SymbolTable populated with a mapping from symbols in the  AbstractGrammar to symbols in module mod or Main, if defined.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.init_probabilities!-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.init_probabilities!","text":"init_probabilities!(grammar::AbstractGrammar)\n\nIf the grammar is not probabilistic yet, initializes the grammar with uniform probabilities per type. If the grammar is already probabilistic, no changed are made.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iscomplete-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.iscomplete","text":"iscomplete(grammar::AbstractGrammar, node::RuleNode)\n\nReturns true if the expression represented by the RuleNode is a complete expression,  meaning that it is fully defined and doesn't have any Holes.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(grammar::AbstractGrammar, index::Int)::Bool\n\nReturns true if the production rule at rule_index contains the special _() eval function.\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(grammar::AbstractGrammar)::Bool\n\nReturns true if any production rules in grammar contain the special _() eval function.\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(rule)\n\nReturns true if the rule is the special evaluate immediately function, i.e., _()\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isprobabilistic-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.isprobabilistic","text":"isprobabilistic(grammar::AbstractGrammar)::Bool\n\nFunction returns whether a AbstractGrammar is probabilistic.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{AbstractGrammar, AbstractRuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(grammar::AbstractGrammar, node::AbstractRuleNode)::Bool\n\nReturns true if the production rule used by node is terminal, i.e., does not contain any nonterminal symbols.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(grammar::AbstractGrammar, rule_index::Int)::Bool\n\nReturns true if the production rule at rule_index is terminal, i.e., does not contain any nonterminal symbols.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{Any, AbstractVector{Symbol}}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(rule::Any, types::AbstractVector{Symbol})\n\nReturns true if the rule is terminal, i.e., it does not contain any of the types in the provided vector. For example, :(x) is terminal, and :(1+1) is terminal, but :(Real + Real) is typically not.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, Int64, Vararg{Module}}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::AbstractGrammar, ind::Int, mod::Module)::Bool\n\nReturn true if the rule with index ind represents a variable.\n\nTaking into account the symbols defined in the given module(s).\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::AbstractGrammar, ind::Int)::Bool\n\nReturn true if the rule with index ind represents a variable.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, RuleNode, Vararg{Module}}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::AbstractGrammar, node::RuleNode, mod::Module)::Bool\n\nReturn true if the rule used by node represents a variable.\n\nTaking into account the symbols defined in the given module(s).\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::AbstractGrammar, node::RuleNode)::Bool\n\nReturn true if the rule used by node represents a variable in a program (essentially, an input to the program)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.log_probability-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.log_probability","text":"log_probability(grammar::AbstractGrammar, index::Int)::Real\n\nReturns the log probability for the rule at index in the grammar.\n\nwarning: Warning\nIf the grammar is not probabilistic, a warning is displayed, and a uniform probability is assumed.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.max_arity-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.max_arity","text":"max_arity(grammar::AbstractGrammar)::Int\n\nReturns the maximum arity (number of children) over all production rules in the AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.max_rulenode_log_probability-Tuple{RuleNode, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.max_rulenode_log_probability","text":"max_rulenode_log_probability(rulenode::AbstractRuleNode, grammar::AbstractGrammar)\n\nCalculates the highest possible probability within an AbstractRuleNode.  That is, for each node and its domain, get the highest probability and multiply it with the probabilities of its children, if present.  As we operate with log probabilities, we sum the logarithms.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.merge_grammars!-Tuple{AbstractGrammar, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.merge_grammars!","text":"merge_grammars!(merge_to::AbstractGrammar, merge_from::AbstractGrammar)\n\nAdds all rules and constraints from merge_from to merge_to. Duplicate rules are ignored.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.mindepth-Tuple{AbstractGrammar, Symbol, AbstractVector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.mindepth","text":"mindepth(grammar::AbstractGrammar, typ::Symbol, dmap::AbstractVector{Int})\n\nReturns the minimum depth achievable for a given nonterminal symbol. The minimum depth is the depth of the lowest tree that can be made using typ  as a start symbol. dmap can be obtained from mindepth_map.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.mindepth_map-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.mindepth_map","text":"mindepth_map(grammar::AbstractGrammar)\n\nReturns the minimum depth achievable for each production rule in the AbstractGrammar. In other words, this function finds the depths of the lowest trees that can be made  using each of the available production rules as a root.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nchildren-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.nchildren","text":"nchildren(grammar::AbstractGrammar, rule_index::Int)::Int\n\nReturns the number of children (nonterminals) of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nchildren-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.nchildren","text":"nchildren(grammar::AbstractGrammar, node::RuleNode)::Int\n\nReturns the number of children in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nonterminals-Tuple{AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.nonterminals","text":"nonterminals(grammar::AbstractGrammar)::Vector{Symbol}\n\nReturns a list of the nonterminals or types in the AbstractGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.normalize!","page":"HerbGrammar.jl","title":"HerbGrammar.normalize!","text":"normalize!(grammar::ContextSensitiveGrammar, type::Union{Symbol, Nothing}=nothing)\n\nA function for normalizing the probabilities of a probabilistic ContextSensitiveGrammar. If the optional type argument is provided, only the rules of that type are normalized.  If the grammar is not probabilistic, i.e. grammar.log_probabilities==nothing, a uniform distribution is initialized.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.parse_probabilistic_rule-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.parse_probabilistic_rule","text":"parse_probabilistic_rule(e::Expr)\n\nParses a single (potentially shorthand) derivation rule of a probabilistic ContextSensitiveGrammar. Returns nothing if the rule is not probabilistic, otherwise a Tuple of its type and a  Vector of probability-rule pairs it expands into.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.probability-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.probability","text":"probability(grammar::AbstractGrammar, index::Int)::Real\n\nReturn the probability for a rule in the grammar. Use log_probability whenever possible.\n\nwarning: Warning\nIf the grammar is not probabilistic, a warning is displayed, and a uniform probability is assumed.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.read_csg","page":"HerbGrammar.jl","title":"HerbGrammar.read_csg","text":"read_csg(grammarpath::AbstractString, constraintspath::OptionalPath=nothing)::ContextSensitiveGrammar\n\nReads a ContextSensitiveGrammar from the files at grammarpath and constraintspath.\n\ndanger: Danger\nOnly open trusted grammars.  Parts of the grammar can be passed to Julia's eval function.  \n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.read_pcsg","page":"HerbGrammar.jl","title":"HerbGrammar.read_pcsg","text":"read_pcsg(grammarpath::AbstractString, constraintspath::OptionalPath=nothing)::ContextSensitiveGrammar\n\nReads a probabilistic ContextSensitiveGrammar from the files at grammarpath and constraintspath.\n\ndanger: Danger\nOnly open trusted grammars.  Parts of the grammar can be passed to Julia's eval function.  \n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.remove_rule!-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.remove_rule!","text":"remove_rule!(g::AbstractGrammar, idx::Int)\n\nRemoves the rule corresponding to idx from the grammar.  In order to avoid shifting indices, the rule is replaced with nothing, and all other data structures are updated accordingly.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.return_type-Tuple{AbstractGrammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.return_type","text":"return_type(grammar::AbstractGrammar, rule_index::Int)::Symbol\n\nReturns the type of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.return_type-Tuple{AbstractGrammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.return_type","text":"return_type(grammar::AbstractGrammar, node::RuleNode)\n\nGives the return type or nonterminal symbol in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.return_type-Tuple{AbstractGrammar, UniformHole}","page":"HerbGrammar.jl","title":"HerbGrammar.return_type","text":"return_type(grammar::AbstractGrammar, hole::UniformHole)\n\nGives the return type or nonterminal symbol in the production rule used by hole.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.root_node_loc-Tuple{RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.root_node_loc","text":"rootnodeloc(root::RuleNode) Returns a NodeLoc pointing to the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulenode2expr-Tuple{AbstractRuleNode, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.rulenode2expr","text":"rulenode2expr(rulenode::AbstractRuleNode, grammar::AbstractGrammar)\n\nConverts an AbstractRuleNode into a Julia expression corresponding to the rule definitions in the grammar. The returned expression can be evaluated with Julia semantics using eval().\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulenode_log_probability-Tuple{RuleNode, AbstractGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.rulenode_log_probability","text":"rulenode_log_probability(node::RuleNode, grammar::AbstractGrammar)\n\nCalculates the log probability associated with a rulenode in a probabilistic grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesonleft-Tuple{RuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesonleft","text":"rulesonleft(node::RuleNode, path::Vector{Int})::Set{Int}\n\nFinds all rules that are used in the left subtree defined by the path.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.store_csg","page":"HerbGrammar.jl","title":"HerbGrammar.store_csg","text":"store_csg(g::ContextSensitiveGrammar, grammarpath::AbstractString, constraintspath::OptionalPath=nothing)\n\nWrites a ContextSensitiveGrammar to the files at grammarpath and constraintspath. The grammarpath file will contain a ContextSensitiveGrammar definition, and the constraintspath file will contain the AbstractConstraints of the ContextSensitiveGrammar.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.subsequenceof-Tuple{Vector{Int64}, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.subsequenceof","text":"subsequenceof(vec1::Vector{Int}, vec2::Vector{Int})\n\nChecks if vec1 is a subsequence of vec2.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.swap_node","text":"swap_node(expr::AbstractRuleNode, new_expr::AbstractRuleNode, path::Vector{Int})\n\nReplace a node in expr, specified by path, with new_expr. Path is a sequence of child indices, starting from the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.swap_node","text":"swap_node(expr::RuleNode, node::RuleNode, child_index::Int, new_expr::RuleNode)\n\nReplace child i of a node, a part of larger expr, with new_expr.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#Index","page":"HerbGrammar.jl","title":"Index","text":"","category":"section"},{"location":"HerbGrammar/","page":"HerbGrammar.jl","title":"HerbGrammar.jl","text":"","category":"page"},{"location":"HerbGrammar/","page":"HerbGrammar.jl","title":"HerbGrammar.jl","text":"","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"We are going to use the MineRL library in Julia. ","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"The installation process will be as follows:","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"Make sure Java 8 SDK is installed on your system, and it is in PATH. This is a requirement from the minerl package (probably because Minecraft runs Java :) )\nRun the provided script in section Install MineRL.","category":"page"},{"location":"other/mincraft_installation/#Install-and-Check-Java-SDK-8","page":"-","title":"Install and Check Java SDK 8","text":"","category":"section"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"If you already have Java SDK 8, you only have to make sure it is in PATH. You can check that by running java -version in cmd/bash/WSL. It should output 1.8.X_XXX as a version.","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"For Linux and WSL(Windows Subsystem for Linux), simply run, sudo apt-get update; sudo apt-get install openjdk-8-jdk to install Java 8.","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"For Windows, or as an alternative option in Linux, download the appropriate version from here: Oracle JDK 8","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"Also, if you have the environment variable JAVA_HOME, make sure it is set to that same version of JDK.","category":"page"},{"location":"other/mincraft_installation/#Using-Windows-natively","page":"-","title":"Using Windows natively","text":"","category":"section"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"One may also set up the environment without WSL. The most important condition for MineRL is that the command bash is found.","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"Given this, one can just set a Windows Bash installation in PATH. The simplest one is to use Git Bash since you most likely have it installed (assuming any user reading this wiki is setting up the environment, and cloning the repo :))","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"To do this, simply add C:\\Program Files\\Git\\bin to PATH. Similarly to Java, you can check if this is set up correctly, by running bash in cmd, and checking if Git Bash is loaded.","category":"page"},{"location":"other/mincraft_installation/#Install-MineRL","page":"-","title":"Install MineRL","text":"","category":"section"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"We now install MineRL and all the necessary utilities for the Python environment. We are using a Conda environment that is ran through Julia with PyCall.","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"You can install MineRL by running the following script:","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"using Pkg\n\nPkg.add(\"Conda\")\nusing Conda\nConda.pip_interop(true)\nConda.pip(\"install\", \"setuptools==65.5.0\")\nConda.pip(\"install\", \"pip==21\")\nConda.pip(\"install\", \"wheel==0.38.0\")\nConda.pip(\"install\", \"git+https://github.com/eErr0Re/minerl@prog-synth\")\nConda.pip(\"install\", \"pyglet==1.5\")\n\nENV[\"PYTHON\"] = Conda.PYTHONDIR * \"/python3\"\nPkg.add(\"PyCall\")\nPkg.build(\"PyCall\")","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"It is important to note that the forked version of MineRL is necessary for running this repository. This is for multiple reasons, the main three being Gradle build configuration, the proper MineRL version (0.4 instead of 1.0.0 from the original repo), and modifying the environment slightly to be better suited for this repo's needs.","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"Rarely, the installation of MineRL can fail, especially if you are setting up the environment through Windows natively. Here are some potential fixes:","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"Enable long paths: Navigate to the Registry Editor on Windows, then by following the path Computer\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem set the registry LongPathsEnabled to 1.\nDowngrade HTTP version if cloning the repository fails: ","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"git config --global http.version HTTP/1.1 Make sure that you revert this change after installation, for security purposes: git config --global --unset http.version","category":"page"},{"location":"other/mincraft_installation/#Testing-the-code","page":"-","title":"Testing the code","text":"","category":"section"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"You can test that it worked correctly by running src/minecraft/getting_started_minerl.jl in the frangel-with-minerl or probe-with-minerl branches.","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"Julia may crash while setting up the environment, with an error about subprocess_call(\"...\\julia.exe\",\"-m\", ...). This is because Julia is spawning a Python process using the sys.executable function to access the Python path. However, when Python is spawned by Julia, sys.executable points to julia.exe instead of python.exe.","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"To fix this, we have to change the code in the processwatcher.py to use the python.exe from the conda environment. Open `C:\\Users\\<yourusername>.julia\\conda\\3\\x8664\\lib\\site-packages\\minerl\\utils\\processwatcher.py, and on line52, replacesys.executablewith\"C:\\Users\\<yourusername>\\.julia\\conda\\3\\x8664\\python.exe\"`","category":"page"},{"location":"other/mincraft_installation/","page":"-","title":"-","text":"","category":"page"},{"location":"HerbSpecification/#HerbSpecification_docs","page":"HerbSpecification.jl","title":"HerbSpecification.jl Documentation","text":"","category":"section"},{"location":"HerbSpecification/#HerbSpecification.AbstractDependentTypeSpecification","page":"HerbSpecification.jl","title":"HerbSpecification.AbstractDependentTypeSpecification","text":"struct AbstractDependentTypeSpecification <: AbstractTypeSpecification\n\nDefines a specification through dependent types. Needs a concrete type checker as oracle.\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.AgdaSpecification","page":"HerbSpecification.jl","title":"HerbSpecification.AgdaSpecification","text":"struct AgdaSpecification <: AbstractDependentTypeSpecification\n\nDefines a specification \n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.IOExample","page":"HerbSpecification.jl","title":"HerbSpecification.IOExample","text":"struct IOExample\n\nAn input-output example. in is a Dict of {Symbol,Any} where the symbol represents a variable in a program. out can be anything.\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.MetricProblem","page":"HerbSpecification.jl","title":"HerbSpecification.MetricProblem","text":"struct MetricProblem{T <: Vector{IOExample}}\n\nProgram synthesis problem defined by an specification and a metric. The specification has to be based on input/output examples, while the function needs to return a numerical value.\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.Problem","page":"HerbSpecification.jl","title":"HerbSpecification.Problem","text":"struct Problem\n\nProgram synthesis problem defined by an AbstractSpecifications. Has a name and a specification of type T.\n\nwarning: Warning\nPlease care that concrete Problem types with different values of T are never subtypes of each other. \n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.SMTSpecification","page":"HerbSpecification.jl","title":"HerbSpecification.SMTSpecification","text":"struct SMTSpecification <: AbstractFormalSpecification\n\nA specification based on a logical formula defined by a SMT solver.\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#HerbSpecification.Trace","page":"HerbSpecification.jl","title":"HerbSpecification.Trace","text":"struct Trace\n\nA trace defining a wanted program execution for program synthesis.  @TODO combine with Gen.jl\n\n\n\n\n\n","category":"type"},{"location":"HerbSpecification/#Base.getindex-Tuple{Problem{<:AbstractVector{<:IOExample}}, Any}","page":"HerbSpecification.jl","title":"Base.getindex","text":"Base.getindex(p::Problem{Vector{IOExample}}, indices)\n\nOverwrite Base.getindex to allow for slicing of input/output-based problems.\n\n\n\n\n\n","category":"method"},{"location":"HerbSpecification/#Index","page":"HerbSpecification.jl","title":"Index","text":"","category":"section"},{"location":"HerbSpecification/","page":"HerbSpecification.jl","title":"HerbSpecification.jl","text":"","category":"page"},{"location":"HerbSpecification/","page":"HerbSpecification.jl","title":"HerbSpecification.jl","text":"","category":"page"},{"location":"HerbConstraints/#HerbConstraints_docs","page":"HerbConstraints.jl","title":"HerbConstraints.jl Documentation","text":"","category":"section"},{"location":"HerbConstraints/#HerbConstraints.AbstractGrammarConstraint","page":"HerbConstraints.jl","title":"HerbConstraints.AbstractGrammarConstraint","text":"abstract type AbstractGrammarConstraint <: AbstractConstraint\n\nAbstract type representing all user-defined constraints. Each grammar constraint has a related AbstractLocalConstraint that is responsible for propagating the constraint at a specific location in the tree. Grammar constraints should implement on_new_node to post a AbstractLocalConstraint at that new node\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.AbstractLocalConstraint","page":"HerbConstraints.jl","title":"HerbConstraints.AbstractLocalConstraint","text":"abstract type AbstractLocalConstraint <: AbstractConstraint\n\nAbstract type representing all local constraints. Each local constraint contains a path that points to a specific location in the tree at which the constraint applies.\n\nEach local constraint should implement a propagate!-function. Inside the propagate! function, the constraint can use the following solver functions:\n\nremove!: Elementary tree manipulation. Removes a value from a domain. (other tree manipulations are: remove_above!, remove_below!, remove_all_but!)\ndeactivate!: Prevent repropagation. Call this as soon as the constraint is satisfied.\nset_infeasible!: Report a non-trivial inconsistency. Call this if the constraint can never be satisfied. An empty domain is considered a trivial inconsistency, such inconsistencies are already handled by tree manipulations.\nisfeasible: Check if the current tree is still feasible. Return from the propagate function, as soon as infeasibility is detected.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.AbstractStateManager","page":"HerbConstraints.jl","title":"HerbConstraints.AbstractStateManager","text":"Manages all changes made to StateInts using StateIntBackups. Support the following functions:\n\nStateInt Creates a new stateful integer\nsave_state! Creates a checkpoint for all stateful integers\nrestore! Restores the values to the latest checkpoint\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Contains","page":"HerbConstraints.jl","title":"HerbConstraints.Contains","text":"Contains <: AbstractGrammarConstraint This [AbstractGrammarConstraint] enforces that a given rule appears in the program tree at least once.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.ContainsSubtree","page":"HerbConstraints.jl","title":"HerbConstraints.ContainsSubtree","text":"ContainsSubtree <: AbstractGrammarConstraint\n\nThis [AbstractGrammarConstraint] enforces that a given subtree appears in the program tree at least once.\n\n!!! warning:     This constraint can only be propagated by the UniformSolver\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.DomainRuleNode","page":"HerbConstraints.jl","title":"HerbConstraints.DomainRuleNode","text":"struct DomainRuleNode <: AbstractRuleNode\n\nMatches any 1 rule in its domain. Example usage:\n\nDomainRuleNode(Bitvector((0, 0, 1, 1)), [RuleNode(1), RuleNode(1)])\n\nThis matches RuleNode(3, [RuleNode(1), RuleNode(1)]) and RuleNode(4, [RuleNode(1), RuleNode(1)]) and UniformHole({3, 4}, [RuleNode(1), RuleNode(1)])\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Forbidden","page":"HerbConstraints.jl","title":"HerbConstraints.Forbidden","text":"Forbidden <: AbstractGrammarConstraint\n\nThis [AbstractGrammarConstraint] forbids any subtree that matches the pattern given by tree to be generated. A pattern is a tree of AbstractRuleNodes. \n\nExample\n\nA node in the tree can be of any type <:AbstractRuleNode. For example, a RuleNode, which contains a rule index corresponding to the  rule index in the AbstractGrammar and the appropriate number of children, or a VarNode, which contains a single identifier symbol.\n\nLet's consider the tree 1(a, 2(b, 3(c, 4)))):\n\nForbidden(RuleNode(3, [RuleNode(5), RuleNode(4)])) forbids c to be filled with 5.\nForbidden(RuleNode(3, [VarNode(:v), RuleNode(4)])) forbids c to be filled, since a [VarNode] can    match any rule, thus making the match attempt successful for the entire domain of c.    Therefore, this tree invalid.\nForbidden(RuleNode(3, [VarNode(:v), VarNode(:v)])) forbids c to be filled with 4, since that would    make both assignments to v equal, which causes a successful match.\n\nA VarNode can match any subtree, but if there are multiple instances of the same variable in the pattern, the matched subtrees must be identical. Any rule in the domain that makes the match attempt successful is removed.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.ForbiddenSequence","page":"HerbConstraints.jl","title":"HerbConstraints.ForbiddenSequence","text":"ForbiddenSequence <: AbstractGrammarConstraint\n\nThis [AbstractGrammarConstraint] forbids the given sequence of rule nodes. Sequences are strictly vertical and may include gaps. Consider the tree 1{a, 2{b, 3{c, d}}}:\n\n[2, 3, d] is a sequence\n[1, 3, d] is a sequence\n[3, c, d] is not a sequence since c and d are siblings (horizontal)\n\nExamples:\n\nForbiddenSequence([3, 4]) enforces that rule 4 cannot be applied at c or d.\nForbiddenSequence([1, 2, 4]) enforces that rule 4 cannot be applied at b, c or d.\nForbiddenSequence([1, 4]) enforces that rule 4 cannot be applied anywhere.\n\nIf any of the rules in ignore_if appears in the sequence, the constraint is ignored. Suppose the forbidden sequence = [1, 2, 3] and ignore_if = [99] Consider the following paths from the root:\n\n[1, 2, 2, 3] is forbidden, as the sequence does not contain 99\n[1, 99, 2, 3] is NOT forbidden, as the sequence does contain 99\n[1, 99, 1, 2, 3] is forbidden, as there is a subsequence that does not contain 99\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.GenericSolver","page":"HerbConstraints.jl","title":"HerbConstraints.GenericSolver","text":"GenericSolver\n\nMaintains a feasible partial program in a SolverState. A ProgramIterator may manipulate the partial tree with the following tree manipulations:\n\nsubstitute!\nremove!\nremove_below!\nremove_above!\nremove_all_but!\n\nEach SolverState holds an independent propagation program. Program iterators can freely move back and forth between states using:\n\nnew_state!\nsave_state!\nload_state!\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.GenericSolver-Tuple{AbstractGrammar, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.GenericSolver","text":"GenericSolver(grammar::AbstractGrammar, init_node::AbstractRuleNode)\n\nConstructs a new solver, with an initial state of the provided AbstractRuleNode.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.GenericSolver-Tuple{AbstractGrammar, Symbol}","page":"HerbConstraints.jl","title":"HerbConstraints.GenericSolver","text":"GenericSolver(grammar::AbstractGrammar, sym::Symbol)\n\nConstructs a new solver, with an initial state using starting symbol sym\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualHardFail","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualHardFail","text":"struct LessThanOrEqualHardFail <: LessThanOrEqualResult end\n\nnode1 > node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualResult","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualResult","text":"abstract type LessThanOrEqualResult end\n\nA result of the less_than_or_equal function. Can be one of 3 cases:\n\nLessThanOrEqualSuccess\nLessThanOrEqualHardFail\nLessThanOrEqualSoftFail\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSoftFail","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSoftFail","text":"struct LessThanOrEqualSoftFail <: LessThanOrEqualResult\n\nnode1 <= node2 and node1 > node2 are both possible depending on the assignment of hole1 and hole2. Includes two cases:\n\nhole2::AbstractHole: A failed AbstractHole-AbstractHole comparison. (e.g. AbstractHole(BitVector((1, 0, 1))) vs AbstractHole(BitVector((0, 1, 1))))\nhole2::Nothing: A failed AbstractHole-RuleNode comparison. (e.g. AbstractHole(BitVector((1, 0, 1))) vs RuleNode(2))\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSuccess","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSuccess","text":"abstract type LessThanOrEqualSuccess <: LessThanOrEqualResult\n\nnode1 <= node2 is guaranteed under all possible assignments of the holes involved. The strictness of a LessThanOrEqualSuccess is specified by 1 of 2 concrete cases:\n\nLessThanOrEqualSuccessLessThan: node1 < node2\nLessThanOrEqualSuccessEquality: node1 == node2\nLessThanOrEqualSuccessWithHoles: node1 <= node2. Unable to specific.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSuccessEquality","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSuccessEquality","text":"struct LessThanOrEqualSuccessEquality <: LessThanOrEqualSuccess end\n\nnode1 == node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSuccessLessThan","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSuccessLessThan","text":"struct LessThanOrEqualSuccessEquality <: LessThanOrEqualSuccess end\n\nnode1 < node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LessThanOrEqualSuccessWithHoles","page":"HerbConstraints.jl","title":"HerbConstraints.LessThanOrEqualSuccessWithHoles","text":"struct LessThanOrEqualSuccessWithHoles <: LessThanOrEqualSuccess end\n\nnode1 <= node2 is guaranteed under all possible assignments of the holes involved. Because of the holes involved, it is not possible to specify '<' or '=='.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalContains","page":"HerbConstraints.jl","title":"HerbConstraints.LocalContains","text":"LocalContains\n\nEnforces that a given rule appears at or below the given path at least once.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalContainsSubtree","page":"HerbConstraints.jl","title":"HerbConstraints.LocalContainsSubtree","text":"LocalContains\n\nEnforces that a given tree appears at or below the given path at least once.\n\n!!! warning:     This is a stateful constraint can only be propagated by the UniformSolver.     The indices and candidates fields should not be set by the user.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalContainsSubtree-Tuple{Vector{Int64}, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.LocalContainsSubtree","text":"LocalContainsSubtree(path::Vector{Int}, tree::AbstractRuleNode)\n\nEnforces that a given tree appears at or below the given path at least once.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.LocalForbidden","page":"HerbConstraints.jl","title":"HerbConstraints.LocalForbidden","text":"LocalForbidden\n\nForbids the a subtree that matches the tree to be generated at the location  provided by the path.  Use a Forbidden constraint for enforcing this throughout the entire search space.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalForbiddenSequence","page":"HerbConstraints.jl","title":"HerbConstraints.LocalForbiddenSequence","text":"LocalForbiddenSequence <: AbstractLocalConstraint\n\nForbids the given sequence of rule nodes ending at the node at the path. If any of the rules in ignore_if appears in the sequence, the constraint is ignored.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalOrdered","page":"HerbConstraints.jl","title":"HerbConstraints.LocalOrdered","text":"Enforces an order over two or more subtrees that fill the variables  specified in order when the pattern is applied at the location given by path. Use an Ordered constraint for enforcing this throughout the entire search space.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalUnique","page":"HerbConstraints.jl","title":"HerbConstraints.LocalUnique","text":"LocalUnique <: AbstractLocalConstraint\n\nEnforces that a given rule appears at or below the given path at most once. In case of the UniformSolver, cache the list of holes, since no new holes can appear.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MakeEqualHardFail","page":"HerbConstraints.jl","title":"HerbConstraints.MakeEqualHardFail","text":"struct MakeEqualHardFail <: MakeEqualResult end\n\nnode1 != node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MakeEqualResult","page":"HerbConstraints.jl","title":"HerbConstraints.MakeEqualResult","text":"abstract type MakeEqualResult end\n\nA result of the make_equal! function. Can be one of 3 cases:\n\nMakeEqualSuccess\nMakeEqualHardFail\nMakeEqualSoftFail\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MakeEqualSoftFail","page":"HerbConstraints.jl","title":"HerbConstraints.MakeEqualSoftFail","text":"struct MakeEqualSoftFail <: MakeEqualResult end\n\nMaking node1 == node2 is ambiguous. Examples:\n\nRuleNode(1, [Hole({1, 2, 3})]) == RuleNode(1, [VarNode(:a)]). The hole can be filled with any rule.\nHole({1, 2, 3}) == DomainRuleNode({1, 2, 3}). The hole can be filled with any rule.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MakeEqualSuccess","page":"HerbConstraints.jl","title":"HerbConstraints.MakeEqualSuccess","text":"struct MakeEqualSuccess <: MakeEqualResult end\n\nnode1 == node2 is guaranteed under all possible assignments of the holes involved.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Ordered","page":"HerbConstraints.jl","title":"HerbConstraints.Ordered","text":"Ordered <: AbstractGrammarConstraint\n\nA AbstractGrammarConstraint that enforces a specific order in MatchVar  assignments in the pattern defined by tree. Nodes in the pattern can either be a RuleNode, which contains a rule index corresponding to the  rule index in the AbstractGrammar and the appropriate number of children. It can also contain a VarNode, which contains a single identifier symbol. A VarNode can match any subtree.  If there are multiple instances of the same variable in the pattern, the matched subtrees must be identical.\n\nThe order defines an order between the variable assignments.  For example, if the order is [x, y], the constraint will require  the assignment to x to be less than or equal to the assignment to y. The order is recursively defined by RuleNode indices.  For more information, see Base.isless(rnâ‚::AbstractRuleNode, rnâ‚‚::AbstractRuleNode).\n\nFor example, consider the tree 1(a, 2(b, 3(c, 4)))):\n\nOrdered(RuleNode(3, [VarNode(:v), VarNode(:w)]), [:v, :w]) removes every rule    with an index of 5 or greater from the domain of c, since that would make the index of the    assignment to v greater than the index of the assignment to w, violating the order.\nOrdered(RuleNode(3, [VarNode(:v), VarNode(:w)]), [:w, :v]) removes every rule    with an index of 4 or less from the domain of c, since that would make the index of the    assignment to v less than the index of the assignment to w, violating the order.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchHardFail","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchHardFail","text":"The pattern is not matched and can never be matched by filling in holes\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchResult","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchResult","text":"abstract type PatternMatchResult end\n\nA result of the pattern_match function. Can be one of 4 cases:\n\nPatternMatchSuccess\nPatternMatchSuccessWhenHoleAssignedTo\nPatternMatchHardFail\nPatternMatchSoftFail\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchSoftFail","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchSoftFail","text":"The pattern can still be matched in a non-trivial way. Includes two cases:\n\nmultiple holes are involved. this result stores a reference to one of them\na single hole is involved, but needs to be filled with a node of size >= 2\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchSuccess","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchSuccess","text":"The pattern is exactly matched and does not involve any holes at all\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PatternMatchSuccessWhenHoleAssignedTo","page":"HerbConstraints.jl","title":"HerbConstraints.PatternMatchSuccessWhenHoleAssignedTo","text":"The pattern can be matched when the hole is filled with any of the given ind(s).\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Solver","page":"HerbConstraints.jl","title":"HerbConstraints.Solver","text":"abstract type Solver\n\nAbstract constraint solver.  Each solver should have at least the following fields:\n\nstatistics::TimerOutput\nfix_point_running::Bool\nschedule::PriorityQueue{AbstractLocalConstraint, Int}\n\nEach solver should implement at least:\n\npost!\nget_tree\nget_grammar\nset_infeasible!\nisfeasible\nHerbCore.get_node_at_location\nget_hole_at_location\nnotify_tree_manipulation\ndeactivate!\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.SolverState","page":"HerbConstraints.jl","title":"HerbConstraints.SolverState","text":"mutable struct SolverState\n\nA state to be solved by the GenericSolver. A state contains of:\n\ntree: A partial AST\nactive_constraints: The local constraints that apply to this tree.   These constraints are enforced each time the tree is modified.\nisfeasible: Flag to indicate if this state is still feasible.  When a propagator spots an inconsistency, this field will be set to false.  Tree manipulations and further propagations are not allowed on infeasible states\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateHole","page":"HerbConstraints.jl","title":"HerbConstraints.StateHole","text":"StateHole <: AbstractUniformHole\n\nStateHoles are uniform holes used by the UniformSolver. Domain manipulations are tracked for backpropagation.\n\ndomain: A StateSparseSet representing the rule nodes this hole can take. If size(domain) == 1, this hole should act like a RuleNode\nchildren: The children of this hole in the expression tree.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateHole-Tuple{HerbConstraints.StateManager, RuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.StateHole","text":"Converts a RuleNode to a StateHole\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateHole-Tuple{HerbConstraints.StateManager, UniformHole}","page":"HerbConstraints.jl","title":"HerbConstraints.StateHole","text":"Converts a UniformHole to a StateHole\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateInt","page":"HerbConstraints.jl","title":"HerbConstraints.StateInt","text":"Stateful integer that can be saved and restored by the StateManager. Supports the following functions:\n\nget_value\nset_value!\nincrement!\ndecrement!\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateIntBackup","page":"HerbConstraints.jl","title":"HerbConstraints.StateIntBackup","text":"Backup entry for the given StateInt\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateManager","page":"HerbConstraints.jl","title":"HerbConstraints.StateManager","text":"Manages all changes made to StateInts using StateIntBackups\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateSparseSet-Tuple{HerbConstraints.StateManager, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.StateSparseSet","text":"Converts a BitVector domain representation to a StateSparseSet Example:\n\nset = StateSparseSet(sm, BitVector((1, 1, 0, 0, 1, 0, 0))) #{1, 2, 5}\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateSparseSet-Tuple{HerbConstraints.StateManager, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.StateSparseSet","text":"Create a new StateSparseSet with values [1, 2, ..., n]\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateStack","page":"HerbConstraints.jl","title":"HerbConstraints.StateStack","text":"Simple stack that can only increase in size. Supports backtracking by decreasing the size to the saved size.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.StateStack-Union{Tuple{HerbConstraints.AbstractStateManager}, Tuple{T}} where T","page":"HerbConstraints.jl","title":"HerbConstraints.StateStack","text":"function StateStack{T}(sm::AbstractStateManager) where T\n\nCreate an empty StateStack supporting elements of type T\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.StateStack-Union{Tuple{T}, Tuple{HerbConstraints.AbstractStateManager, Vector{T}}} where T","page":"HerbConstraints.jl","title":"HerbConstraints.StateStack","text":"function StateStack{T}(sm::AbstractStateManager, vec::Vector{T}) where T\n\nCreate a StateStack for the provided vec\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.UniformSolver","page":"HerbConstraints.jl","title":"HerbConstraints.UniformSolver","text":"A DFS-based solver that uses StateHoles that support backtracking.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.UniformSolver-Tuple{AbstractGrammar, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.UniformSolver","text":"UniformSolver(grammar::AbstractGrammar, fixed_shaped_tree::AbstractRuleNode)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.Unique","page":"HerbConstraints.jl","title":"HerbConstraints.Unique","text":"Unique <: AbstractGrammarConstraint\n\nThis [AbstractGrammarConstraint] enforces that a given rule appears in the program tree at most once.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.VarNode","page":"HerbConstraints.jl","title":"HerbConstraints.VarNode","text":"struct VarNode <: AbstractRuleNode\n\nMatches any subtree and assigns it to a variable name. The LocalForbidden constraint will not match if identical variable symbols match to different trees. Example usage:\n\nRuleNode(3, [VarNode(:x), VarNode(:x)])\n\nThis matches RuleNode(3, [RuleNode(1), RuleNode(1)]), RuleNode(3, [RuleNode(2), RuleNode(2)]), etc. but also larger subtrees such as RuleNode(3, [RuleNode(4, [RuleNode(1)]), RuleNode(4, [RuleNode(1)])])\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.@csgrammar_annotated-Tuple{Any}","page":"HerbConstraints.jl","title":"HerbConstraints.@csgrammar_annotated","text":"@csgrammar_annotated Define an annotated grammar and return it as a ContextSensitiveGrammar. Allows for adding optional annotations per rule. As well as that, allows for adding optional labels per rule, which can be referenced in annotations.  Syntax is backwards-compatible with @csgrammar. Examples:\n\ngâ‚ = @csgrammar_annotated begin\n    Element = 1\n    Element = x\n    Element = Element + Element := commutative\n    Element = Element * Element := (commutative, transitive)\nend\n\ngâ‚ = @csgrammar_annotated begin\n    Element = 1\n    Element = x\n    Element = Element + Element := forbidden_path([3, 1])\n    Element = Element * Element := (commutative, transitive)\nend\n\ngâ‚ = @csgrammar_annotated begin\n    one::            Element = 1\n    variable::       Element = x\n    addition::       Element = Element + Element := (\n                                                       commutative,\n                                                       transitive,\n                                                       forbidden_path([:addition, :one]) || forbidden_path([:one, :variable])\n                                                    )\n    multiplication:: Element = Element * Element := (commutative, transitive)\nend\n\n\n\n\n\n","category":"macro"},{"location":"HerbConstraints/#Base.collect-Tuple{HerbConstraints.StateStack}","page":"HerbConstraints.jl","title":"Base.collect","text":"function Base.collect(stack::StateStack)\n\nReturn the internal Vector representation of the stack. !!! warning:     The returned vector is read-only.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.findall-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.findall","text":"Returns all elements in the set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.findfirst-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.findfirst","text":"Returns the minimum value in the set. This function name is used instead of min to allow code reuse for domains of type BitVector and StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.findlast-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.findlast","text":"Returns the maximum value in the set. This function name is used instead of min to allow code reuse for domains of type BitVector and StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.getindex-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"Base.getindex","text":"Checks if value val is in StateSparseSet s. !!! warning:     This allows a StateSparseSet to be used as if it were a BitVector representation of a set\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.in-Tuple{Int64, HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.in","text":"Checks if value val is in StateSparseSet s.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.in-Union{Tuple{T}, Tuple{HerbConstraints.StateStack{T}, T}} where T","page":"HerbConstraints.jl","title":"Base.in","text":"function Base.in(stack::StateStack, value)::Bool\n\nChecks whether the value is in the stack.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.length-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.length","text":"Returns the number of values in the StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.push!-Tuple{HerbConstraints.StateStack, Any}","page":"HerbConstraints.jl","title":"Base.push!","text":"function Base.push!(stack::StateStack, item)\n\nPlace an item on top of the stack.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.show-Tuple{IO, HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.show","text":"Pretty print the StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.size-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.size","text":"Returns the number of values in the StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.size-Tuple{HerbConstraints.StateStack}","page":"HerbConstraints.jl","title":"Base.size","text":"function Base.size(stack::StateStack)\n\nGet the current size of the stack.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.sum-Tuple{HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"Base.sum","text":"Returns the number of values in the StateSparseSet. !!! warning:     This is not actually the sum of the set. It is the length of the set.     This allows a StateSparseSet to be used as if it were a BitVector representation of a set\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._contains-Tuple{AbstractRuleNode, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._contains","text":"_contains(node::AbstractRuleNode, rule::Int)::Bool\n\nRecursive helper function for the LocalContains constraint Returns one of the following:\n\ntrue, if the node does contains the rule\nfalse, if the node does not contain the rule\nVector{AbstractHole}, if the node contains the rule if one the holes gets filled with the target rule\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._count_occurrences!-Tuple{AbstractRuleNode, Int64, Vector{AbstractHole}}","page":"HerbConstraints.jl","title":"HerbConstraints._count_occurrences!","text":"function _count_occurrences!(node::AbstractRuleNode, rule::Int, holes::Vector{AbstractHole})::Int\n\nRecursive helper function for the LocalUnique constraint. Returns the number of certain occurrences of the rule in the tree. All holes that potentially can hold the target rule are stored in the holes vector.\n\n!!! warning:      Stops counting if the rule occurs more than once.      Counting beyond 2 is not needed for LocalUnique. \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._count_occurrences-Tuple{AbstractRuleNode, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._count_occurrences","text":"function _count_occurrences(rule::Int, node::AbstractRuleNode)::Int\n\nRecursively counts the number of occurrences of the rule in the node.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._count_occurrences-Tuple{Vector{AbstractHole}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._count_occurrences","text":"function _count_occurrences(holes::Vector{AbstractHole}, rule::Int)\n\nCounts the occurences of the rule in the cached list of holes.\n\n!!! warning:      Stops counting if the rule occurs more than once.      Counting beyond 2 is not needed for LocalUnique. \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._exchange_positions!-Tuple{HerbConstraints.StateSparseSet, Int64, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._exchange_positions!","text":"Exchanges the positions in the internal representation of the StateSparseSet.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._update_bounds_val_removed!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._update_bounds_val_removed!","text":"This function should be called whenever the minimum or maximum value from the set might have been removed. The minimum and maximum value of the set will be updated to the actual bounds of the set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._update_max_val_removed!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._update_max_val_removed!","text":"This function should be called whenever the maximum value from the set might have been removed. The maximum value of the set will be updated to the actual maximum of the set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._update_min_val_removed!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints._update_min_val_removed!","text":"This function should be called whenever the minimum value from the set might have been removed. The minimum value of the set will be updated to the actual minimum of the set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.annotation2constraint-Tuple{Any, Int64, Vector{String}}","page":"HerbConstraints.jl","title":"HerbConstraints.annotation2constraint","text":"Converts an annotation to a constraint. commutative: creates an Ordered constraint transitive: creates an (incorrect) Forbidden constraint forbidden_path(path::Vector{Union{Symbol, Int}}): creates a ForbiddenSequence` constraint with the original rule included ... || ...: creates a OneOf constraint (also works with ... || ... || ... et cetera, though not very performant)\n\nwarning: Warning\nThis function is untested and probably broken. Tests are a really good idea. \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.are_disjoint-Tuple{BitVector, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.are_disjoint","text":"are_disjoint(domain1::BitVector, domain2::BitVector)::Bool\n\nReturns true if there is no overlap in values between domain1 and domain2\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.are_disjoint-Tuple{HerbConstraints.StateSparseSet, HerbConstraints.StateSparseSet}","page":"HerbConstraints.jl","title":"HerbConstraints.are_disjoint","text":"are_disjoint(set1::StateSparseSet, set2::StateSparseSet)\n\nReturns true if there is no overlap in values between set1 and set2\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.backup!-Tuple{StateInt}","page":"HerbConstraints.jl","title":"HerbConstraints.backup!","text":"Should be called whenever the state of a StateInt is modified. Creates a StateIntBackup for the given StateInt. Only backup the value if this integer has not been stored during this state before Example usecase:\n\na = StateInt(sm, 10)\nsave_state!(sm)\nset_value!(a, 9) #backup value 10\nset_value!(a, 8) #no need to backup again\nset_value!(a, 3) #no need to backup again\nrestore!(sm) #restores a to value 10\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Contains, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::Contains, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Contains constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{ContainsSubtree, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::ContainsSubtree, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the ContainsSubtree constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Forbidden, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::Forbidden, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Forbidden constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{ForbiddenSequence, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::ForbiddenSequence, tree::AbstractRuleNode; sequence_started=false)::Bool\n\nChecks if the given AbstractRuleNode tree abides the ForbiddenSequence constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Ordered, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::Ordered, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Ordered constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Unique, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"function check_tree(c::Unique, tree::AbstractRuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Unique constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.contains_varnode-Tuple{AbstractRuleNode, Symbol}","page":"HerbConstraints.jl","title":"HerbConstraints.contains_varnode","text":"contains_varnode(rn::AbstractRuleNode, name::Symbol)\n\nChecks if an AbstractRuleNode tree contains a VarNode with the given name.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.deactivate!-Tuple{GenericSolver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.deactivate!","text":"deactivate!(solver::GenericSolver, constraint::AbstractLocalConstraint)\n\nFunction that should be called whenever the constraint is already satisfied and never has to be repropagated.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.deactivate!-Tuple{UniformSolver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.deactivate!","text":"deactivate!(solver::UniformSolver, constraint::AbstractLocalConstraint)\n\nFunction that should be called whenever the constraint is already satisfied and never has to be repropagated.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.decrement!-Tuple{StateInt}","page":"HerbConstraints.jl","title":"HerbConstraints.decrement!","text":"Decrease the value of the integer by 1\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.fix_point!-Tuple{Solver}","page":"HerbConstraints.jl","title":"HerbConstraints.fix_point!","text":"fix_point!(solver::Solver)\n\nPropagate constraints in the current state until no further dedecutions can be made\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.freeze_state-Tuple{StateHole}","page":"HerbConstraints.jl","title":"HerbConstraints.freeze_state","text":"freeze_state(hole::StateHole)::RuleNode\n\nConverts a [StateHole])(@ref) to a [RuleNode]@(ref). The hole and its children are assumed to be filled.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_grammar-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_grammar","text":"function get_grammar(solver::GenericSolver)::AbstractGrammar\n\nGet the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_grammar-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_grammar","text":"function get_grammar(solver::UniformSolver)::AbstractGrammar\n\nGet the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_hole_at_location-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.get_hole_at_location","text":"get_hole_at_location(solver::GenericSolver, location::Vector{Int})::AbstractHole\n\nGet the node at path location and assert it is a AbstractHole.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_hole_at_location-Tuple{UniformSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.get_hole_at_location","text":"get_hole_at_location(solver::UniformSolver, path::Vector{Int})\n\nGet the hole that is located at the provided path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_intersection-Tuple{BitVector, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.get_intersection","text":"get_intersection(domain1::BitVector, domain2::BitVector)::Bool\n\nReturns all the values that are in both domain1 and domain2\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_max_depth-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_max_depth","text":"function get_max_depth(solver::GenericSolver)::SolverState\n\nGet the maximum depth of the tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_max_size-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_max_size","text":"function get_max_depth(solver::GenericSolver)::SolverState\n\nGet the maximum number of AbstractRuleNodes allowed inside the tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_nodes-Tuple{Any}","page":"HerbConstraints.jl","title":"HerbConstraints.get_nodes","text":"get_nodes(solver)\n\nReturn an iterator over all nodes in the tree\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_nodes_on_path-Tuple{AbstractRuleNode, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.get_nodes_on_path","text":"function get_nodes_on_path(root::AbstractRuleNode, path::Vector{Int})::Vector{AbstractRuleNode}\n\nGets a list of nodes on the path, starting (and including) the root.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_priority-Tuple{AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.get_priority","text":"function get_priority(::AbstractLocalConstraint)\n\nUsed to determine which constraint to propagate first in fix_point!. Constraints with fast propagators and/or strong inference should be propagated first.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_starting_symbol-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_starting_symbol","text":"function get_starting_symbol(solver::GenericSolver)::Symbol\n\nGet the symbol from the solver.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_state-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_state","text":"function get_state(solver::GenericSolver)::SolverState\n\nGet the current [SolverState]@(ref) of the solver.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_tree-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_tree","text":"function get_tree(solver::GenericSolver)::AbstractRuleNode\n\nReturns the number of AbstractRuleNodes in the tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_tree-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_tree","text":"function get_tree(solver::UniformSolver)::AbstractRuleNode\n\nGet the root of the tree. This remains the same instance throughout the entire search.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_tree_size-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.get_tree_size","text":"function get_tree_size(solver::GenericSolver)::Int\n\nReturns the number of AbstractRuleNodes in the tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.get_value-Tuple{StateInt}","page":"HerbConstraints.jl","title":"HerbConstraints.get_value","text":"Get the value of the stateful integer\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.increment!-Tuple{StateInt}","page":"HerbConstraints.jl","title":"HerbConstraints.increment!","text":"Increase the value of the integer by 1\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.is_subdomain-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.is_subdomain","text":"is_subdomain(specific_tree::AbstractRuleNode, general_tree::AbstractRuleNode)\n\nChecks if the specific_tree can be obtained by repeatedly removing values from the general_tree\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.is_subdomain-Tuple{BitVector, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.is_subdomain","text":" is_subdomain(subdomain::BitVector, domain::BitVector)\n is_subdomain(subdomain::StateSparseSet, domain::BitVector)\n\nChecks if subdomain is a subdomain of domain. Example: [0, 0, 1, 0] is a subdomain of [0, 1, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.isfeasible-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.isfeasible","text":"isfeasible(solver::GenericSolver)\n\nReturns true if no inconsistency has been detected. Used in several ways:\n\nIterators should check for infeasibility to discard infeasible states\nAfter any tree manipulation with the possibility of an inconsistency (e.g. remove_below!, remove_above!, remove!)\nfix_point! should check for infeasibility to clear its schedule and return\nSome GenericSolver functions assert a feasible state for debugging purposes @assert isfeasible(solver)\nSome GenericSolver functions have a guard that skip the function on an infeasible state: if !isfeasible(solver) return end\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.isfeasible-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.isfeasible","text":"isfeasible(solver::UniformSolver)\n\nReturns true if no inconsistency has been detected.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.load_state!-Tuple{GenericSolver, SolverState}","page":"HerbConstraints.jl","title":"HerbConstraints.load_state!","text":"load_state!(solver::GenericSolver, state::SolverState)\n\nOverwrites the current state with the given state\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_equal!-Tuple{Solver, Union{AbstractHole, RuleNode}, Union{DomainRuleNode, AbstractHole, RuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_equal!","text":"function make_equal!(solver::Solver, node1::AbstractRuleNode, node2::AbstractRuleNode)::MakeEqualResult\n\nTree manipulation that enforces node1 == node2 if unambiguous.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_less_than_or_equal!-Tuple{Solver, Union{AbstractHole, RuleNode}, Union{AbstractHole, RuleNode}, Vector{Tuple{AbstractHole, Int64}}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_less_than_or_equal!","text":"function make_less_than_or_equal!(h1::Union{RuleNode, AbstractHole}, h2::Union{RuleNode, AbstractHole}, guards::Vector{Tuple{AbstractHole, Int}})::LessThanOrEqualResult\n\nHelper function that keeps track of the guards\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_less_than_or_equal!-Tuple{Solver, Union{AbstractHole, RuleNode}, Union{AbstractHole, RuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_less_than_or_equal!","text":"function make_less_than_or_equal!(h1::Union{RuleNode, AbstractHole}, h2::Union{RuleNode, AbstractHole})::LessThanOrEqualResult\n\nEnsures that n1<=n2 by removing impossible values from holes. Returns one of the following results:\n\nLessThanOrEqualSuccess. When [n1<=n2].\nLessThanOrEqualHardFail. When [n1>n2] or when the solver state is infeasible.\nLessThanOrEqualSoftFail. When no further deductions can be made, but [n1<=n2] and [n1>n2] are still possible.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_less_than_or_equal!-Tuple{Solver, Vector{AbstractRuleNode}, Vector{AbstractRuleNode}, Vector{Tuple{AbstractHole, Int64}}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_less_than_or_equal!","text":"function make_less_than_or_equal!(solver::Solver, nodes1::Vector{AbstractRuleNode}, nodes2::Vector{AbstractRuleNode}, guards::Vector{Tuple{AbstractHole, Int}})::LessThanOrEqualResult\n\nHelper function that tiebreaks on children.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.new_state!-Tuple{GenericSolver, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.new_state!","text":"new_state!(solver::GenericSolver, tree::AbstractRuleNode)\n\nOverwrites the current state and propagates constraints on the tree from the ground up\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_new_node-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_new_node","text":"notify_new_node(solver::GenericSolver, event_path::Vector{Int})\n\nNotify all constraints that a new node has appeared at the event_path by calling their respective on_new_node function.\n\nwarning: Warning\nThis does not notify the solver about nodes below the event_path. In that case, call notify_new_nodes instead.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_new_nodes-Tuple{GenericSolver, AbstractRuleNode, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_new_nodes","text":"notify_new_nodes(solver::GenericSolver, node::AbstractRuleNode, path::Vector{Int})\n\nNotify all grammar constraints about the new node and its (grand)children\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_new_nodes-Tuple{UniformSolver, AbstractRuleNode, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_new_nodes","text":"notify_new_nodes(solver::UniformSolver, node::AbstractRuleNode, path::Vector{Int})\n\nNotify all grammar constraints about the new node and its (grand)children\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_tree_manipulation-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_tree_manipulation","text":"notify_tree_manipulation(solver::GenericSolver, event_path::Vector{Int})\n\nNotify subscribed constraints that a tree manipulation has occured at the event_path by scheduling them for propagation\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.notify_tree_manipulation-Tuple{UniformSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.notify_tree_manipulation","text":"notify_tree_manipulation(solver::UniformSolver, event_path::Vector{Int})\n\nNotify subscribed constraints that a tree manipulation has occured at the event_path by scheduling them for propagation\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.partition-Tuple{Hole, ContextSensitiveGrammar}","page":"HerbConstraints.jl","title":"HerbConstraints.partition","text":"partition(hole::Hole, grammar::ContextSensitiveGrammar)::Vector{BitVector}\n\nPartition a Hole into subdomains grouped by childtypes\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{AbstractRuleNode, AbstractRuleNode, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"Generic fallback function for commutativity. Swaps arguments 1 and 2, then dispatches to a more specific signature. If this gets stuck in an infinite loop, the implementation of an AbstractRuleNode type pair is missing.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(rn::AbstractRuleNode, mn::AbstractRuleNode)::PatternMatchResult\n\nRecursively tries to match AbstractRuleNode rn with AbstractRuleNode mn. Returns a PatternMatchResult that describes if the pattern was matched.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{AbstractRuleNode, DomainRuleNode, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(node::AbstractRuleNode, domainrulenode::DomainRuleNode, vars::Dict{Symbol, AbstractRuleNode})::PatternMatchResult\n\nComparing any AbstractRuleNode with a DomainRuleNode\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{AbstractRuleNode, VarNode, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(rn::AbstractRuleNode, var::VarNode, vars::Dict{Symbol, AbstractRuleNode})::PatternMatchResult\n\nComparing any AbstractRuleNode with a named VarNode\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{Union{AbstractHole, RuleNode}, Union{AbstractHole, RuleNode}, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(h1::Union{RuleNode, AbstractHole}, h2::Union{RuleNode, AbstractHole}, vars::Dict{Symbol, AbstractRuleNode})::PatternMatchResult\n\nComparing any pair of Rulenode and/or AbstractHole. It is important to note that some AbstractHoles are already filled and should be treated as RuleNode. This is why this function is dispatched on (isfilled(h1), isfilled(h2)). The '(RuleNode, AbstractHole)' case could still include two nodes of type AbstractHole, but one of them should be treated as a rulenode.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.pattern_match-Tuple{Vector{AbstractRuleNode}, Vector{AbstractRuleNode}, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints.pattern_match","text":"pattern_match(rns::Vector{AbstractRuleNode}, mns::Vector{AbstractRuleNode}, vars::Dict{Symbol, AbstractRuleNode})::PatternMatchResult\n\nPairwise tries to match two ordered lists of AbstractRuleNodes.  Typically, this function is used to pattern match the children two AbstractRuleNodes.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.post!-Tuple{GenericSolver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.post!","text":"post!(solver::GenericSolver, constraint::AbstractLocalConstraint)\n\nImposes the constraint to the current state. By default, the constraint will be scheduled for its initial propagation. Constraints can overload this method to add themselves to notify lists or triggers.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.post!-Tuple{UniformSolver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.post!","text":"post!(solver::UniformSolver, constraint::AbstractLocalConstraint)\n\nPost a new local constraint. Converts the constraint to a state constraint and schedules it for propagation.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{GenericSolver, LocalContainsSubtree}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(::GenericSolver, ::LocalContainsSubtree)\n\n!!! warning:     LocalContainsSubtree uses stateful properties and can therefore not be propagated in the GenericSolver.     (The GenericSolver shares constraints among different states, so they cannot use stateful properties)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalContains}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalContains)\n\nEnforce that the rule appears at or below the path at least once. Uses a helper function to retrieve a list of holes that can potentially hold the target rule. If there is only a single hole that can potentially hold the target rule, that hole will be filled with that rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalForbiddenSequence}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalForbiddenSequence)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalForbidden}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalForbidden)\n\nEnforce that the forbidden tree does not occur at the path. The forbidden tree is matched against the AbstractRuleNode located at the path. Deductions are based on the type of the PatternMatchResult returned by the pattern_match function.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalOrdered}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalOrdered)\n\nEnforce that the VarNodes in the tree are in the specified order. First the node located at the path is matched to see if the ordered constraint applies here. The nodes matching the variables are stored in the vars dictionary. Then the order is enforced within the make_less_than_or_equal! tree manipulation.   \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{Solver, LocalUnique}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::Solver, c::LocalUnique)\n\nEnforce that the rule appears at or below the path at least once. Uses a helper function to retrieve a list of holes that can potentially hold the target rule. If there is only a single hole that can potentially hold the target rule, that hole will be filled with that rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate!-Tuple{UniformSolver, LocalContainsSubtree}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate!","text":"function propagate!(solver::UniformSolver, c::LocalContainsSubtree)\n\nEnforce that the tree appears at or below the path at least once. Nodes that can potentially become the target sub-tree are considered candidates. In case of multiple candidates, a stateful set of indices is used to keep track of active candidates.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{GenericSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(solver::GenericSolver, path::Vector{Int}, rule_index::Int)\n\nRemove rule_index from the domain of the hole located at the path. It is assumed the path points to a hole, otherwise an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{GenericSolver, Vector{Int64}, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(solver::GenericSolver, path::Vector{Int}, rules::Vector{Int})\n\nRemove all rules from the domain of the hole located at the path. It is assumed the path points to a hole, otherwise an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(set::StateSparseSet, val::Int)\n\nRemoves value val from StateSparseSet set. Returns true if val was in set.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{UniformSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(solver::Solver, path::Vector{Int}, rule_index::Int)\n\nRemove rule_index from the domain of the hole located at the path. It is assumed the path points to a hole, otherwise an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove!-Tuple{UniformSolver, Vector{Int64}, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove!","text":"remove!(solver::UniformSolver, path::Vector{Int}, rules::Vector{Int})\n\nRemove all rules from the domain of the hole located at the path. It is assumed the path points to a hole, otherwise an exception will be thrown.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_above!-Tuple{GenericSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_above!","text":"remove_above!(solver::GenericSolver, path::Vector{Int}, rule_index::Int)\n\nReduce the domain of the hole located at the path by removing all rules indices above rule_index Example: rule_index = 2.  hole with domain [1, 1, 0, 1] gets reduced to [1, 0, 0, 0] and gets simplified to a RuleNode\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_above!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_above!","text":"Remove all the values greater than val from the set\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_above!-Tuple{UniformSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_above!","text":"remove_above!(solver::UniformSolver, path::Vector{Int}, rule_index::Int)\n\nReduce the domain of the hole located at the path by removing all rules indices above rule_index Example: rule_index = 2.  hole with domain {1, 2, 4} gets reduced to {1}\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{GenericSolver, Vector{Int64}, BitVector}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(solver::GenericSolver, path::Vector{Int}, new_domain::BitVector)\n\nReduce the domain of the hole located at the path, to the new_domain. It is assumed the path points to a hole, otherwise an exception will be thrown. It is assumed new_domain âŠ† domain. For example: [1, 0, 1, 0] âŠ† [1, 0, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{GenericSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(solver::GenericSolver, path::Vector{Int}, rule_index::Int)\n\nFill in the hole located at the path with rule rule_index. It is assumed the path points to a hole, otherwise an exception will be thrown. It is assumed rule_index âˆˆ hole.domain.\n\n!!! warning: If the hole is known to be in the current tree, the hole can be passed directly.     The caller has to make sure that the hole instance is actually present at the provided path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{GenericSolver, Vector{Int64}, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(solver::GenericSolver, path::Vector{Int}, rules_to_keep::Vector{Int})\n\nRemove all rules from the domain of the hole located at the path except for the rules in rules_to_keep.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(set::StateSparseSet, val::Int)::Bool\n\nRemoves all values from StateSparseSet set, except val\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{HerbConstraints.StateSparseSet, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(set::StateSparseSet, vals::Vector{Int})::Bool\n\nRemoves all values from StateSparseSet set, except those in vals\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_all_but!-Tuple{UniformSolver, Vector{Int64}, Union{Int64, Vector{Int64}}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_all_but!","text":"remove_all_but!(solver::UniformSolver, path::Vector{Int}, rule_index::Int)\n\nFill in the hole located at the path with rule rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_below!-Tuple{GenericSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_below!","text":"remove_below!(solver::GenericSolver, path::Vector{Int}, rule_index::Int)\n\nReduce the domain of the hole located at the path by removing all rules indices below rule_index Example: rule_index = 2.  hole with domain [1, 1, 0, 1] gets reduced to [0, 1, 0, 1]\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_below!-Tuple{HerbConstraints.StateSparseSet, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_below!","text":"Remove all the values less than val from the set\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_below!-Tuple{UniformSolver, Vector{Int64}, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_below!","text":"remove_below!(solver::UniformSolver, path::Vector{Int}, rule_index::Int)\n\nReduce the domain of the hole located at the path by removing all rules indices below rule_index Example: rule_index = 2.  hole with domain {1, 2, 4} gets reduced to {2, 4}\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.remove_node!-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.remove_node!","text":"function remove_node!(solver::GenericSolver, path::Vector{Int})\n\nRemove the node at the given path by substituting it with a hole of the same symbol.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.restore!-Tuple{HerbConstraints.StateIntBackup}","page":"HerbConstraints.jl","title":"HerbConstraints.restore!","text":"Restores the StateInt stored in the StateIntBackup to its original value\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.restore!-Tuple{HerbConstraints.StateManager}","page":"HerbConstraints.jl","title":"HerbConstraints.restore!","text":"Reverts all the backups since the last save_state!.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.restore!-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.restore!","text":"Restore state of the solver until the last save_state!\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.save_state!-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.save_state!","text":"save_state!(solver::GenericSolver)\n\nReturns a copy of the current state that can be restored by calling load_state!(solver, state)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.save_state!-Tuple{HerbConstraints.StateManager}","page":"HerbConstraints.jl","title":"HerbConstraints.save_state!","text":"Make a backup of the current state. Return to this state by calling restore!.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.save_state!-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.save_state!","text":"Save the current state of the solver, can restored using restore!\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.schedule!-Tuple{Solver, AbstractLocalConstraint}","page":"HerbConstraints.jl","title":"HerbConstraints.schedule!","text":"schedule(solver::GenericSolver, constraint::AbstractLocalConstraint)\n\nSchedules the constraint for propagation.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.set_infeasible!-Tuple{GenericSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.set_infeasible!","text":"set_infeasible!(solver::GenericSolver)\n\nFunction to be called if any inconsistency has been detected\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.set_infeasible!-Tuple{UniformSolver}","page":"HerbConstraints.jl","title":"HerbConstraints.set_infeasible!","text":"set_infeasible!(solver::Solver)\n\nFunction to be called if any inconsistency has been detected\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.set_value!-Tuple{StateInt, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.set_value!","text":"Set the value of the integer to the given val\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.shouldschedule-Tuple{Solver, AbstractLocalConstraint, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.shouldschedule","text":"shouldschedule(solver::Solver, constraint::AbstractLocalConstraint, path::Vector{Int})::Bool\n\nFunction that is called when a tree manipulation occured at the path. Returns true if the constraint should be scheduled for propagation.\n\nDefault behavior: return true iff the manipulation happened at or below the constraint path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.shouldschedule-Tuple{Solver, LocalForbiddenSequence, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.shouldschedule","text":"shouldschedule(::Solver, constraint::LocalForbiddenSequence, path::Vector{Int})::Bool\n\nReturn true iff the manipulation happened at or above the constraint path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.simplify_hole!-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.simplify_hole!","text":"simplify_hole!(solver::GenericSolver, path::Vector{Int})\n\nTakes a Hole and tries to simplify it to a UniformHole or RuleNode. If the domain of the hole is empty, the state will be marked as infeasible\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.substitute!-Tuple{GenericSolver, Vector{Int64}, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.substitute!","text":"substitute!(solver::GenericSolver, path::Vector{Int}, new_node::AbstractRuleNode; is_domain_increasing::Union{Nothing, Bool}=nothing)\n\nSubstitute the node at the path, with a new_node.\n\nis_domain_increasing: indicates if all grammar constraints should be repropagated from the ground up.\n\nDomain increasing substitutions are substitutions that cannot be achieved by repeatedly removing values from domains. Example of an domain increasing event: hole[{3, 4, 5}] -> hole[{1, 2}]. Example of an domain decreasing event: hole[{3, 4, 5}] -> rulenode(4, [hole[{1, 2}], rulenode(1)]).\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.contains_hole-Tuple{StateHole}","page":"HerbConstraints.jl","title":"HerbCore.contains_hole","text":"contains_hole(hole::StateHole)::Bool\n\nReturns true if the hole or any of its (grand)children are not filled.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_node_at_location-Tuple{GenericSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbCore.get_node_at_location","text":"HerbCore.get_node_at_location(solver::GenericSolver, location::Vector{Int})::AbstractRuleNode\n\nGet the node at path location.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_node_at_location-Tuple{UniformSolver, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbCore.get_node_at_location","text":"get_node_at_location(solver::UniformSolver, path::Vector{Int})\n\nGet the node that is located at the provided path.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_path-Tuple{GenericSolver, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbCore.get_path","text":"get_path(solver::GenericSolver, node::AbstractRuleNode)\n\nGet the path at which the node is located.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_path-Tuple{UniformSolver, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbCore.get_path","text":"get_path(solver::UniformSolver, node::AbstractRuleNode)\n\nGet the path at which the node is located.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.get_rule-Tuple{StateHole}","page":"HerbConstraints.jl","title":"HerbCore.get_rule","text":"get_rule(hole::StateHole)::Int\n\nAssuming the hole has domain size 1, get the rule it is currently assigned to.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.isfilled-Tuple{StateHole}","page":"HerbConstraints.jl","title":"HerbCore.isfilled","text":"isfilled(hole::StateHole)::Bool\n\nHoles with domain size 1 are fixed to a rule. Returns whether the hole has domain size 1. (holes with an empty domain are not considered to be fixed)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Contains, AbstractGrammar, AbstractDict{<:Integer, <:Integer}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Contains, grammar::AbstractGrammar, mapping::AbstractDict{<:Integer,<:Integer})\n\nUpdates the Contains constraint to reflect grammar changes by replacing it with a new  Contains constraint using the mapped rule index.\n\nArguments\n\nc: The Contains constraint to be updated\ngrammar: The grammar that changed  \nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Contains, AbstractGrammar}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Contains, grammar::AbstractGrammar)\n\nUpdates the Contains constraint as required when grammar size changes. Errors if the rule index exceeds number of grammar rules.\n\nArguments\n\nc: The Contains constraint to be updated\ngrammar: The grammar that changed\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Contains, Integer, AbstractDict{<:Integer, <:Integer}, Vector{<:AbstractConstraint}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Contains, n_rules::Integer, mapping::AbstractDict{<:Integer,<:Integer}, constraints::Vector{<:AbstractConstraint})\n\nUpdates the Contains constraint to reflect grammar changes by replacing it with a new  Contains constraint using the mapped rule index.\n\nArguments\n\nc: The Contains constraint to be updated\nn_rules: The new number of rules in the grammar  \nmapping: Dictionary mapping old rule indices to new rule indices\nconstraints: Vector of grammar constraints containing the constraint to update\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Contains, Integer}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Contains, n_rules::Integer)\n\nUpdates a Contains constraint to reflect grammar changes. Errors if rule index exceeds new n_rules.\n\nArguments\n\nc: The Contains constraint to be updated\nn_rules: The new number of rules in the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{ContainsSubtree, AbstractGrammar, AbstractDict{<:Integer, <:Integer}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::ContainsSubtree, grammar::AbstractGrammar, mapping::AbstractDict{<:Integer, <:Integer})\n\nUpdates the ContainsSubtree constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The ContainsSubtree to be updated\ngrammar: The grammar that changed\nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{ContainsSubtree, AbstractGrammar}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::ContainsSubtree, grammar::AbstractGrammar)\n\nUpdates the ContainsSubtree constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The ContainsSubtree constraint to be updated\ngrammar: The grammar that changed\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{ContainsSubtree, Integer, AbstractDict{<:Integer, <:Integer}, Vector{<:AbstractConstraint}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::ContainsSubtree, n_rules::Integer, mapping::AbstractDict{<:Integer, <:Integer}, ::Vector{<:AbstractConstraint})\n\nUpdates the ContainsSubtree constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The ContainsSubtree to be updated\nn_rules: The new number of rules in the grammar\nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{ContainsSubtree, Integer}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::ContainsSubtree, n_rules::Integer)\n\nUpdates the ContainsSubtree constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The ContainsSubtree constraint to be updated\nn_rules: The new number of rules in the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{DomainRuleNode, Integer, AbstractDict{<:Integer, <:Integer}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(node::DomainRuleNode, n_rules::Integer, mapping::AbstractDict{<:Integer, <:Integer})\n\nUpdates the DomainRuleNode by resizing the domain vector to n_rules and remapping rule indices based mapping.  Errors if the length of the domain vector exceeds new n_rules.\n\nArguments\n\nnode: The current DomainRuleNode being processed\nn_rules: The new number of rules in the grammar\nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{DomainRuleNode, Integer}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(node::DomainRuleNode, n_rules::Integer)\n\nUpdates the DomainRuleNode by resizing the domain vector to n_rules.  Errors if the length of the domain vector exceeds new n_rules.\n\nArguments\n\nnode: The current DomainRuleNode being processed\nn_rules: The new number of rules in the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Forbidden, AbstractGrammar, AbstractDict{<:Integer, <:Integer}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Forbidden, grammar::AbstractGrammar, mapping::AbstractDict{<:Integer, <:Integer})\n\nUpdates the Forbidden constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The Forbidden constraint to be updated\ngrammar: The grammar that changed\nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Forbidden, AbstractGrammar}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Forbidden, grammar::AbstractGrammar)\n\nUpdates the Forbidden constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The Forbidden constraint to be updated.\ngrammar: The new number of rules in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Forbidden, Integer, AbstractDict{<:Integer, <:Integer}, Vector{<:AbstractConstraint}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Forbidden, n_rules::Integer, mapping::AbstractDict{<:Integer, <:Integer}, ::Vector{<:AbstractConstraint})\n\nUpdates the Forbidden constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The Forbidden constraint to be updated\nn_rules: The new number of rules in the grammar  \nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Forbidden, Integer}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Forbidden, n_rules::Integer)\n\nUpdates the Forbidden constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The Forbidden constraint to be updated.\nn_rules: The new number of rules in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{ForbiddenSequence, AbstractGrammar, AbstractDict{<:Integer, <:Integer}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::ForbiddenSequence, grammar::AbstractGrammar, mapping::AbstractDict{<:Integer, <:Integer})\n\nUpdates the rule indices in a ForbiddenSequence constraint by applying the given mapping to both the sequence and ignore_if fields. Errors if rule indices exceeds number of grammar rules.\n\nArguments\n\nc: The ForbiddenSequence constraint to be updated\ngrammar: The grammar that changed\nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{ForbiddenSequence, AbstractGrammar}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::ForbiddenSequence, grammar::AbstractGrammar)\n\nUpdates a ForbiddenSequence constraint to reflect grammar changes. Errors if rule indices exceeds number of grammar rules.\n\nArguments\n\nc: The ForbiddenSequence constraint to be updated\ngrammar: The grammar that changed\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{ForbiddenSequence, Integer, AbstractDict{<:Integer, <:Integer}, Vector{<:AbstractConstraint}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::ForbiddenSequence, n_rules::Integer, mapping::AbstractDict{<:Integer, <:Integer}, ::Vector{<:AbstractConstraint})\n\nUpdates the rule indices in a ForbiddenSequence constraint by applying the given mapping to both the sequence and ignore_if fields. Errors if rule indices exceeds number of grammar rules.\n\nArguments\n\nc: The ForbiddenSequence constraint to be updated\nn_rules: The new number of rules in the grammar  \nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{ForbiddenSequence, Integer}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::ForbiddenSequence, n_rules::Integer)\n\nUpdates a ForbiddenSequence constraint to reflect grammar changes. Errors if rule indices exceeds n_rules.\n\nArguments\n\nc: The ForbiddenSequence constraint to be updated\nn_rules: The new number of rules in the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Ordered, AbstractGrammar, AbstractDict{<:Integer, <:Integer}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Ordered, grammar::AbstractGrammar, mapping::AbstractDict{<:Integer, <:Integer})\n\nUpdates the Ordered constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The Ordered constraint to be updated\ngrammar: The grammar that changed\nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Ordered, AbstractGrammar}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Ordered, grammar::AbstractGrammar)\n\nUpdates the Ordered constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The Ordered constraint to be updated\ngrammar: The grammar that changed\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Ordered, Integer, AbstractDict{<:Integer, <:Integer}, Vector{<:AbstractConstraint}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Ordered, n_rules::Integer, mapping::AbstractDict{<:Integer, <:Integer}, ::Vector{<:AbstractConstraint})\n\nUpdates the Ordered constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The Ordered constraint to be updated\nn_rules: The new number of rules in the grammar  \nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Ordered, Integer}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Ordered, n_rules::Integer)\n\nUpdates the Ordered constraint to reflect grammar changes by calling HerbCore.update_rule_indices! on its tree field.\n\nArguments\n\nc: The Ordered constraint to be updated.\nn_rules: The new number of rules in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Unique, AbstractGrammar, AbstractDict{<:Integer, <:Integer}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"HerbCore.update_rule_indices!(c::Unique,\ngrammar::AbstractGrammar,\nmapping::AbstractDict{<:Integer,<:Integer})\n\nUpdates the Unique constraint to reflect grammar changes by replacing it with a new  Unique constraint using the mapped rule index.Errors if rule index exceeds number of grammar rules.\n\nArguments\n\nc: The Unique constraint to be updated\ngrammar: The grammar that changed\nmapping: Dictionary mapping old rule indices to new rule indices\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Unique, AbstractGrammar}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Unique, grammar::AbstractGrammar)\n\nUpdates a Unique constraint to reflect grammar changes. Errors if rule index exceeds number of grammar rules.\n\nArguments\n\nc: The Unique constraint to be updated\ngrammar: The grammar that changed\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Unique, Integer, AbstractDict{<:Integer, <:Integer}, Vector{<:AbstractConstraint}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"HerbCore.update_rule_indices!(c::Unique,\nn_rules::Integer,\nmapping::AbstractDict{<:Integer,<:Integer},\nconstraints::Vector{<:AbstractConstraint})\n\nUpdates the Unique constraint to reflect grammar changes by replacing it with a new  Unique constraint using the mapped rule index. Errors if rule index exceeds new n_rules.\n\nArguments\n\nc: The Unique constraint to be updated\nn_rules: The new number of rules in the grammar  \nmapping: Dictionary mapping old rule indices to new rule indices\nconstraints: Vector of grammar constraints containing the constraint to update\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{Unique, Integer}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"update_rule_indices!(c::Unique, n_rules::Integer)\n\nUpdates a Unique constraint to reflect grammar changes. Errors if rule index exceeds new n_rules.\n\nArguments\n\nc: The Unique constraint to be updated.\nn_rules: The new number of rules in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{VarNode, Integer, AbstractDict{<:Integer, <:Integer}}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":"HerbCore.update_rule_indices!(c::VarNode, n_rules::Integer, mapping::AbstractDict{<:Integer, <:Integer})\n\nUpdate the rule indices of a VarNode. As VarNodes contain no indices, this function does nothing.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbCore.update_rule_indices!-Tuple{VarNode, Integer}","page":"HerbConstraints.jl","title":"HerbCore.update_rule_indices!","text":" HerbCore.update_rule_indices!(c::ContainVarNodesSubtree, n_rules::Integer)\n\nUpdate the rule indices of a VarNode. As VarNodes contain no indices, this function does nothing.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Index","page":"HerbConstraints.jl","title":"Index","text":"","category":"section"},{"location":"HerbConstraints/","page":"HerbConstraints.jl","title":"HerbConstraints.jl","text":"","category":"page"},{"location":"HerbConstraints/","page":"HerbConstraints.jl","title":"HerbConstraints.jl","text":"","category":"page"},{"location":"tutorials/advanced_search/","page":"Advanced Search Procedures","title":"Advanced Search Procedures","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"cf838b477c06aa8f7774f25113c8f06ddf76bfc20e5e906347c27973b9e37fc0\"\n    julia_version = \"1.12.1\"\n-->\n\n<div class=\"markdown\"><h1 id=\"Advanced-Search-Procedures-in-Herb.jl\">Advanced Search Procedures in Herb.jl</h1><p><a href=\"\">A more verbose getting started with Herb.jl</a> described the concept of a program space and showed how to search it with Herb.jl, using a simple breadth-first-search (BFS) iterator for the search.  This tutorial takes a closer look at advanced search procedures hat can be employed to find a solution program to a program synthesis problem. </p><p>More specifically, you will learn about</p><ul><li><p><strong>Parameters</strong> that can be specified and their effect on the search procedure.  </p></li><li><p><strong>Deterministic search methods</strong> BFS and DFS.</p></li><li><p><strong>Stochastic search methods</strong>, which introduce randomness to search the program space. We will look at Metropolis-Hastings, Very Large Scale Neighbourhood Search, Simulated Annealing and Genetic Search.</p></li></ul></div>\n\n\n\n\n\n\n\n\n<div class=\"markdown\"><p>Let's import all the Herb modules that we will use throughout the tutorial.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    import Pkg\n    Pkg.activate(Base.current_project())\n    Pkg.instantiate()\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><p>We start with a simple grammar:.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g_1 = @csgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g_1\">1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><p>Let's use the simple program <code>2x+1</code> as our problem and generate some input-output examples for the problem specification.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>problem_1 = Problem([IOExample(Dict(:x =&gt; x), 2x+1) for x âˆˆ 1:5])</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-problem_1\">Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 11)])</pre>\n\n\n<div class=\"markdown\"><h2 id=\"Parameters\">Parameters</h2><p>Search procedures typically have some hyperparameters that you can configure.</p><h3 id=\"max_depth\"><code>max_depth</code></h3><p><code>max_depth</code> controls the maximum depth of the program trees that are explored during the search, effectively limiting the size and complexity of the synthesized program. The parameter is configured as part of the iterator.</p><p>In the following example, we consider two different values for <code>max_depth</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator_1 = BFSIterator(g_1, :Number, max_depth=3)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_1\">BFSIterator(GenericSolver(1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n, SolverState(Hole[Bool[1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 3))</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_2 = BFSIterator(g_1, :Number, max_depth=6)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_2\">BFSIterator(GenericSolver(1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n, SolverState(Hole[Bool[1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 6))</pre>\n\n\n<div class=\"markdown\"><p>To see the effect <code>max_depth</code> has on the number of memory allocations made during the program synthesis process, we use the <code>@time</code> macro.  </p></div>\n\n\n<div class=\"markdown\"><p>Solution for max_depth = 3:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>solution_1 = @time synth(problem_1, iterator_1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-solution_1\">(4{1,4{3,3}}, optimal_program)</pre>\n\n<pre class='language-julia'><code class='language-julia'>rulenode2expr(solution_1[1], g_1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash195477\">:(1 + (x + x))</pre>\n\n\n<div class=\"markdown\"><p>Solution for max_depth = 6:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    solution_2 = @time synth(problem_1, iterator_2)\n    rulenode2expr(solution_2[1], g_1)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-solution_2\">:((1 + x) + x)</pre>\n\n\n<div class=\"markdown\"><p>While increasing <code>max_depth</code> allows us to explore more complex and deeper program trees, which may lead to a better solution, it also requires more memory allocation and can increase the execution time. </p></div>\n\n\n<div class=\"markdown\"><h3 id=\"max_enumerations\"><code>max_enumerations</code></h3><p><code>max_enumerations</code> defines the maximum number of candidate programs that can be evaluated before the search is terminated. </p><p>Let's explore how many enumerations are necessary to solve our simple problem.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    solutions = []\n    times = []\n    nodes = []\n    iterations = []\n    for i in range(1, 50)\n        iterator = BFSIterator(g_1, :Number, max_depth=i)\n        solution = @timed synth(problem_1, iterator)\n        push!(times, solution.time)\n        push!(nodes, solution[1][1])\n        push!(solutions, rulenode2expr(solution[1][1], g_1))\n        push!(iterations, i)\n    end\n       pretty_table(HTML, [iterations nodes solutions times], column_labels=[[\"Iteration\", \"RuleNode\", \"Program\", \"Duration\"]])\nend</code></pre>\n<table><thead><tr class=\"columnLabelRow\"><th style=\"font-weight: bold; text-align: right;\">Iteration</th><th style=\"font-weight: bold; text-align: right;\">RuleNode</th><th style=\"font-weight: bold; text-align: right;\">Program</th><th style=\"font-weight: bold; text-align: right;\">Duration</th></tr></thead><tbody><tr class=\"dataRow\"><td style=\"text-align: right;\">1</td><td style=\"text-align: right;\">3</td><td style=\"text-align: right;\">x</td><td style=\"text-align: right;\">0.00308993</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">2</td><td style=\"text-align: right;\">4{3,2}</td><td style=\"text-align: right;\">x + 2</td><td style=\"text-align: right;\">0.00018771</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">3</td><td style=\"text-align: right;\">4{1,4{3,3}}</td><td style=\"text-align: right;\">1 + (x + x)</td><td style=\"text-align: right;\">0.000355854</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">4</td><td style=\"text-align: right;\">4{1,4{3,3}}</td><td style=\"text-align: right;\">1 + (x + x)</td><td style=\"text-align: right;\">0.000484304</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">5</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000589029</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">6</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000636778</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">7</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000607213</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">8</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000615488</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">9</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.00061075</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">10</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000593257</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">11</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000612904</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">12</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000600331</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">13</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.00061632</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">14</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000620618</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">15</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000588799</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">16</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000612924</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">17</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000593117</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">18</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000619025</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">19</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000619506</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">20</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000593758</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">21</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000609136</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">22</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.0006054</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">23</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000623814</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">24</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000617902</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">25</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000606862</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">26</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000607083</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">27</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000600881</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">28</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000593177</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">29</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000604518</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">30</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000588798</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">31</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000611821</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">32</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.00061652</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">33</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000592626</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">34</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000609537</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">35</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.00062142</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">36</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000606251</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">37</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000614466</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">38</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000597084</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">39</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000602945</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">40</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000590963</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">41</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000601122</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">42</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000600159</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">43</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000588247</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">44</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000635155</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">45</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000608896</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">46</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000591373</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">47</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000651375</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">48</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000606732</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">49</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000600941</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">50</td><td style=\"text-align: right;\">4{4{1,3},3}</td><td style=\"text-align: right;\">(1 + x) + x</td><td style=\"text-align: right;\">0.000595922</td></tr></tbody></table>\n\n\n<div class=\"markdown\"><p>At <code>i = 3</code>, we observe that an optimal program is found. Increasing the number of enumerations beyond that does not affect the solution or the number of memory allocations. </p></div>\n\n\n<div class=\"markdown\"><h3 id=\"allow_evaluation_errors\"><code>allow_evaluation_errors</code></h3><p>A final parameter we consider here is <code>allow_evaluation_errors</code>, which is <code>false</code> by default. When <code>true</code>, the search continues even if an exception occurs during the evaluation of a candidate program. This allows the search process to handle faulty candidate programs and explore other ones, instead of throwing an error and terminating prematurely.</p><p>We will use a new example to see the effect of <code>allow_evaluation_errors</code>. We begin defining a new simple grammar. We then create some input-output examples to specify the problem we want to solve. This time, we choose a problem that we cannot solve with the provided grammar. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>g_2 = @csgrammar begin\n    Number = 1\n    List = []\n    Index = List[Number]\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g_2\">1: Number = 1\n2: List = []\n3: Index = List[Number]\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_2 = Problem([IOExample(Dict{Symbol,Any}(), x) for x âˆˆ 1:5])</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-problem_2\">Problem{Vector{IOExample{Any, Int64}}}(\"\", IOExample{Any, Int64}[IOExample{Any, Int64}(Dict{Symbol, Any}(), 1), IOExample{Any, Int64}(Dict{Symbol, Any}(), 2), IOExample{Any, Int64}(Dict{Symbol, Any}(), 3), IOExample{Any, Int64}(Dict{Symbol, Any}(), 4), IOExample{Any, Int64}(Dict{Symbol, Any}(), 5)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_3 = BFSIterator(g_2, :Index, max_depth=2)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_3\">BFSIterator(GenericSolver(1: Number = 1\n2: List = []\n3: Index = List[Number]\n, SolverState(3{2,1}, Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 2))</pre>\n\n<pre class='language-julia'><code class='language-julia'>Test.@test_throws HerbSearch.EvaluationError synth(problem_2, iterator_3)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash467858\">ï¿½[32mï¿½[1mTest Passedï¿½[22mï¿½[39m\n      Thrown: EvaluationError</pre>\n\n\n<div class=\"markdown\"><p>As expected, an exception occurs during the synthesis process. Now we try the same again, with <code>allow_evaluation_errors=true</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>solution_4 = synth(problem_2, iterator_3, allow_evaluation_errors=true)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-solution_4\">(3{2,1}, suboptimal_program)</pre>\n\n\n<div class=\"markdown\"><p>\"This time we find a solution, although a suboptimal one.</p></div>\n\n\n<div class=\"markdown\"><h2 id=\"Top-down-search\">Top-down search</h2><p>Herb.jl provides already implemented, ready-to-use search methods. The core building block of the search is the program iterator, which represents a walk through the program space. All program iterators share the top-level abstract type <code>ProgramIterator</code>. For more information on iterators and how to customize them, see <a href=\"https://herb-ai.github.io/Herb.jl/dev/tutorials/TopDown/\">this tutorial</a>.</p><p>First, we explore two fundamental deterministic top-down search algorithms: <strong>breadth-first search (BFS)</strong> and <strong>depth-first search (DFS)</strong>. Both algorithms are implemented using the abstract type <code>TopDownIterator</code>, which can be customized through the functions </p><ul><li><p><code>priority_function</code></p></li><li><p><code>derivation_heuristic</code></p></li><li><p><code>hole_heuristic</code></p></li></ul></div>\n\n\n<div class=\"markdown\"><p>First, we explore two fundamental deterministic top-down search algorithms: <strong>breadth-first search (BFS)</strong> and <strong>depth-first search (DFS)</strong>. Both algorithms are implemented using the abstract type <code>TopDownIterator</code>, which can be customized through the functions priority<em>function, derivation</em>heuristic, and hole_heuristic.</p><h3 id=\"Breadth-First-Search\">Breadth-First Search</h3><p>The <code>BFSIterator</code> enumerates all possible programs at a given depth before progressing to the next level, ensuring that trees are explored in increasing order of size. This guarantees that smaller programs are evaluated first, and larger, more complex ones are considered only after all smaller ones have been processed.</p><p>To explore <code>BFSIterator</code>, we define another very simple grammar.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g_3 = @csgrammar begin\n        Real = 1 | 2\n        Real = Real * Real\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g_3\">1: Real = 1\n2: Real = 2\n3: Real = Real * Real\n</pre>\n\n\n<div class=\"markdown\"><p>Next, we define a <code>BFSIterator</code> with a <code>max_depth</code> of 2 and a <code>max_size</code> of infinite (which we approximate with the maximum value of <code>Int</code>), and a starting symbol of type <code>Real</code>. By default, <code>BFSIterator</code> uses the heuristic 'left-most first', i.e., the left-most child in the tree is always explored first.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator_bfs = BFSIterator(g_3, :Real, max_depth=2, max_size=typemax(Int))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_bfs\">BFSIterator(GenericSolver(1: Real = 1\n2: Real = 2\n3: Real = Real * Real\n, SolverState(Hole[Bool[1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 2))</pre>\n\n\n<div class=\"markdown\"><p>To see all possible solution programs the iterator explores, we use <code>collect</code>. It returs a list of the programs, ordered by increasing size and depth. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>programs_bfs = collect(iterator_bfs)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-programs_bfs\">6-element Vector{RuleNode}:\n 1\n 2\n 3{1,1}\n 3{1,2}\n 3{2,1}\n 3{2,2}</pre>\n\n\n<div class=\"markdown\"><p>Let's verify that the iterator returns the programs we expect (keep in mind we use a leftmost-first heuristic).</p></div>\n\n<pre class='language-julia'><code class='language-julia'>answer_programs = [\n    RuleNode(1),\n    RuleNode(2),\n    RuleNode(3, [RuleNode(1), RuleNode(1)]),\n    RuleNode(3, [RuleNode(1), RuleNode(2)]),\n    RuleNode(3, [RuleNode(2), RuleNode(1)]),\n    RuleNode(3, [RuleNode(2), RuleNode(2)])\n]</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-answer_programs\">6-element Vector{RuleNode}:\n 1\n 2\n 3{1,1}\n 3{1,2}\n 3{2,1}\n 3{2,2}</pre>\n\n<pre class='language-julia'><code class='language-julia'>rulenode_programs = [rulenode2expr(r, g_3) for r in answer_programs]</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-rulenode_programs\">6-element Vector{Any}:\n 1\n 2\n  :(1 * 1)\n  :(1 * 2)\n  :(2 * 1)\n  :(2 * 2)</pre>\n\n<pre class='language-julia'><code class='language-julia'>found_all_programs = all(p âˆˆ programs_bfs for p âˆˆ answer_programs)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-found_all_programs\">true</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Depth-First-Search\">Depth-First Search</h3><p>The <code>DFSIterator</code> explores one branch of the search tree at a time, fully traversing it unitl a correct program is found or the specified <code>max_depth</code> is reached. Only after completing the current branch, it proceeds to the next branch.</p><p>As before, we <code>collect</code> the candidate programs using the same grammar, but a <code>DFSIterator</code>. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator_dfs = DFSIterator(g_3, :Real, max_depth=2, max_size=typemax(Int))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_dfs\">DFSIterator(GenericSolver(1: Real = 1\n2: Real = 2\n3: Real = Real * Real\n, SolverState(Hole[Bool[1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 2))</pre>\n\n<pre class='language-julia'><code class='language-julia'>programs_dfs = collect(iterator_dfs)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-programs_dfs\">6-element Vector{RuleNode}:\n 1\n 3{1,1}\n 3{1,2}\n 3{2,1}\n 3{2,2}\n 2</pre>\n\n\n<div class=\"markdown\"><p><code>DFSIterator</code> also uses by default a <strong>leftmost-first</strong> heuristic. If we want to use a <strong>rightmost-first</strong> heuristic instead, we can create our own iterator <code>DFSIteratorRightmost</code> as a sub-type of <code>TopDownIterator</code>, using the <code>@programiterator</code> macro. Then we implement the functions <code>priority_function</code> and <code>hole_heuristic</code>. Also see the tutorial <a href=\"https://herb-ai.github.io/Herb.jl/dev/tutorials/TopDown/\">Top Down Iterator</a> for how to build iterators is Herb.jl. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>@programiterator DFSIteratorRightmost() &lt;: TopDownIterator</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-DFSIteratorRightmost\">DFSIteratorRightmost</pre>\n\n\n<div class=\"markdown\"><p>By default, <code>priority_function</code> for a <code>TopDownIterator</code> is that of a BFS iterator. Hence, we need to provide a new implementation. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>function priority_function(\n    ::DFSIteratorRightmost, \n    ::AbstractGrammar, \n    ::AbstractRuleNode, \n    parent_value::Union{Real, Tuple{Vararg{Real}}},\n    isrequeued::Bool\n)\n    if isrequeued\n        return parent_value;\n    end\n    return parent_value - 1;\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-priority_function\">priority_function (generic function with 1 method)</pre>\n\n\n<div class=\"markdown\"><p>Next, we need to implement the <code>hole_heuristic</code> to be rightmost-first.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function hole_heuristic(::DFSIteratorRightmost, node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n    return heuristic_rightmost(node, max_depth);\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hole_heuristic\">hole_heuristic (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>iteratordfs_rightmost = DFSIteratorRightmost(g_3, :Real, max_depth=2, max_size=typemax(Int))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iteratordfs_rightmost\">DFSIteratorRightmost(GenericSolver(1: Real = 1\n2: Real = 2\n3: Real = Real * Real\n, SolverState(Hole[Bool[1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 2))</pre>\n\n<pre class='language-julia'><code class='language-julia'>programs_dfs_rightmost = collect(iteratordfs_rightmost)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-programs_dfs_rightmost\">6-element Vector{RuleNode}:\n 1\n 2\n 3{1,1}\n 3{1,2}\n 3{2,1}\n 3{2,2}</pre>\n\n\n<div class=\"markdown\"><p>We observe that the order of programs has changed. We can also test if both DFS iterators return the same programs:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>Set(programs_dfs)==Set(programs_dfs_rightmost)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash121764\">true</pre>\n\n\n<div class=\"markdown\"><h2 id=\"Stochastic-search\">Stochastic search</h2><p>While deterministic search methods explore the search space in a predictable way, stochastic ones introduce randomness to allow for more flexibility.</p><p>In this section, we will look at the stochastic search algorithms: Metropolis-Hastings (MH), Very Large Scale Neighbourhood Search (VLSNS), and Simulated Annealing (SA). In Herb.jl, all of these search methodsthe share a common supertype <code>StochasticSearchIterator</code>, which defines the following fields</p><ul><li><p><code>examples</code></p></li><li><p><code>cost_function</code></p></li><li><p><code>initial_temperature</code></p></li><li><p><code>evaluation_function</code>.</p></li></ul><p>They are customized by overriding the functions <code>neighbourhood</code>, <code>propose</code>, <code>accept</code> and <code>temperature</code> as required.</p><p>We start with a simple grammar and a helper function to create the input-output examples for the problem we want to solve.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g_4 = @csgrammar begin\n    X = |(1:5)\n    X = X * X\n    X = X + X\n    X = X - X\n    X = x\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g_4\">1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>function create_problem(f, range=20)\n    examples = [IOExample(Dict(:x =&gt; x), f(x)) for x âˆˆ 1:range]\n    return Problem(examples), examples\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-create_problem\">create_problem (generic function with 2 methods)</pre>\n\n\n<div class=\"markdown\"><p>Throughout the stochastic search examples, we will use mean-squared-error as cost function. The cost function helps to guide the search by evaluating how well a candidate program solves the given task. This is used to decide whether a proposed program should be accepted or rejected.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>cost_function = mean_squared_error</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-cost_function\">mean_squared_error (generic function with 1 method)</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Metropolis-Hastings\">Metropolis-Hastings</h3><p>Metropolis-Hastings (MH) is a method to produce samples from a distribution that may otherwise be difficult to sample. In the context of program synthesis, we sample from a distribution of programs defined by the grammar. </p><p>For more information on MH, see for example <a href=\"https://stephens999.github.io/fiveMinuteStats/MH_intro.html\">this webpage</a>.</p><p>To illustrate MH, we use a simple arithmetic example.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>e_mh = x -&gt; x * x + 4</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-e_mh\">#14 (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_mh, examples_mh = create_problem(e_mh)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_mh\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)])</pre>\n\n\n<div class=\"markdown\"><p>Run the following code block to define the iterator and perform the program synthesis multiple times. Since the search process is stochastic, you will likely see different solution programs with each run.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    rules = []\n    programs = []\n    iters = []\n    for i in range(1, 3)\n        iterator_mh = MHSearchIterator(g_4, :X, examples_mh, cost_function, max_depth=3) \n        program_mh = synth(problem_mh, iterator_mh)\n        push!(rules, program_mh[1])\n        push!(programs, rulenode2expr(program_mh[1], g_4))\n        push!(iters, i)\n    end\n       pretty_table(HTML, [iters rules programs], column_labels=[[\"Run\", \"RuleNode\", \"Program\"]])\nend</code></pre>\n<table><thead><tr class=\"columnLabelRow\"><th style=\"font-weight: bold; text-align: right;\">Run</th><th style=\"font-weight: bold; text-align: right;\">RuleNode</th><th style=\"font-weight: bold; text-align: right;\">Program</th></tr></thead><tbody><tr class=\"dataRow\"><td style=\"text-align: right;\">1</td><td style=\"text-align: right;\">8{6{9,9},8{1,5}}</td><td style=\"text-align: right;\">x * x - (1 - 5)</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">2</td><td style=\"text-align: right;\">7{6{9,9},4}</td><td style=\"text-align: right;\">x * x + 4</td></tr><tr class=\"dataRow\"><td style=\"text-align: right;\">3</td><td style=\"text-align: right;\">7{7{2,2},6{9,9}}</td><td style=\"text-align: right;\">(2 + 2) + x * x</td></tr></tbody></table>\n\n\n<div class=\"markdown\"><h3 id=\"Very-Large-Scale-Neighbourhood-Search\">Very Large Scale Neighbourhood Search</h3><p>The second stochastic search method we consider is Very Large Scale Neighbourhood Search (VLSN). In each iteration, the algorithm searches the neighbourhood of the current candidate program for a local optimum, aiming to find a better candidate solution.</p><p>For more information, see <a href=\"https://backend.orbit.dtu.dk/ws/portalfiles/portal/5293785/Pisinger.pdf\">this article</a>.</p><p>Given the same grammar as before, we can try it with some simple examples.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>e_vlsn = x -&gt; 10</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-e_vlsn\">#17 (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_vlsn1, examples_vlsn1 = create_problem(e_vlsn)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_vlsn1\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 10)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 10)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_vlsn1 = VLSNSearchIterator(g_4, :X, examples_vlsn1, cost_function, max_depth=2) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_vlsn1\">VLSNSearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(Hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 2), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 10)], mean_squared_error, 2, 1, execute_on_input)</pre>\n\n<pre class='language-julia'><code class='language-julia'>program_vlsn1 = synth(problem_vlsn1, iterator_vlsn1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program_vlsn1\">(6{2,5}, optimal_program)</pre>\n\n<pre class='language-julia'><code class='language-julia'>e_vlsn2 = x -&gt; x</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-e_vlsn2\">#20 (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_vlsn2, examples_vlsn2 = create_problem(e_vlsn2)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_vlsn2\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 1), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 2), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 4), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 11), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 12), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 14), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 15), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 17), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 18), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 19), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 20)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 1), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 2), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 4), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 11), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 12), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 14), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 15), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 17), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 18), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 19), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 20)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_vlsn2 = VLSNSearchIterator(g_4, :X, examples_vlsn2, cost_function, max_depth=1) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_vlsn2\">VLSNSearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(Hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 1), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 1), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 2), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 4), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 11), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 12), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 14), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 15), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 17), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 18), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 19), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 20)], mean_squared_error, 2, 1, execute_on_input)</pre>\n\n<pre class='language-julia'><code class='language-julia'>program_vlsn2 = synth(problem_vlsn2, iterator_vlsn2)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program_vlsn2\">(9, optimal_program)</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Simulated-Annealing\">Simulated Annealing</h3><p>Simulated Annealing (SA) explores smaller, incremental changes to the candidate program in each iteration, gradually refining the solution. It is a variation of the hill-climbing algorithm: Instead of always selecting the best move, SA picks a random move. If the move improves the solution (i.e., the candidate program), it is accepted.</p><p>Occasionally, SA will accept a move that worsens the solution. This allows the algorithm to escape local optima and explore more of the solution space. However, this strategy follows a cooling (annealing) schedule: at the beginning (high temperature), the algorithm explores more broadly and is more likely to accept worse solutions. As the temperature decreases, it becomes more selective, accepting worse solutions less often.</p><p>For more information, see <a href=\"https://www.cs.cmu.edu/afs/cs.cmu.edu/project/learn-43/lib/photoz/.g/web/glossary/anneal.html\">this page</a>.</p></div>\n\n\n<div class=\"markdown\"><p>We use the same example as for MH. SA additionally has the option to specify the <code>initial_temperature</code> for the annealing (default <code>initial_temperature=1</code>). Let's see what effect changing the temperature from 1 to 2 has on the solution program.   </p></div>\n\n<pre class='language-julia'><code class='language-julia'>problem_sa, examples_sa = create_problem(e_mh)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_sa\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>initial_temperature1 = 1</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-initial_temperature1\">1</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_sa1 = SASearchIterator(g_4, :X, examples_sa, cost_function, max_depth=3, initial_temperature = initial_temperature1) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_sa1\">SASearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(Hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 3), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)], mean_squared_error, 1, 0.99, execute_on_input)</pre>\n\n<pre class='language-julia'><code class='language-julia'>program_sa1 = synth(problem_sa, iterator_sa1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program_sa1\">(8{6{9,9},8{1,5}}, optimal_program)</pre>\n\n<pre class='language-julia'><code class='language-julia'>initial_temperature2 = 2</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-initial_temperature2\">2</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_sa2 = SASearchIterator(g_4, :X, examples_sa, cost_function, max_depth=3, initial_temperature = initial_temperature2) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_sa2\">SASearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(Hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 3), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 8), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 13), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 20), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 29), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 40), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 53), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 68), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 85), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 104), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 125), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 148), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 173), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 200), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 229), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 260), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 293), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 328), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 365), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 404)], mean_squared_error, 2, 0.99, execute_on_input)</pre>\n\n\n<div class=\"markdown\"><h2 id=\"Genetic-Search\">Genetic Search</h2><p>Genetic search is a type of evolutionary algorithm, which simulates the process of natural selection. It evolves a population of candidate programs through operations like mutation, crossover (recombination), and selection. Then, the fitness of each program is assessed (i.e., how well it satisfies the given specifications). Only the 'fittest' programs are selected for the next generation, thus gradually refining the population of candidate programs.</p><p>For more information, see <a href=\"https://www.geeksforgeeks.org/genetic-algorithms/\">here</a>.</p><p>We show the example of finding a lambda function. Try varying the parameters of the genetic search to see what happens.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>e_gs = x -&gt; 3 * x * x + (x + 2)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-e_gs\">#23 (generic function with 1 method)</pre>\n\n<pre class='language-julia'><code class='language-julia'>problem_gs, examples_gs = create_problem(e_gs)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples_gs\">(Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 32), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 54), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 82), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 116), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 156), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 202), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 254), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 312), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 376), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 446), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 522), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 604), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 692), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 786), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 886), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 992), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 1104), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 1222)]), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 32), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 54), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 82), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 116), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 156), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 202), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 254), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 312), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 376), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 446), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 522), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 604), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 692), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 786), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 886), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 992), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 1104), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 1222)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>iterator_gs = GeneticSearchIterator(g_4, :X, examples_gs, population_size = 10, mutation_probability = 0.8, maximum_initial_population_depth = 3) </code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_gs\">GeneticSearchIterator(GenericSolver(1: X = 1\n2: X = 2\n3: X = 3\n4: X = 4\n5: X = 5\n6: X = X * X\n7: X = X + X\n8: X = X - X\n9: X = x\n, SolverState(Hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 9223372036854775807), IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 6), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 16), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 32), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 54), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 82), IOExample{Int64, Int64}(Dict(:x =&gt; 6), 116), IOExample{Int64, Int64}(Dict(:x =&gt; 7), 156), IOExample{Int64, Int64}(Dict(:x =&gt; 8), 202), IOExample{Int64, Int64}(Dict(:x =&gt; 9), 254), IOExample{Int64, Int64}(Dict(:x =&gt; 10), 312), IOExample{Int64, Int64}(Dict(:x =&gt; 11), 376), IOExample{Int64, Int64}(Dict(:x =&gt; 12), 446), IOExample{Int64, Int64}(Dict(:x =&gt; 13), 522), IOExample{Int64, Int64}(Dict(:x =&gt; 14), 604), IOExample{Int64, Int64}(Dict(:x =&gt; 15), 692), IOExample{Int64, Int64}(Dict(:x =&gt; 16), 786), IOExample{Int64, Int64}(Dict(:x =&gt; 17), 886), IOExample{Int64, Int64}(Dict(:x =&gt; 18), 992), IOExample{Int64, Int64}(Dict(:x =&gt; 19), 1104), IOExample{Int64, Int64}(Dict(:x =&gt; 20), 1222)], execute_on_input, 10, 0.8, 3)</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    program_gs, error_gs = synth(problem_gs, iterator_gs)\n    rulenode2expr(program_gs, g_4)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program_gs\">:(((4 + 3 * (x * x)) + (3 - 5)) + x)</pre>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/advanced_search/","page":"Advanced Search Procedures","title":"Advanced Search Procedures","text":"","category":"page"},{"location":"tutorials/getting_started_with_constraints/","page":"Getting started with Constraints","title":"Getting started with Constraints","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"7f6d2c79d4e994a25b08d4ee57295d2ef1e865c282ddf1847c84c5dbceddbe9a\"\n    julia_version = \"1.12.1\"\n-->\n\n<div class=\"markdown\"><h1 id=\"Getting-started-with-HerbConstraints\">Getting started with HerbConstraints</h1><p>When enumerating programs using a grammar, we will encounter many redundant programs. For example, <code>x</code>, <code>-(-x)</code> and <code>1 * x</code> are syntactically different programs, but they have the same semantics. Grammar constraints aim to speed up synthesis by eliminating such redundant programs and thereby reducing the size of the program space.</p></div>\n\n\n<div class=\"markdown\"><h3 id=\"Setup\">Setup</h3><p>For this tutorial, we need to import the Herb.jl framework and we define a simple arithmetic grammar.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    import Pkg\n    # Use the docs/ environment instead of embedded one\n    Pkg.activate(Base.current_project())\n    Pkg.instantiate()\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>grammar = @csgrammar begin\n    Int = 1\n    Int = x\n    Int = -Int\n    Int = Int + Int\n    Int = Int * Int\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grammar\">1: Int = 1\n2: Int = x\n3: Int = -Int\n4: Int = Int + Int\n5: Int = Int * Int\n</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Working-with-constraints\">Working with constraints</h3><p>To show the effects of constraints, we will first enumerate all programs without constraints (up to a maximum size of 3 AST nodes).</p><p>(To make sure the grammar doesn't have any constraints, we can clear the constraints using <code>clearconstraints!</code>. This is not needed at this point, but could come in handy if your REPL holds a reference to a constrained version of the grammar)</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n    iter_1 = BFSIterator(grammar, :Int, max_size=3)\n\n    for program âˆˆ iter_1\n        println(rulenode2expr(program, grammar))\n    end\n\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Upon inspection, we can already see some redundant programs, like <code>1 * 1</code> and <code>-(-1)</code>. To eliminate these redundant programs, we will set up some constraints that prevent these patterns from appearing. Then we will create another iterator to enumerate all programs that satisfy the defined grammar constraints.</p><p>To make the forbidden pattern constraint general, we will use a special type of rulenode: <code>VarNode(:A)</code>. This node matches with any subtree and can be used to forbid multiple forbidden patterns using a single constraint. For example, <code>Forbidden(RuleNode(minus, [RuleNode(minus, [VarNode(:A)])])))</code> forbids:</p><ul><li><p><code>-(-1)</code></p></li><li><p><code>-(-X)</code></p></li><li><p><code>-(-(1 + 1))</code></p></li><li><p><code>1 + -(-(1 + 1))</code></p></li><li><p>etc</p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    one = 1\n    x = 2\n    minus = 3\n    plus = 4\n    times = 5\n\n    addconstraint!(grammar, Forbidden(RuleNode(times, [RuleNode(one), VarNode(:A)])))        # forbid 1*A\n    addconstraint!(grammar, Forbidden(RuleNode(minus, [RuleNode(minus, [VarNode(:A)])])))    # forbid -(-A)\n\n    iter_2 = BFSIterator(grammar, :Int, max_size=3)\n\n    for program âˆˆ iter_2\n        println(rulenode2expr(program, grammar))\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3 id=\"Forbidden-Constraint\">Forbidden Constraint</h3><p>The <code>Forbidden</code> constraint forbids any subtree in the program that matches a given template tree. Such a template tree can consist of 3 node types:</p><ul><li><p><code>RuleNode(1)</code>. Matches exactly the given rule.</p></li><li><p><code>DomainRuleNode(BitVector((0, 0, 0, 1, 1)), children)</code>. Matches any rule in its bitvector domain. In this case, rule 4 and 5.</p></li><li><p><code>VarNode(:A)</code>. Matches any subtree. If another VarNode of the same name is used, the subtrees have to be the same.</p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    #this constraint forbids A+A and A*A\n    constraint_1 = Forbidden(DomainRuleNode(BitVector((0, 0, 0, 1, 1)), [VarNode(:A), VarNode(:A)]))\n\n    # Without this constraint, we encounter 154 programs\n    clearconstraints!(grammar)\n    iter_3 = BFSIterator(grammar, :Int, max_size=5)\n    println(length(iter_3))\n\n    # With this constraint, we encounter 106 programs\n    clearconstraints!(grammar)\n    addconstraint!(grammar, constraint_1)\n    iter_4 = BFSIterator(grammar, :Int, max_size=5)\n    println(length(iter_4))\n\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3 id=\"Contains-Constraint\">Contains Constraint</h3><p>The <code>Contains</code> constraint enforces that a given rule appears in the program tree at least once. </p><p>In the arithmetic grammar, this constraint can be used to ensure the input symbol <code>x</code> is used in the program. Otherwise, the program is just a constant.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n    addconstraint!(grammar, Contains(2)) #rule 2 should be used in the program\n    iter_5 = BFSIterator(grammar, :Int, max_size=3)\n\n    for program âˆˆ iter_5\n        println(rulenode2expr(program, grammar))\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3 id=\"Contains-Subtree-Constraint\">Contains Subtree Constraint</h3><p>Similarly to the <code>Contains</code> constraint, the <code>ContainsSubtree</code> can be used to enforce a given template tree is used in the program at least once.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n    addconstraint!(grammar, ContainsSubtree(RuleNode(times, [RuleNode(x), RuleNode(x)]))) #x*x should be in the program tree\n    iter_6 = BFSIterator(grammar, :Int, max_size=4)\n\n    for program âˆˆ iter_6\n        println(rulenode2expr(program, grammar))\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3 id=\"Ordered-Constraint\">Ordered Constraint</h3><p>The <code>Ordered</code> constraint enforces an <code>&lt;=</code> ordering on a provided list of variables. With this constraint, we can break symmetries based on commutativity. For example, <code>1+x</code> and <code>x+1</code> are semantically equivalent. By imposing an <code>Ordered</code> constraint, we can eliminate one of the symmetric variants.</p><p>To define an <code>Ordered</code> constraint, we need to provide it with a template tree including at least two differently named <code>VarNode</code>s. And additionally, an ordering of the variables in the tree.</p><p>In the upcoming example we will set up a template tree representing <code>a+b</code> and <code>a*b</code>. Then, we will impose an ordering <code>a&lt;=b</code> on all the subtrees that match the template.</p><p>The result is that our iterator skips the redundant programs <code>x+1</code> and <code>x*1</code>, as they are already represented by <code>1+x</code> and <code>1*x</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n\n    template_tree = DomainRuleNode(BitVector((0, 0, 0, 1, 1)), [VarNode(:a), VarNode(:b)])\n    order = [:a, :b]\n\n    addconstraint!(grammar, Ordered(template_tree, order))\n    iter_7 = BFSIterator(grammar, :Int, max_size=3)\n\n    for program âˆˆ iter_7\n        println(rulenode2expr(program, grammar))\n    end\n\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3 id=\"Forbidden-Sequence-Constraint\">Forbidden Sequence Constraint</h3><p>The <code>ForbiddenSequence</code> constraints forbids a given sequence of rule nodes in a vertical path of the tree. </p><p>An optional second argument, <code>ignore_if</code>, can be used to overrule the constraint in case any of the rules on the <code>ignore_if</code> list are present. </p><p>Below we will define the constraint <code>ForbiddenSequence([plus, one], ignore_if=[times])</code>. It forbids an <code>1</code> after an <code>+</code> unless an <code>*</code> disrupts the sequence.</p><p>This constraint will <strong>forbid</strong> the following programs:</p><ul><li><p>x + 1</p></li><li><p>x + -1</p></li><li><p>x + -(-1)</p></li><li><p>x + (x + 1)</p></li><li><p>x * (x + 1)</p></li></ul><p>But it will <strong>allow</strong> the following program (as * disrupts the sequence):</p><ul><li><p>x + (x * 1)</p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    constraint_2 = ForbiddenSequence([plus, one], ignore_if=[times])\n    addconstraint!(grammar, constraint_2)\n    iter_8 = BFSIterator(grammar, :Int, max_size=3)\n\n    for program âˆˆ iter_8\n        println(rulenode2expr(program, grammar))\n    end\n\nend</code></pre>\n\n\n\n<div class=\"markdown\"><h3 id=\"Custom-Constraint\">Custom Constraint</h3><p>To implement a new constraint, we need to define two structs: an <code>AbstractGrammarConstraint</code> and an <code>AbstractLocalConstraint</code>.</p><p>A <strong>grammar constraint</strong> is a high-level constraint on the grammar itself and does not refer to a location in the tree. For example, the <code>Forbidden</code> constraint is responsible for forbidding a template tree everywhere in the tree. To divide the work of constraint propagation, the grammar constraint will post several local constraints that are responsible for propagating the constraint at each particular location.</p><p>A <strong>local constraint</strong> is a rooted version of a grammar constraint. Each local constraint holds a <code>path</code> field that points to a location in the tree where this constraint applies.</p></div>\n\n\n<div class=\"markdown\"><p>Suppose we want to implement a simple custom constraint that forbids a given <code>rule</code> twice in a row. </p><p>Each time a new AST node is added to a tree, the <code>on_new_node</code> function is called to notify that an unseen node has been added to the tree at path <code>path</code>. Our grammar constraint has the opportunity to react to this event. In this example, we will post a new local constraint at the new location using the <code>post!</code> function.</p><p>(Don't worry about the <code>HerbConstraints.</code> prefixes. Normally, constraints are defined within the HerbConstraints repository, so there is no need to specify the namespace)</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    \"\"\"\n    Forbids the consecutive application of the specified rule.\n    For example, CustomConstraint(4) forbids the tree 4(1, 4(1, 1)) as it applies rule 4 twice in a row.\n    \"\"\"\n    struct ForbidConsecutive &lt;: AbstractGrammarConstraint\n        rule::Int\n    end\n\n    \"\"\"\n    Post a local constraint on each new node that appears in the tree\n    \"\"\"\n    function HerbConstraints.on_new_node(solver::Solver, constraint::ForbidConsecutive, path::Vector{Int})\n        HerbConstraints.post!(solver, LocalForbidConsecutive(path, constraint.rule))\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>To be able to add our custom constraint to the grammar, we need to implement two more functions that are required for all grammar constraints:</p><ul><li><p><code>HerbCore.is_domain_valid()</code></p></li><li><p><code>HerbCore.issame()</code></p></li></ul><p>Let's look at <code>is_domain_valid</code> first. For a <code>ForbidConsecutive</code> constraint the domain is valid if its <code>rule</code> is a valid rule index, i.e. it does not exceed the number of rules in the given grammar.</p><p>The docs for tell us that there is two interfaces for <code>is_domain</code> and we will implement both.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>@doc HerbCore.is_domain_valid</code></pre>\n<div class=\"markdown\"><pre><code class=\"language-julia\">is_domain_valid(x, n_rules::Integer)\nis_domain_valid(x, grammar::AbstractGrammar)</code></pre><p>Check if the domain for the given object <code>x</code> (ex: <a href=\"@ref\"><code>RuleNode</code></a>, <a href=\"@ref\"><code>Hole</code></a> or <a href=\"@ref\"><code>AbstractConstraint</code></a>) is valid given the provided grammar or number of rules.</p><p>If <a href=\"@ref\"><code>isfilled</code></a><code>(x)</code> and <code>x</code> has children, it checks if all children are valid.</p></div>\n\n\n<div class=\"markdown\"><p>We implement both interfaces:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function HerbCore.is_domain_valid(c::ForbidConsecutive, n_rules::Integer)\n    c.rule &lt;= n_rules\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>function HerbCore.is_domain_valid(c::ForbidConsecutive, grammar::AbstractGrammar)\n    HerbCore.is_domain_valid(c, length(grammar.rules))\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p><code>issame</code> is used by <code>addconstraint!</code> to avoid duplicate constraints, i.e. a constraint is only added to the grammar if it doesn't already exist. If not implemented for a specific type, <code>issame</code> defaults to <code>false</code>. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>@doc HerbCore.issame</code></pre>\n<div class=\"markdown\"><pre><code class=\"language-julia\">issame(a, b)</code></pre><p>Returns whether the two given objects <code>a</code> and <code>b</code> (ex: <a href=\"@ref\"><code>RuleNode</code></a>, <a href=\"@ref\"><code>Hole</code></a> or <a href=\"@ref\"><code>AbstractConstraint</code></a>) are the same.</p></div>\n\n\n<div class=\"markdown\"><p>We consider two <code>ForbidConsecutive</code> constraints to be the same if their <code>rule</code>s are equal. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>function HerbCore.issame(c1::ForbidConsecutive, c2::ForbidConsecutive)\n    c1.rule == c2.rule\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Next, we will define our local constraint. This constraint is responsible for propagating the constraint at a given path. The <code>propagate!</code> method can use several solver functions to manipulate the tree. The following <strong>tree manipulations</strong> can be used to remove rules from the domain of a hole at a given path:</p><ul><li><p><code>remove!(solver::Solver, path::Vector{Int}, rule_index::Int)</code></p></li><li><p><code>remove!(solver::Solver, path::Vector{Int}, rules::Vector{Int})</code></p></li><li><p><code>remove_all_but!(solver::Solver, path::Vector{Int}, new_domain::BitVector)</code></p></li><li><p><code>remove_above!(solver::Solver, path::Vector{Int}, rule_index::Int)</code></p></li><li><p><code>remove_below!(solver::Solver, path::Vector{Int}, rule_index::Int)</code></p></li><li><p><code>make_equal!(solver::Solver, node1::AbstractRuleNode, node2::AbstractRuleNode)</code> (a high level manipulation that requires <code>node1</code> and <code>node2</code> to be in the tree)</p></li></ul><p>In addition to tree manipulations, the following solver functions can be used to communicate new information to the solver:</p><ul><li><p><code>set_infeasible!(solver)</code>. If a propagator detects an inconsistency, the solver should be notified and cancel any other scheduled propagators.</p></li><li><p><code>deactivate!(solver, constraint)</code>.  If a constraint is satisfied, it should deactivate itself to prevent re-propagation.</p></li><li><p><code>post!(solver, constraint)</code>  A constraint is allowed to post new local constraints. This might be helpful if a constraint can be reduced to a smaller constraint.</p></li></ul><p>The solver manages all constraints and the program tree we propagate on. Applying tree manipulations might cause a chain reaction of other propagators, so the shape of the tree might update as we propagate. The get the latest information about the tree, we should use the following getter functions:</p><ul><li><p><code>get_tree(solver)</code> returns the root node of the current (partial) program tree</p></li><li><p><code>isfeasible(solver)</code> returns the a flag indicating if the solver is not violating any (other) constraints.</p></li><li><p><code>get_path(solver, node)</code> returns the path at which the node is located.</p></li><li><p><code>get_node_at_location(solver, path)</code> returns the node that is currently at the given path (be aware that this instance might be replaced by manipulations).</p></li><li><p><code>get_hole_at_location(solver, path)</code> same as get node at location, but asserts the node is a hole (domain size &gt;= 2).</p></li></ul><p>To get information about a node, we can use the following getter functions:</p><ul><li><p><code>isfilled(node)</code>. Returns true if the node is a <code>RuleNode</code> or has domain size 1.</p></li><li><p><code>get_rule(node)</code>. Get the rule of a filled node.</p></li><li><p><code>get_children(node)</code>. Get the children of a node.</p></li><li><p><code>node.domain[rule]</code>. Given the node is a hole, return true if <code>rule</code> is in the domain.</p></li></ul><p>Finally, another useful function for propagators is <code>pattern_match(node1, node2)</code>. This function compares two trees and returns a <code>PatternMatchResult</code> that indicates if the nodes match, and potentially indicate which holes need to be filled to complete the match.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    \"\"\"\n    Forbids the consecutive application of the specified rule at path `path`.\n    \"\"\"\n    struct LocalForbidConsecutive &lt;: AbstractLocalConstraint\n        path::Vector{Int}\n        rule::Int\n    end\n\n    \"\"\"\n    Propagates the constraints by preventing a consecutive application of the specified rule.\n    \"\"\"\n    function HerbConstraints.propagate!(solver::Solver, constraint::LocalForbidConsecutive)\n        node = get_node_at_location(solver, constraint.path)\n        if isfilled(node)\n            if get_rule(node) == constraint.rule\n                #the specified rule is used, make sure the rule will not be used by any of the children\n                for (i, child) âˆˆ enumerate(get_children(node))\n                    if isfilled(child)\n                        if get_rule(child) == constraint.rule\n                            #the specified rule was used twice in a row, which is violating the constraint\n                            set_infeasible!(solver)\n                            return\n                        end\n                    elseif child.domain[constraint.rule]\n                        child_path = push!(copy(constraint.path), i)\n                        remove!(solver, child_path, constraint.rule) # remove the rule from the domain of the child\n                    end\n                end\n            end\n        elseif node.domain[constraint.rule]\n            #our node is a hole with the specified rule in its domain\n            #we will now check if any of the children already uses the specified rule\n            softfail = false\n            for (i, child) âˆˆ enumerate(get_children(node))\n                if isfilled(child)\n                    if get_rule(child) == constraint.rule\n                        #the child holds the specified rule, so the parent cannot have this rule\n                        remove!(solver, constraint.path, constraint.rule)\n                    end\n                elseif child.domain[constraint.rule]\n                    #the child is a hole and contains the specified node. since there are 2 holes involved, we will softfail.\n                    softfail = true\n                end\n            end\n            if softfail\n                #we cannot deactivate the constraint, because it needs to be repropagated\n                return\n            end\n        end\n\n        #the constraint is satisfied and can be deactivated\n        HerbConstraints.deactivate!(solver, constraint)\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>Posting a local constraint will trigger the initial propagation. To re-propagate, the constraint needs to be rescheduled for propagation.</p><p>Whenever the tree is manipulated, we will make a <code>shouldschedule</code> check to see if our constraint needs to be rescheduled for propagation based on the manipulation.</p><p>In our case, we want to repropagate if either:</p><ul><li><p>a tree manipulation occurred at the <code>constraint.path</code></p></li><li><p>a tree manipulation occurred at the child of the <code>constraint.path</code></p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>\n\"\"\"\nGets called whenever an tree manipulation occurs at the given `path`.\nReturns true iff the `constraint` should be rescheduled for propagation.\n\"\"\"\nfunction HerbConstraints.shouldschedule(solver::Solver, constraint::LocalForbidConsecutive, path::Vector{Int})::Bool\n    return (path == constraint.path) || (path == constraint.path[1:end-1])\nend\n</code></pre>\n\n\n\n<div class=\"markdown\"><p>With all the components implemented, we can do a constrained enumeration using our custom constraint. Firt, we clear the grammar and add some of our new <code>ForbidConsecutive</code> constraints.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    clearconstraints!(grammar)\n\n    addconstraint!(grammar, ForbidConsecutive(minus))\n    addconstraint!(grammar, ForbidConsecutive(plus))\n    addconstraint!(grammar, ForbidConsecutive(times))\n    addconstraint!(grammar, ForbidConsecutive(plus))\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>The last constraint we try to add is ignored - it already exists.</p><p>Finally we enumerate the programs that satisfy the constraints.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    iter = BFSIterator(grammar, :Int, max_size=6)\n\n    for program âˆˆ iter\n        println(rulenode2expr(program, grammar))\n    end\nend\n</code></pre>\n\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/getting_started_with_constraints/","page":"Getting started with Constraints","title":"Getting started with Constraints","text":"","category":"page"},{"location":"HerbInterpret/#HerbInterpret_docs","page":"HerbInterpret.jl","title":"HerbInterpret.jl Documentation","text":"","category":"section"},{"location":"HerbInterpret/#HerbInterpret.evaluate_program-Tuple{RuleNode, Vector{<:IOExample}, AbstractGrammar, Function}","page":"HerbInterpret.jl","title":"HerbInterpret.evaluate_program","text":"evaluate_program(program::RuleNode, examples::Vector{<:IOExample}, grammar::AbstractGrammar, evaluation_function::Function)\n\nRuns a program on the examples and returns tuples of actual desired output and the program's output\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{AbstractGrammar, RuleNode, Dict{Symbol, T}}} where T","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_input","text":"execute_on_input(grammar::AbstractGrammar, program::RuleNode, input::Dict{Symbol, T})::Any where T\n\nConverts a RuleNode program into an expression using a given grammar, then evaluates this expression with a single input dictionary input and a symbol table derived from the grammar using execute_on_input(tab::SymbolTable, expr::Any, input::Dict{Symbol, T}).\n\nArguments\n\ngrammar::AbstractGrammar: A grammar object used to convert the RuleNode into an executable expression.\nprogram::RuleNode: The program, represented as a RuleNode, to be converted and evaluated.\ninput::Dict{Symbol, T}: A dictionary providing input values for symbols used in the generated expression.\n\nReturns\n\nAny: The result of evaluating the generated expression with the given input dictionary.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{AbstractGrammar, RuleNode, Vector{T}}} where T<:(Dict{Symbol})","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_input","text":"execute_on_input(grammar::AbstractGrammar, program::RuleNode, input::Vector{T})::Vector{Any} where T <: Dict{Symbol, <:Any}\n\nConverts a RuleNode program into an expression using a given grammar, then evaluates this expression for each input dictionary in a vector input and a symbol table derived from the grammar using execute_on_input(tab::SymbolTable, expr::Any, input::Dict{Symbol, T}).\n\nArguments\n\ngrammar::AbstractGrammar: A grammar object used to convert the RuleNode into an executable expression.\nprogram::RuleNode: The program, represented as a RuleNode, to be converted and evaluated.\ninput::Vector{T}: A vector of dictionaries, each providing input values for symbols used in the generated expression.\n\nReturns\n\nVector{Any}: A vector containing the results of evaluating the generated expression for each input dictionary.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{Dict{Symbol, Any}, Any, Dict{Symbol, T}}} where T","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_input","text":"execute_on_input(tab::SymbolTable, expr::Any, input::Dict{Symbol, T})::Any where T\n\nEvaluates an expression expr within the context of a symbol table tab and a single input dictionary input.  The input dictionary keys should match the symbols used in the expression, and their values are used during the expression's evaluation.\n\nArguments\n\ntab::SymbolTable: A symbol table containing predefined symbols and their associated values or functions.\nexpr::Any: The expression to be evaluated. Can be any Julia expression that is valid within the context of the provided symbol table and input.\ninput::Dict{Symbol, T}: A dictionary where each key is a symbol used in the expression, and the value is the corresponding value to be used in the expression's evaluation. The type T can be any type.\n\nReturns\n\nAny: The result of evaluating the expression with the given symbol table and input dictionary.\n\nwarning: Warning\nThis function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{Dict{Symbol, Any}, Any, Vector{T}}} where T<:(Dict{Symbol})","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_input","text":"execute_on_input(tab::SymbolTable, expr::Any, input::Vector{T})::Vector{<:Any} where T <: Dict{Symbol, <:Any}\n\nWrapper around execute_on_input to execute all inputs given as an array.\n\nArguments\n\ntab::SymbolTable: A symbol table containing predefined symbols and their associated values or functions.\nexpr::Any: The expression to be evaluated for each input dictionary.\ninputs::Vector{T}: A vector of dictionaries, each serving as an individual set of inputs for the expression's evaluation.\n\nReturns\n\nVector{<:Any}: A vector containing the results of evaluating the expression for each input dictionary.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.interpret-Tuple{Dict{Symbol, Any}, Any}","page":"HerbInterpret.jl","title":"HerbInterpret.interpret","text":"interpret(tab::SymbolTable, ex::Expr)\n\nEvaluates an expression without compiling it. Uses AST and symbol lookups. Only supports :call and :(=) expressions at the moment.\n\nExample usage:\n\ntab = SymbolTable(:f => f, :x => x)\nex = :(f(x))\ninterpret(tab, ex)\n\nWARNING: This function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#Index","page":"HerbInterpret.jl","title":"Index","text":"","category":"section"},{"location":"HerbInterpret/","page":"HerbInterpret.jl","title":"HerbInterpret.jl","text":"","category":"page"},{"location":"HerbInterpret/","page":"HerbInterpret.jl","title":"HerbInterpret.jl","text":"","category":"page"},{"location":"tutorials/getting_started_with_herb/","page":"A more verbose getting started with Herb.jl","title":"A more verbose getting started with Herb.jl","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"74081b246d2c5fdeef22efe8bc19981132264ac6cd2cafa35a46b6c35da4ca8d\"\n    julia_version = \"1.12.1\"\n-->\n\n<div class=\"markdown\"><h1 id=\"Search\">Search</h1><p>This notebook describes how you can search a program space as defined by a grammar. Specifically, we will look at example-based search, where the goal is to find a program that is able to transform the inputs of every example to the corresponding output.</p></div>\n\n\n<div class=\"markdown\"><h3 id=\"Setup\">Setup</h3><p>First, we start with the setup. We need access to all the function in the Herb.jl framework.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    import Pkg\n    Pkg.activate(Base.current_project())\n    Pkg.instantiate()\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><h3 id=\"Defining-the-program-space\">Defining the program space</h3><p>Next, we start by creating a grammar. We define a context-free grammar as a <a href=\"@ref\"><code>HerbGrammar.ContextSpecificGrammar</code></a> without any constraints. A context-free grammar is just a simple set of production rules for defining combinations of terminal symbols (in our case integers). </p><p>Alternatively we could define a context-sensitive grammar, when the production rules only hold in a certain context. For more information on this, please see our tutorial on <a href=\"defining_grammars.md\">defining grammars</a>.</p><p>For now, we specify a simple grammar (using the <code>@csgrammar</code> macro) for dealing with integers and explain all the rules individually:</p><ol><li><p>First, we specify our number values and constrain them to being positive even integers.</p></li><li><p>Then, we can also use the variable <code>x</code> to hold an integer.</p></li><li><p>The third rule determines we can add two integers.</p></li><li><p>The fourth rule determines we can subtract an integer from another.</p></li><li><p>Finally, we also allow the multiplication of two integers.</p></li></ol><p>If you run this cell, you can see all the rules rolled out.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g = HerbGrammar.@csgrammar begin\n    Number = 0 | 2 | 4 | 6 | 8\n    Number = x\n    Number = Number + Number\n    Number = Number - Number\n    Number = Number * Number\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g\">1: Number = 0\n2: Number = 2\n3: Number = 4\n4: Number = 6\n5: Number = 8\n6: Number = x\n7: Number = Number + Number\n8: Number = Number - Number\n9: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Defining-the-problem\">Defining the problem</h3></div>\n\n\n<div class=\"markdown\"><p>As mentioned before, we are looking at example-based search.  This means that the problem is defined by a set of input-output examples.  A single example hence consists of an input and an output. The input is defined as a dictionary, with a value assigned to each variable in the grammar. It is important to write the variable name as a <code>Symbol</code> instead of a string. A <code>Symbol</code> in Julia is written with a colon prefix, i.e. <code>:x</code>.  The output of the input-output example is just a single value for this specific grammar, but could possibly relate to e.g. arrays of values, too.</p><p>In the cell below we automatically generate some examples for <code>x</code> assigning values <code>1-5</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'># Create input-output examples\nexamples = [HerbSpecification.IOExample(Dict(:x =&gt; x), 4x + 6) for x âˆˆ 1:5]</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-examples\">5-element Vector{IOExample{Int64, Int64}}:\n IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10)\n IOExample{Int64, Int64}(Dict(:x =&gt; 2), 14)\n IOExample{Int64, Int64}(Dict(:x =&gt; 3), 18)\n IOExample{Int64, Int64}(Dict(:x =&gt; 4), 22)\n IOExample{Int64, Int64}(Dict(:x =&gt; 5), 26)</pre>\n\n\n<div class=\"markdown\"><p>Now that we have some input-output examples, we can define the problem.  Next to the examples, a problem also contains a name meant to link to the file path, which can be used to keep track of current examples.  For now, this is irrelevant, and you can give the program any name you like.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>problem_1 = HerbSpecification.Problem(\"example\", examples)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-problem_1\">Problem{Vector{IOExample{Int64, Int64}}}(\"example\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 10), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 14), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 18), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 22), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 26)])</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Connecting-grammar-and-problem-specification\">Connecting grammar and problem specification</h3><p>For the search to produce programs that use the input examples, we need to ensure that there is a rule where the right-hand side matches the symbol used in the input to the <code>IOExample</code>. For an example like <code>IOExample(Dict(:x =&gt; 1), 2)</code>, there must be some rule like <code>Number = x</code>â€“the <code>x</code>'s must match, otherwise the input value will never be used in any of the programs. If you have multiple input arguments, like <code>IOExample(Dict(:x =&gt; 1, :name =&gt; \"Alice\", \"1. Alice\"))</code>, then you need two rules, such as <code>Number = x</code> and <code>String = name</code>, to construct programs that use both inputs. If these rules don't exist yet, they need to be added (see the tutorial on <a href=\".defining_grammars.md\">Defining Grammars in Herb.jl</a> to learn how to add rules). </p></div>\n\n\n<div class=\"markdown\"><h3 id=\"Searching\">Searching</h3><p>Now that we have defined the search space and the goal of the search, we can start the search. </p><p>Of course, our problem is underdefined as there might be multiple programs that satisfy our examples.  Let us consider the case where we also have a ternary if-then-else operator and standard boolean operators in our grammar: we could synthesize the program <code>x â‰¤ 5 ? 3x+5 : 0</code>.  This program satisfies all our examples, but we don't expect it to generalize very well.</p><p>To search through a program space, we first need to define a <a href=\"@ref\"><code>HerbSearch.ProgramIterator</code></a>, which can be instantiated with different iterators, for now we use a simple <a href=\"@ref\"><code>HerbSearch.BFSIterator</code></a>. For more advanced search methods check out our tutorial on <a href=\".advanced_search.md\">advanced search</a>. For more information about iterators, check out our tutorial on <a href=\".working_with_interpreters.md\">working with interpreters</a>. </p><p>In general, we assume that a smaller program is more general than a larger program.  Therefore, we search for the smallest program in our grammar that satisfies our examples.  This can be done using a breadth-first search over the program/search space.</p><p>This search is very basic; it makes use of an enumeration technique, where we enumerate programs one-by-one until we find a program that matches our examples. The search procedure has a built-in default evaluator to verify the candidate programs with the given input. The search procedure also has a built-in search procedure using breadth-first search. </p><p>So, we only need to give our grammar and the problem to our search procedure, along with a starting <code>Symbol</code>, in our case a <code>Number</code>. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator_1 = BFSIterator(g, :Number)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator_1\">BFSIterator(GenericSolver(1: Number = 0\n2: Number = 2\n3: Number = 4\n4: Number = 6\n5: Number = 8\n6: Number = x\n7: Number = Number + Number\n8: Number = Number - Number\n9: Number = Number * Number\n, SolverState(Hole[Bool[1, 1, 1, 1, 1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 9223372036854775807))</pre>\n\n<pre class='language-julia'><code class='language-julia'>synth(problem_1, iterator_1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash471578\">(7{4,9{3,6}}, optimal_program)</pre>\n\n\n<div class=\"markdown\"><p>As you can see, the search procedure found the correct program!</p></div>\n\n\n<div class=\"markdown\"><h3 id=\"Defining-the-search-procedure\">Defining the search procedure</h3><p>In the previous case, we used the built-ins of the search procedure. However, we can also give a custom enumerator to the search procedure and define a few more values.</p><p>We first define a new problem to test with, we are looking for the programs that can compute the value <code>168</code>. We immediately pass the examples to the problem and then set up the new search.</p><p>Search is done by passing the grammar, the problem and the starting point like before. We now also specify the enumeration function to be used, and now we use depth-first search. Then, we give the maximum depth of the programs we want to search for <code>(3)</code>, the maximum number of nodes in the Abstract Syntax Tree that exists during search <code>(10)</code>, and the maximum time in seconds allowed for the search.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    problem_2 = HerbSpecification.Problem(\"example2\", [HerbSpecification.IOExample(Dict(:x =&gt; x), 168) for x âˆˆ 1:5])\n    iterator_2 = HerbSearch.BFSIterator(g, :Number, max_depth=4, max_size=30)\n    expr_2, flag_2 = HerbSearch.synth(problem_2, iterator_2)\n    println(expr_2)\n    program_2 = rulenode2expr(expr_2, g)\n    println(program_2)\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>We see that our synthesizer can find a program to construct the value <code>168</code>, though a fun experiment would be trying to get the value <code>167</code>, what do you think would happen? You can try below, using the same iterator.</p><p>In any case, this concludes our first introduction to the <code>Herb.jl</code> program synthesis framework. You can see more examples in this repository, or explore yourself. Enjoy!</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    problem_3 = HerbSpecification.Problem(\"example3\", [HerbSpecification.IOExample(Dict(:x =&gt; x), 167) for x âˆˆ 1:5])\n    expr_3, flag_3 = HerbSearch.synth(problem_3, iterator_2)\n    println(expr_3)\n    program_3 = rulenode2expr(expr_3, g)\n    println(program_3)\nend</code></pre>\n\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/getting_started_with_herb/","page":"A more verbose getting started with Herb.jl","title":"A more verbose getting started with Herb.jl","text":"","category":"page"},{"location":"tutorials/defining_grammars/","page":"Defining Grammars in Herb.jl","title":"Defining Grammars in Herb.jl","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"f62aa46b1a328ec1e9ba7bd2f09d208c77e0312379fc61adccd9a2ad2963b99f\"\n    julia_version = \"1.12.1\"\n-->\n\n<div class=\"markdown\"><h1 id=\"Defining-Grammars-in-Herb.jl-using-HerbGrammar\">Defining Grammars in Herb.jl using HerbGrammar</h1><p>The program space in Herb.jl is defined using a grammar.  This notebook demonstrates how such a grammar can be created.  There are multiple kinds of grammars, but they can all be defined in a very similar way.</p></div>\n\n\n<div class=\"markdown\"><h3 id=\"Setup\">Setup</h3><p>First, we import the necessary Herb packages.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    import Pkg\n    Pkg.activate(Base.current_project())\n    Pkg.instantiate()\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><h3 id=\"Creating-a-simple-grammar\">Creating a simple grammar</h3><p>This cell contains a very simple arithmetic grammar.  The grammar is defined using the <code>@csgrammar</code> macro.  This macro converts the grammar definition in the form of a Julia expression into Herb's internal grammar representation.  Macro's are executed during compilation. If you want to load a grammar during execution, have a look at the <code>HerbGrammar.expr2csgrammar</code> function.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>gâ‚ = HerbGrammar.@csgrammar begin\n    Int = 1\n    Int = 2\n    Int = 3\n    Int = Int * Int\n    Int = Int + Int\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-gâ‚\">1: Int = 1\n2: Int = 2\n3: Int = 3\n4: Int = Int * Int\n5: Int = Int + Int\n</pre>\n\n\n<div class=\"markdown\"><p>Defining every integer one-by-one can be quite tedious. Therefore, it is also possible to use the following syntax that makes use of a Julia iterator:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>gâ‚‚ = HerbGrammar.@csgrammar begin\n    Int = |(0:9)\n    Int = Int * Int\n    Int = Int + Int\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-gâ‚‚\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = Int + Int\n</pre>\n\n\n<div class=\"markdown\"><p>You can do the same with lists:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>gâ‚ƒ = HerbGrammar.@csgrammar begin\n    Int = |([0, 2, 4, 6, 8])\n    Int = Int * Int\n    Int = Int + Int\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-gâ‚ƒ\">1: Int = 0\n2: Int = 2\n3: Int = 4\n4: Int = 6\n5: Int = 8\n6: Int = Int * Int\n7: Int = Int + Int\n</pre>\n\n\n<div class=\"markdown\"><p>Variables can also be added to the grammar by just using the variable name:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>gâ‚„ = HerbGrammar.@csgrammar begin\n    Int = |(0:9)\n    Int = Int * Int\n    Int = Int + Int\n    Int = x\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-gâ‚„\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = Int + Int\n13: Int = x\n</pre>\n\n\n<div class=\"markdown\"><p>Grammars can also work with functions.  After all, <code>+</code> and <code>*</code> are just infix operators for Julia's identically-named functions. You can use functions that are provided by Julia, or functions that you wrote yourself:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    f(a) = a + 1\n    \n    gâ‚… = HerbGrammar.@csgrammar begin\n        Int = |(0:9)\n        Int = Int * Int\n        Int = Int + Int\n        Int = f(Int)\n        Int = x\n    end\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-f\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = Int + Int\n13: Int = f(Int)\n14: Int = x\n</pre>\n\n\n<div class=\"markdown\"><p>Similarly, we can also define the operator times (x) manually.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    Ã—(a, b) = a * b\n    \n    gâ‚† = HerbGrammar.@csgrammar begin\n        Int = |(0:9)\n        Int = a\n        Int = Int + Int\n        Int = Int Ã— Int\n    end\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-gâ‚†\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = a\n12: Int = Int + Int\n13: Int = Int Ã— Int\n</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Working-with-grammars\">Working with grammars</h3><p>If you want to implement something using these grammars, it is useful to know about the functions that you can use to manipulate grammars and extract information.  This section is not complete, but it aims to give an overview of the most important functions. </p><p>It is recommended to also read up on <a href=\"https://docs.julialang.org/en/v1/manual/metaprogramming/\">Julia metaprogramming</a> if you are not already familiar with the concept.</p><p>One of the most important things about grammars is that each rule has an index associated with it:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    gâ‚‡ = HerbGrammar.@csgrammar begin\n        Int = |(0:9)\n        Int = Int + Int\n        Int = Int * Int\n        Int = x\n    end\n    \n    collect(enumerate(gâ‚‡.rules))\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-gâ‚‡\">13-element Vector{Tuple{Int64, Any}}:\n (1, 0)\n (2, 1)\n (3, 2)\n (4, 3)\n (5, 4)\n (6, 5)\n (7, 6)\n (8, 7)\n (9, 8)\n (10, 9)\n (11, :(Int + Int))\n (12, :(Int * Int))\n (13, :x)</pre>\n\n\n<div class=\"markdown\"><p>We can use this index to extract information from the grammar.</p></div>\n\n\n<div class=\"markdown\"><h3 id=\"isterminal\">isterminal</h3><p><code>isterminal</code> returns <code>true</code> if a rule is terminal, i.e. it cannot be expanded. For example, rule 1 is terminal, but rule 11 is not, since it contains the non-terminal symbol <code>:Int</code>. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.isterminal(gâ‚‡, 1)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash594982\">true</pre>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.isterminal(gâ‚‡, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash518469\">false</pre>\n\n\n<div class=\"markdown\"><h3 id=\"return_type\">return_type</h3><p>This function is rather obvious; it returns the non-terminal symbol that corresponds to a certain rule. The return type for all rules in our grammar is <code>:Int</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.return_type(gâ‚‡, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash167108\">:Int</pre>\n\n\n<div class=\"markdown\"><h3 id=\"child_types\">child_types</h3><p><code>child_types</code> returns the types of the nonterminal children of a rule in a vector. If you just want to know how many children a rule has, and not necessarily which types they have, you can use <code>nchildren</code></p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.child_types(gâ‚‡, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash141241\">2-element Vector{Symbol}:\n :Int\n :Int</pre>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.nchildren(gâ‚‡, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash151878\">2</pre>\n\n\n<div class=\"markdown\"><h3 id=\"nonterminals\">nonterminals</h3><p>The <code>nonterminals</code> function can be used to obtain a list of all nonterminals in the grammar.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.nonterminals(gâ‚‡)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash115023\">1-element Vector{Symbol}:\n :Int</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Adding-rules\">Adding rules</h3><p>It is also possible to add rules to a grammar during execution. This can be done using the <code>add_rule!</code> function. The exclamation mark is a Julia convention and is appended to name if a function modifies its arguments (in our example the grammar).</p><p>A rule can be provided in the same syntax as is used in the grammar definition. The rule should be of the <code>Expr</code> type, which is a built-in type for representing expressions.  An easy way of creating <code>Expr</code> values in Julia is to encapsulate it in brackets and use a colon as prefix:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.add_rule!(gâ‚‡, :(Int = Int - Int))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash700556\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n14: Int = Int - Int\n</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Removing-rules\">Removing rules</h3><p>It is also possible to remove rules in Herb.jl, however, this is a bit more involved.  As said before, rules have an index associated with them.  The internal representation of programs that are defined by the grammar makes use of those indices for efficiency. Blindly removing a rule would shift the indices of other rules, and this could mean that existing programs get a different meaning or become invalid. </p><p>Therefore, there are two functions for removing rules:</p><ul><li><p><code>remove_rule!</code> removes a rule from the grammar, but fills its place with a placeholder. Therefore, the indices stay the same, and only programs that use the removed rule become invalid.</p></li><li><p><code>cleanup_removed_rules!</code> removes all placeholders and shifts the indices of the other rules.</p></li></ul></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.remove_rule!(gâ‚‡, 11)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash501182\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: nothing = nothing\n12: Int = Int * Int\n13: Int = x\n14: Int = Int - Int\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.cleanup_removed_rules!(gâ‚‡)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash168833\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = x\n13: Int = Int - Int\n</pre>\n\n\n<div class=\"markdown\"><h2 id=\"Context-sensitive-grammars\">Context-sensitive grammars</h2><p>Context-sensitive grammars introduce additional constraints compared to context-free grammars (like the simple grammar examples above). As before, we use the <code>@csgrammar</code> macro:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>gâ‚ˆ = HerbGrammar.@csgrammar begin\n    Int = |(0:9)\n    Int = Int + Int\n    Int = Int * Int\n    Int = x\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-gâ‚ˆ\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n</pre>\n\n\n<div class=\"markdown\"><p>Constraints can be added using the <code>addconstraint!</code> function, which takes a context-sensitive grammar and a constraint and adds the constraint to the grammar.</p><p>For example, we can add a `<code>constraint to enforce that the input symbol</code>x` (rule 13) appears at least once in the program, to avoid programs that are just a constant.  </p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.addconstraint!(gâ‚ˆ, Contains(13))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash105069\">1-element Vector{AbstractConstraint}:\n Contains(13)</pre>\n\n\n<div class=\"markdown\"><p>There is a dedicated tutorial for constraints in Herb.jl and how to work with them.</p></div>\n\n\n<div class=\"markdown\"><h3 id=\"Probabilistic-grammars\">Probabilistic grammars</h3><p>Herb.jl also supports probabilistic grammars.  These grammars allow the user to assign a probability to each rule in the grammar. A probabilistic grammar can be defined in a very similar way to a standard grammar, but has some slightly different syntax:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    gâ‚‰ = HerbGrammar.@pcsgrammar begin\n        0.4 : Int = |(0:9)\n        0.2 : Int = Int + Int\n        0.1 : Int = Int * Int\n        0.3 : Int = x\n    end\n    \n    for r âˆˆ 1:length(gâ‚ƒ.rules)\n        p = HerbGrammar.probability(gâ‚ˆ, r)\n    \n        println(\"$p : $r\")\n    end\nend</code></pre>\n\n\n\n<div class=\"markdown\"><p>The numbers before each rule represent the probability assigned to that rule. The total probability for each return type should add up to 1.0. If this isn't the case, Herb.jl will normalize the probabilities.</p><p>If a single line in the grammar definition represents multiple rules, such as <code>0.4 : Int = |(0:9)</code>, the probability will be evenly divided over all these rules.</p></div>\n\n\n<div class=\"markdown\"><h2 id=\"File-writing\">File writing</h2><h3 id=\"Saving-&amp;-loading-context-free-grammars\">Saving &amp; loading context-free grammars</h3><p>If you want to store a grammar on the disk, you can use the <code>store_csg</code>, <code>read_csg</code> and functions to store and read grammars respectively.  The <code>store_csg</code> grammar can also be used to store probabilistic grammars. To read probabilistic grammars, use <code>read_pcsg</code>. The stored grammar files can also be opened using a text editor to be modified, as long as the contents of the file doesn't violate the syntax for defining grammars.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.store_csg(gâ‚‡, \"demo.txt\")</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.read_csg(\"demo.txt\")</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash174505\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int * Int\n12: Int = x\n13: Int = Int - Int\n</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Saving-&amp;-loading-context-sensitive-grammars\">Saving &amp; loading context-sensitive grammars</h3><p>Saving and loading context-sensitive grammars is very similar to how it is done with context-free grammars. The only difference is that an additional file is created for the constraints.  The file that contains the grammars can be edited and can also be read using the reader for context-free grammars. The file that contains the constraints cannot be edited.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>HerbGrammar.store_csg( gâ‚ˆ, \"demo.grammar\", \"demo.constraints\")</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>gâ‚ˆ, gâ‚ˆ.constraints</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash136301\">(1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n, AbstractConstraint[Contains(13)])</pre>\n\n<pre class='language-julia'><code class='language-julia'>gâ‚â‚€  = HerbGrammar.read_csg(\"demo.grammar\", \"demo.constraints\")</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-gâ‚â‚€\">1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n</pre>\n\n<pre class='language-julia'><code class='language-julia'>gâ‚â‚€, gâ‚â‚€.constraints</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash688383\">(1: Int = 0\n2: Int = 1\n3: Int = 2\n4: Int = 3\n5: Int = 4\n6: Int = 5\n7: Int = 6\n8: Int = 7\n9: Int = 8\n10: Int = 9\n11: Int = Int + Int\n12: Int = Int * Int\n13: Int = x\n, AbstractConstraint[Contains(13)])</pre>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/defining_grammars/","page":"Defining Grammars in Herb.jl","title":"Defining Grammars in Herb.jl","text":"","category":"page"},{"location":"tutorials/TopDown/#Building-Herb-Iterators","page":"Top Down Iterator","title":"Building Herb Iterators","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The core building block in Herb is a program iterator. A program iterator represents a walk through the program space; different iterators provide different ways of iterating through program space.  From the program synthesis point of view, program iterators actually represent program spaces.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"    flowchart TD\n    id1((13)) ---\n    id2((6))\n    id1 --- id3((12))\n    id4((11))\n    id5((4))\n    id3 --- id4\n    id3 --- id5","category":"page"},{"location":"tutorials/TopDown/#Iterator-hierarchy","page":"Top Down Iterator","title":"Iterator hierarchy","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Program iterators are organised in a hierarchy. The top-level abstract type is ProgramIterator.  At the next level of the hierarchy lie commonly used search families:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"TopDownIterator for top-down traversals\nStochasticSearachIterator for traversals with stochastic search\nBottomUpIterator for bottom-up search","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Stochastic search further provides specific iterators:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"MHSearchIterator for program traversal with Metropolis-Hastings algorithm\nVLNSearchIterator for traversals with Very Large Neighbourhood Search\nSASearchIterator for Simulated Annealing","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"We provide generic and customisable implementations of each of these iterators, so that users can easily tweak them by through multiple dispatch. Keep reading!","category":"page"},{"location":"tutorials/TopDown/#Iterator-design","page":"Top Down Iterator","title":"Iterator design","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Program iterators follow the standard Julia Iterator interface. That is, every iterator should implement two functions:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"iterate(<:ProgramIterator)::(RuleNode,Any) to get the first program. The function takes a program iterator as an input, returning the first program and a state (which can be anything)\niterate(<:ProgramIterator,Any)::(RuleNode,Any) to get the consecutive programs. The function takes the program iterator and the state from the previous iteration, and return the next program and the next state.","category":"page"},{"location":"tutorials/TopDown/#Top-Down-iterator","page":"Top Down Iterator","title":"Top Down iterator","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"We illustrate how to build iterators with a Top Down iterator. The top Down iterator is build as a best-first iterator: it maintains a priority queue of programs and always pops the first element of the queue.  The iterator is customisable through the following functions:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"priority_function: dictating the order of programs in the priority queue\nderivation_heuristic: dictating in which order to explore the derivations rules within a single hole\nhole_heuristic: dictating which hole to expand next","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The first call to iterate(iter::TopDownIterator):","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"function Base.iterate(iter::TopDownIterator)\n    # Priority queue with `SolverState`s (for variable shaped trees) and `UniformIterator`s (for fixed shaped trees)\n    pq :: PriorityQueue{Union{SolverState, UniformIterator}, Union{Real, Tuple{Vararg{Real}}}} = PriorityQueue()\n\n    solver = iter.solver\n\n    if isfeasible(solver)\n        enqueue!(pq, get_state(solver), priority_function(iter, get_grammar(solver), get_tree(solver), 0, false))\n    end\n    return _find_next_complete_tree(iter.solver, pq, iter)\nend","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The first call steps everything up: it initiates the priority queue, the constraint solver (more on that later), and return the first program. The function _find_next_complete_tree(iter.solver, pq, iter) does a lot of heavy lifting here; we will cover it later, but the only important thing is that it finds the next complete program in the priority queue (because, in case of top down enumeration, the queue also contains partial programs which we only want to expand, but not return to the user).","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The subsequent call to iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue) are quite simple: all that is needed is to find the next complete program in the priority queue:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"function Base.iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue)\n    return _find_next_complete_tree(iter.solver, pq, iter)\nend","category":"page"},{"location":"tutorials/TopDown/#Modifying-the-provided-iterator","page":"Top Down Iterator","title":"Modifying the provided iterator","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"If you would like to, for example, modify the priority function, you don't have to implement the iterator from scratch. You simply need to create a new type and inherit from the TopDownIterator:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"abstract type MyTopDown <: TopDownIterator end.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"What is left is to implement the priority function, multiple-dispatching it over the new type.  For example, to do a random order:","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"function priority_function(\n    ::MyTopDown, \n    ::AbstractGrammar, \n    ::AbstractRuleNode, \n    ::Union{Real, Tuple{Vararg{Real}}},\n    ::Bool\n)\n    Random.rand();\nend","category":"page"},{"location":"tutorials/TopDown/#A-note-on-data-structures","page":"Top Down Iterator","title":"A note on data structures","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"As you have probably noticed, the priority queue some strange data structures: SolverState and UniformIterator; the top down iterator never puts RuleNodes into the queue. In fact, the iterator never directly manipulates RuleNodes itself, but that is rather delegated to the constraint solver. The constraint solver will do a lot of work to reduce the number of programs we have to consider. The SolverState and UniformIterator are specialised data structure to improve the efficiency and memory usage. ","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Herb uses a data structure of UniformTrees to represent all programs with an AST of the same shape, where each node has the same type. the UniformIterator is an iterator efficiently iterating over that structure.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"The SolverState represents non-uniform trees â€“ ASTs whose shape we haven't completely determined yet. SolverState is used as an intermediate representation before we reach UniformTrees on which partial constraint propagation is done.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"In principle, you should never construct ASTs yourself directly; you should leave that to the constraint solver.","category":"page"},{"location":"tutorials/TopDown/#Extra:-Find-Next-Complete-Tree-/-Program","page":"Top Down Iterator","title":"Extra: Find Next Complete Tree / Program","text":"","category":"section"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"This function pops an element from the priority queue whilst it is not empty, and then checks what kind of iterator it is.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"function _find_next_complete_tree(\n    solver::Solver,\n    pq::PriorityQueue,\n    iter::TopDownIterator\n)\n    while length(pq) â‰  0\n        (item, priority_value) = dequeue_pair!(pq)\n","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"If it is a Uniform Iterator, that is an iterator where all the holes have the same shape, then it iterates over the solutions.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"\n        if item isa UniformIterator\n            #the item is a fixed shaped solver, we should get the next solution and re-enqueue it with a new priority value\n            uniform_iterator = item\n            solution = next_solution!(uniform_iterator)\n            if !isnothing(solution)\n                enqueue!(pq, uniform_iterator, priority_function(iter, get_grammar(solver), solution, priority_value, true))\n                return (solution, pq)\n            end\n","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"If it is not a Uniform Iterator, we find a hole to branch on. If the holes are all uniform, a Uniform Iterator is created, and is enqueued. If iterating on the holes would exceed a maximum depth, nothing new is enqueued. Lastly, if the holes aren't the same shape, we branch / partition on the holes, to create new partial domains to enqueue.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"        elseif item isa SolverState\n            #the item is a solver state, we should find a variable shaped hole to branch on\n            state = item\n            load_state!(solver, state)\n\n            hole_res = hole_heuristic(iter, get_tree(solver), get_max_depth(solver))\n            if hole_res â‰¡ already_complete\n                uniform_solver = UniformSolver(get_grammar(solver), get_tree(solver), with_statistics=solver.statistics)\n                uniform_iterator = UniformIterator(uniform_solver, iter)\n                solution = next_solution!(uniform_iterator)\n                if !isnothing(solution)\n                    enqueue!(pq, uniform_iterator, priority_function(iter, get_grammar(solver), solution, priority_value, true))\n                    return (solution, pq)\n                end\n            elseif hole_res â‰¡ limit_reached\n                # The maximum depth is reached\n                continue\n            elseif hole_res isa HoleReference\n                # Variable Shaped Hole was found\n                (; hole, path) = hole_res\n        \n                partitioned_domains = partition(hole, get_grammar(solver))\n                number_of_domains = length(partitioned_domains)\n                for (i, domain) âˆˆ enumerate(partitioned_domains)\n                    if i < number_of_domains\n                        state = save_state!(solver)\n                    end\n                    @assert isfeasible(solver) \"Attempting to expand an infeasible tree: $(get_tree(solver))\"\n                    remove_all_but!(solver, path, domain)\n                    if isfeasible(solver)\n                        enqueue!(pq, get_state(solver), priority_function(iter, get_grammar(solver), get_tree(solver), priority_value, false))\n                    end\n                    if i < number_of_domains\n                        load_state!(solver, state)\n                    end\n                end\n            end\n\n","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"Otherwise, throw an exception, because we came across an unexpected iterator type.","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"        else\n            throw(\"BadArgument: PriorityQueue contains an item of unexpected type '$(typeof(item))'\")\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/TopDown/","page":"Top Down Iterator","title":"Top Down Iterator","text":"","category":"page"},{"location":"other/grammar_example/#Defining-complex-grammars","page":"-","title":"Defining complex grammars","text":"","category":"section"},{"location":"other/grammar_example/","page":"-","title":"-","text":"The Julia meta programming should allow for arbitrary complex grammars. Let's look at an example where we define while loops, conditionals and use user-defined functions in our programs.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"The whole code is below","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"using HerbGrammar \nusing HerbSearch # only used to sample random programs from the grammar\n\n# define a custom function \nfunction customfunction(x,y)\n    return x * x + y * y\nend\n\ncomplex_grammar = @csgrammar begin\n    # the starting symbol (does not necessary have be at the top of the grammar)\n    StartExpression = begin \n        x = Constant # initialize x to a constant\n        Expression   # run expression with x\n    end\n    # Number definition\n    Number = Constant\n    Constant = 1 | 2 | 3\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\n\n    # Expression definition\n    Expression = Number \n    Expression = customfunction(Number, Number)\n    Expression = println(Number) # use Julia's print function\n    Condition = BoolExpression | (BoolExpression && Condition) | (BoolExpression || Condition)\n    BoolExpression = (Number < Number) | (Number > Number) | (Number == Number)\n\n    # if condition\n    Expression = \n        if Condition \n            Expression\n        end \n    # if then else\n    Expression = \n        if Condition \n            Expression\n        else \n            Expression\n        end\n\n    Expression = WhileLoop\n    WhileLoop = while Condition \n                    Expression \n                end\n\nend\n\n\n# generate some random programs to see if they look good\nusing Random\nRandom.seed!(42)\nfor _ in 1:10\n    rulenode_program = rand(RuleNode, complex_grammar, :StartExpression)\n    # print program tree\n    println(\"Rulenode program: \", rulenode_program)\n    # convert prorgam tree to an expression\n    expression_program = rulenode2expr(rulenode_program, complex_grammar)\n    println(\"Program: \",  expression_program)\n    # WARNING: some programs will loop forever and you may need to stop julia\n    # println(\"Eval program: \", eval(expression)) \nend","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"The code is quite long and complex, but it shows that this way of defining grammars can be powerful. It is very important to note that everything on the right-hand side of the rule must be a valid Julia expression that can be parsed. This is the limitation that we are imposed when defining grammars like this. ","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"One example where one might encounter this limitation, is when trying to define boolean expressions as below.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"g = @csgrammar begin \n    number = 1  \n    boolexpr = number operator number \n    operator = < | > | ==\nend","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"This might be a valid approach in a BNF grammar for instance, but it will not work in Julia. Why?","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"Julia can't parse the expression number operator number. Since we are using the Julia's parser to implement our grammars, we have to comply to the parsing rules Julia has. Usually there is always a work around that will allow you to do what you want.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"For instance, this will work","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"g = @csgrammar begin \n    number = 1  \n    boolexpr = number < number | number > number | number == number\nend","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"You should also always check that the operator precedence that Julia uses matches your intent. You do not want to debug a grammar that does not work because Julia parses the expression on the right-hand side the way you do not want it to do. That's why it is good practice to add parenthesis () around your expressions when not sure about operator precedence.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"What I usually do is to sample from the grammar many expressions and check by looking at them to see if they are parsed properly.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"<details> <summary> Bonus question about grammars</summary> <br>","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"Are you up for a challenge? Well, since you opened the dropdown I assume you are :wink: ","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"Below is an incorrect grammar definition taken from some code written in Herb some time ago (it is slightly simplified).","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"Try to find the spot the bug :lady_beetle:. Good luck :+1: ","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"You can check the hints below if you get stuck.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"grammar_string = @cfgrammar begin\n    Start = (state = Init; Sequence; Return)\n    Init = initState(_arg_1)\n    Return = getString(state)\n\n    Sequence = Operation \n    Sequence = Operation; Sequence\n    Operation = Transformation \n    Operation = ControlStatement\n\n    Transformation = moveRight(state) | moveLeft(state) | makeUppercase(state) | makeLowercase(state) | drop(state)\n    ControlStatement = (Condition ? Sequence : Sequence) | (while Condition; Sequence; end)\n\n    Condition = atEnd(state) | notAtEnd(state) \nend","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"<details> <summary>Hint 1</summary> <br> Try to paste the grammar definition in a Julia REPL. Do you notice anything unusual? </details>","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"<details> <summary>Hint 2</summary> <br> Look at this grammar rule Sequence = Operation; Sequence and try to find it in the output. </details>","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"<details> <summary>Solution</summary> <br> The expression Operation; Sequence is not parsed as we want by Julia. Checking the output we can see that there are two identical rules.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"1: Start = begin\n    state = Init\n    Sequence\n    Return\nend\n2: Init = initState(_arg_1)\n3: Return = getString(state)\n4: Sequence = Operation\n5: Sequence = Operation  # is the same as the one on top\n6: Operation = Transformation\n// other rules\n13: ControlStatement = if Condition\n    Sequence\nelse\n    Sequence\nend","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"Adding parentheses around Operation; Sequence fixes the issue. Thus, Sequence = (Operation; Sequence) this is the correct way of writing the grammar. You can check by changing the grammar and looking at the output of the REPL.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"Also if you ask Julia to parse Sequence; Operation vs (Sequence; Operation) you will notice different results:","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"julia> Meta.parse(\"Operation; Sequence\")\n:($(Expr(:toplevel, :Operation, :Sequence))) # <- I have no idea what :toplevel means but it is not what we want most probably\n\njulia> Meta.parse(\"(Operation; Sequence)\")\nquote                    # this output looks good. It has one operation followed by another operation.\n    Operation\n    #= none:1 =# \n    Sequence\nend","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"Meta.parse is a function is Julia that allows you to see how a raw string is parsed as an expression. ","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"Meta-programming is hard in general. Hopefully you will be able to easily debug this kindof issues that you might encounter from now on.","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"</details>","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"</details>","category":"page"},{"location":"other/grammar_example/#Sum","page":"-","title":"Sum","text":"","category":"section"},{"location":"other/grammar_example/","page":"-","title":"-","text":"We have seen how to define grammars in Herb by use of the @csgrammar macro. The general syntax for a rule is RuleName -> some_julia_expr. The RuleName does not necessarily need to start with a capital case, it can be any identifier like expression (e.g., rule1, rule_with_underscore, etc.). However, it is nice to keep the convention that non-terminal rules start with capital rule (e.g. Number, Start) and terminal rules start with a lower case letter (e.g. x).","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"The HerbGrammar package also allows for the creation of constraints that can be enforced in the grammar. I am not knowledgeable enough to talk about them. I will leave to other contributors to better explain these concepts. ","category":"page"},{"location":"other/grammar_example/","page":"-","title":"-","text":"","category":"page"},{"location":"#[Herb.jl](https://github.com/Herb-AI/Herb.jl)","page":"Herb.jl","title":"Herb.jl","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"A library for defining and efficiently solving program synthesis tasks in Julia.","category":"page"},{"location":"#Why-Herb.jl?","page":"Herb.jl","title":"Why Herb.jl?","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"When writing research software we almost always investigate highly specific properties or algorithms of our domain, leading to us building the tools from scratch over and over again. The very same holds for the field of program synthesis: Tools are hard to run, benchmarks are hard to get and prepare, and it is hard to adapt our existing code to a novel idea.","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl will take care of this for you and helps you in defining, solving and extending your program synthesis problems.","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl provides...","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"a unified and universal framework for program synthesis\nHerb.jl allows you to describe all sorts of program synthesis problems using context-free grammars\na number of state-of-the-art benchmarks and solvers already implemented and usable out-of-the-box","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl's sub-packages provide fast and easily extendable implementations of ","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"various static and dynamic search strategies,\nlearning search strategies, sampling techniques and more,\nconstraint formulation and propagation, \neasy grammar formulation and usage,\nwide-range of usable program interpreters and languages + the possibility to use your own, and \nefficient data formulation.","category":"page"},{"location":"#Why-Julia?","page":"Herb.jl","title":"Why Julia?","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Julia is a perfect fit for program synthesis due to numerous reasons. Starting from scientific reasons like speed of execution and composability over to practical reasons like speed of writing Julia code. For a full ode on why to use Julia, please see the WhyJulia manifesto.","category":"page"},{"location":"#Sub-Modules","page":"Herb.jl","title":"Sub-Modules","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb's functionality is distributed among several sub-packages:","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"HerbCore.jl: The core of Herb.jl defining abstract concepts,\nHerbGrammar.jl: Functionality for declaring grammars,\nHerbSpecification.jl: For describing user intent as specifications,\nHerbInterpret.jl: For running programs in different languages and environments,\nHerbConstraints.jl: For defining and effectively propagating and managing constraints during search, and\nHerbSearch.jl: For actually searching for solutions.","category":"page"},{"location":"#Basics","page":"Herb.jl","title":"Basics","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Pages = [\"install.md\", \"get_started.md\", \"concepts.md\"]","category":"page"},{"location":"#Advanced-content","page":"Herb.jl","title":"Advanced content","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Pages = [p * \"/index.md\" for p in readdir(joinpath(dirname(@__FILE__), \"..\", \"src\")) if occursin(\"Herb\", p)]\nDepth = 1","category":"page"},{"location":"#Tutorials","page":"Herb.jl","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"To familiarize yourself with Herb, we have created several tutorials:","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"A more verbose getting started with Herb.jl\nDefining Grammars in Herb.jl\nAdvanced Search Procedures\nTop Down Iterator\nGetting started with Constraints\nWorking with custom interpreters\nAbstract Syntax Trees","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"","category":"page"},{"location":"tutorials/abstract_syntax_trees/","page":"Abstract Syntax Trees","title":"Abstract Syntax Trees","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"818b1b9ad49fe20cbe375d65480fc26c0f3f09cdf22c13d555f23d46d9df7201\"\n    julia_version = \"1.12.1\"\n-->\n\n<div class=\"markdown\"><h1 id=\"Herb-tutorial:-Abstract-syntax-trees\">Herb tutorial: Abstract syntax trees</h1></div>\n\n\n<div class=\"markdown\"><p>In this tutorial, you will learn</p><ul><li><p>How to represent a computer program as an abstract syntax tree  in Herb.</p></li><li><p>How to replace parts of the tree to modify the program.</p></li></ul></div>\n\n\n<div class=\"markdown\"><h2 id=\"Abstract-syntax-trees\">Abstract syntax trees</h2><p>The syntactic structure of a computer program can be represented in a hierarchical tree structure, a so-called <em>Abstract Syntax Tree (AST)</em>. The syntax of a programming language is typically defined using a formal grammar, a set of rules on how valid programs can be constructed. ASTs are derived from the grammar, but are abstractions in the sense that they omit details such as parenthesis, semicolons, etc. and only retain what's necessary to capture the program structure. </p><p>In the context of program synthesis, ASTs are often used to define the space of all possible programs which is searched to find one that satisfies the given specifications. During the search process, different ASTs, each corresponding to a different program, are generated and evaluated until a suitable one is found.</p><p>Each <em>node</em> of the AST represents a construct in the program (e.g., a variable, an operator, a statement, or a function) and this construct corresponds to a rule in the formal grammar.  An <em>edge</em> describes the relationship between constructs, and the tree structure captures the nesting of constructs. </p></div>\n\n\n<div class=\"markdown\"><h2 id=\"A-simple-example-program\">A simple example program</h2><p>We first consider the simple program 5*(x+3). We will define a grammar that is sufficient to represent this program and use it to construct a AST for our program.</p></div>\n\n\n<div class=\"markdown\"><h3 id=\"Define-the-grammar\">Define the grammar</h3></div>\n\n\n\n\n<pre class='language-julia'><code class='language-julia'>begin\n    import Pkg\n    Pkg.activate(Base.current_project())\n    Pkg.instantiate()\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>grammar = @csgrammar begin\n        Number = |(0:9)\n        Number = x\n        Number = Number + Number\n        Number = Number * Number\n    end</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grammar\">1: Number = 0\n2: Number = 1\n3: Number = 2\n4: Number = 3\n5: Number = 4\n6: Number = 5\n7: Number = 6\n8: Number = 7\n9: Number = 8\n10: Number = 9\n11: Number = x\n12: Number = Number + Number\n13: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Construct-the-syntax-tree\">Construct the syntax tree</h3></div>\n\n\n<div class=\"markdown\"><p>The AST of this program is shown in the diagram below. The number in each node refers to the index of the corresponding rule in our grammar. </p></div>\n\n\n<img src=\"data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0iZmxvd2NoYXJ0LXYyIiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgdmlld0JveD0iMCAwIDE1NC4yNTc4MTI1IDIwNC40MjE4NzUiIGhlaWdodD0iMjA0LjQyMTg3NSIgY2xhc3M9ImZsb3djaGFydCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTU0LjI1NzgxMjUiIGlkPSJjb250YWluZXIiPjxzdHlsZT4jY29udGFpbmVye2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTZweDtmaWxsOiMzMzM7fUBrZXlmcmFtZXMgZWRnZS1hbmltYXRpb24tZnJhbWV7ZnJvbXtzdHJva2UtZGFzaG9mZnNldDowO319QGtleWZyYW1lcyBkYXNoe3Rve3N0cm9rZS1kYXNob2Zmc2V0OjA7fX0jY29udGFpbmVyIC5lZGdlLWFuaW1hdGlvbi1zbG93e3N0cm9rZS1kYXNoYXJyYXk6OSw1IWltcG9ydGFudDtzdHJva2UtZGFzaG9mZnNldDo5MDA7YW5pbWF0aW9uOmRhc2ggNTBzIGxpbmVhciBpbmZpbml0ZTtzdHJva2UtbGluZWNhcDpyb3VuZDt9I2NvbnRhaW5lciAuZWRnZS1hbmltYXRpb24tZmFzdHtzdHJva2UtZGFzaGFycmF5OjksNSFpbXBvcnRhbnQ7c3Ryb2tlLWRhc2hvZmZzZXQ6OTAwO2FuaW1hdGlvbjpkYXNoIDIwcyBsaW5lYXIgaW5maW5pdGU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fSNjb250YWluZXIgLmVycm9yLWljb257ZmlsbDojNTUyMjIyO30jY29udGFpbmVyIC5lcnJvci10ZXh0e2ZpbGw6IzU1MjIyMjtzdHJva2U6IzU1MjIyMjt9I2NvbnRhaW5lciAuZWRnZS10aGlja25lc3Mtbm9ybWFse3N0cm9rZS13aWR0aDoxcHg7fSNjb250YWluZXIgLmVkZ2UtdGhpY2tuZXNzLXRoaWNre3N0cm9rZS13aWR0aDozLjVweDt9I2NvbnRhaW5lciAuZWRnZS1wYXR0ZXJuLXNvbGlke3N0cm9rZS1kYXNoYXJyYXk6MDt9I2NvbnRhaW5lciAuZWRnZS10aGlja25lc3MtaW52aXNpYmxle3N0cm9rZS13aWR0aDowO2ZpbGw6bm9uZTt9I2NvbnRhaW5lciAuZWRnZS1wYXR0ZXJuLWRhc2hlZHtzdHJva2UtZGFzaGFycmF5OjM7fSNjb250YWluZXIgLmVkZ2UtcGF0dGVybi1kb3R0ZWR7c3Ryb2tlLWRhc2hhcnJheToyO30jY29udGFpbmVyIC5tYXJrZXJ7ZmlsbDojMzMzMzMzO3N0cm9rZTojMzMzMzMzO30jY29udGFpbmVyIC5tYXJrZXIuY3Jvc3N7c3Ryb2tlOiMzMzMzMzM7fSNjb250YWluZXIgc3Zne2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTZweDt9I2NvbnRhaW5lciBwe21hcmdpbjowO30jY29udGFpbmVyIC5sYWJlbHtmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Y29sb3I6IzMzMzt9I2NvbnRhaW5lciAuY2x1c3Rlci1sYWJlbCB0ZXh0e2ZpbGw6IzMzMzt9I2NvbnRhaW5lciAuY2x1c3Rlci1sYWJlbCBzcGFue2NvbG9yOiMzMzM7fSNjb250YWluZXIgLmNsdXN0ZXItbGFiZWwgc3BhbiBwe2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7fSNjb250YWluZXIgLmxhYmVsIHRleHQsI2NvbnRhaW5lciBzcGFue2ZpbGw6IzMzMztjb2xvcjojMzMzO30jY29udGFpbmVyIC5ub2RlIHJlY3QsI2NvbnRhaW5lciAubm9kZSBjaXJjbGUsI2NvbnRhaW5lciAubm9kZSBlbGxpcHNlLCNjb250YWluZXIgLm5vZGUgcG9seWdvbiwjY29udGFpbmVyIC5ub2RlIHBhdGh7ZmlsbDojRUNFQ0ZGO3N0cm9rZTojOTM3MERCO3N0cm9rZS13aWR0aDoxcHg7fSNjb250YWluZXIgLnJvdWdoLW5vZGUgLmxhYmVsIHRleHQsI2NvbnRhaW5lciAubm9kZSAubGFiZWwgdGV4dCwjY29udGFpbmVyIC5pbWFnZS1zaGFwZSAubGFiZWwsI2NvbnRhaW5lciAuaWNvbi1zaGFwZSAubGFiZWx7dGV4dC1hbmNob3I6bWlkZGxlO30jY29udGFpbmVyIC5ub2RlIC5rYXRleCBwYXRoe2ZpbGw6IzAwMDtzdHJva2U6IzAwMDtzdHJva2Utd2lkdGg6MXB4O30jY29udGFpbmVyIC5yb3VnaC1ub2RlIC5sYWJlbCwjY29udGFpbmVyIC5ub2RlIC5sYWJlbCwjY29udGFpbmVyIC5pbWFnZS1zaGFwZSAubGFiZWwsI2NvbnRhaW5lciAuaWNvbi1zaGFwZSAubGFiZWx7dGV4dC1hbGlnbjpjZW50ZXI7fSNjb250YWluZXIgLm5vZGUuY2xpY2thYmxle2N1cnNvcjpwb2ludGVyO30jY29udGFpbmVyIC5yb290IC5hbmNob3IgcGF0aHtmaWxsOiMzMzMzMzMhaW1wb3J0YW50O3N0cm9rZS13aWR0aDowO3N0cm9rZTojMzMzMzMzO30jY29udGFpbmVyIC5hcnJvd2hlYWRQYXRoe2ZpbGw6IzMzMzMzMzt9I2NvbnRhaW5lciAuZWRnZVBhdGggLnBhdGh7c3Ryb2tlOiMzMzMzMzM7c3Ryb2tlLXdpZHRoOjIuMHB4O30jY29udGFpbmVyIC5mbG93Y2hhcnQtbGlua3tzdHJva2U6IzMzMzMzMztmaWxsOm5vbmU7fSNjb250YWluZXIgLmVkZ2VMYWJlbHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7dGV4dC1hbGlnbjpjZW50ZXI7fSNjb250YWluZXIgLmVkZ2VMYWJlbCBwe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt9I2NvbnRhaW5lciAuZWRnZUxhYmVsIHJlY3R7b3BhY2l0eTowLjU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO2ZpbGw6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt9I2NvbnRhaW5lciAubGFiZWxCa2d7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwgMjMyLCAyMzIsIDAuNSk7fSNjb250YWluZXIgLmNsdXN0ZXIgcmVjdHtmaWxsOiNmZmZmZGU7c3Ryb2tlOiNhYWFhMzM7c3Ryb2tlLXdpZHRoOjFweDt9I2NvbnRhaW5lciAuY2x1c3RlciB0ZXh0e2ZpbGw6IzMzMzt9I2NvbnRhaW5lciAuY2x1c3RlciBzcGFue2NvbG9yOiMzMzM7fSNjb250YWluZXIgZGl2Lm1lcm1haWRUb29sdGlwe3Bvc2l0aW9uOmFic29sdXRlO3RleHQtYWxpZ246Y2VudGVyO21heC13aWR0aDoyMDBweDtwYWRkaW5nOjJweDtmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjEycHg7YmFja2dyb3VuZDpoc2woODAsIDEwMCUsIDk2LjI3NDUwOTgwMzklKTtib3JkZXI6MXB4IHNvbGlkICNhYWFhMzM7Ym9yZGVyLXJhZGl1czoycHg7cG9pbnRlci1ldmVudHM6bm9uZTt6LWluZGV4OjEwMDt9I2NvbnRhaW5lciAuZmxvd2NoYXJ0VGl0bGVUZXh0e3RleHQtYW5jaG9yOm1pZGRsZTtmb250LXNpemU6MThweDtmaWxsOiMzMzM7fSNjb250YWluZXIgcmVjdC50ZXh0e2ZpbGw6bm9uZTtzdHJva2Utd2lkdGg6MDt9I2NvbnRhaW5lciAuaWNvbi1zaGFwZSwjY29udGFpbmVyIC5pbWFnZS1zaGFwZXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7dGV4dC1hbGlnbjpjZW50ZXI7fSNjb250YWluZXIgLmljb24tc2hhcGUgcCwjY29udGFpbmVyIC5pbWFnZS1zaGFwZSBwe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTtwYWRkaW5nOjJweDt9I2NvbnRhaW5lciAuaWNvbi1zaGFwZSByZWN0LCNjb250YWluZXIgLmltYWdlLXNoYXBlIHJlY3R7b3BhY2l0eTowLjU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO2ZpbGw6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt9I2NvbnRhaW5lciA6cm9vdHstLW1lcm1haWQtZm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO308L3N0eWxlPjxnPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjgiIG1hcmtlcldpZHRoPSI4IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjUiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQtdjIiIGlkPSJjb250YWluZXJfZmxvd2NoYXJ0LXYyLXBvaW50RW5kIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAwIDAgTCAxMCA1IEwgMCAxMCB6Ij48L3BhdGg+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iOCIgbWFya2VyV2lkdGg9IjgiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNSIgcmVmWD0iNC41IiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludFN0YXJ0Ij48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAwIDUgTCAxMCAxMCBMIDEwIDAgeiI+PC9wYXRoPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjExIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNSIgcmVmWD0iMTEiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQtdjIiIGlkPSJjb250YWluZXJfZmxvd2NoYXJ0LXYyLWNpcmNsZUVuZCI+PGNpcmNsZSBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgcj0iNSIgY3k9IjUiIGN4PSI1Ij48L2NpcmNsZT48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9Ii0xIiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1jaXJjbGVTdGFydCI+PGNpcmNsZSBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgcj0iNSIgY3k9IjUiIGN4PSI1Ij48L2NpcmNsZT48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUuMiIgcmVmWD0iMTIiIHZpZXdCb3g9IjAgMCAxMSAxMSIgY2xhc3M9Im1hcmtlciBjcm9zcyBmbG93Y2hhcnQtdjIiIGlkPSJjb250YWluZXJfZmxvd2NoYXJ0LXYyLWNyb3NzRW5kIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAyOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAxLDEgbCA5LDkgTSAxMCwxIGwgLTksOSI+PC9wYXRoPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjExIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNS4yIiByZWZYPSItMSIgdmlld0JveD0iMCAwIDExIDExIiBjbGFzcz0ibWFya2VyIGNyb3NzIGZsb3djaGFydC12MiIgaWQ9ImNvbnRhaW5lcl9mbG93Y2hhcnQtdjItY3Jvc3NTdGFydCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMjsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiPjwvcGF0aD48L21hcmtlcj48ZyBjbGFzcz0icm9vdCI+PGcgY2xhc3M9ImNsdXN0ZXJzIj48L2c+PGcgY2xhc3M9ImVkZ2VQYXRocyI+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQxX2lkMl8wIiBkPSJNNDcuNzU0LDMzLjc1Nkw0My4wOSwzOC42MTdDMzguNDI1LDQzLjQ3OCwyOS4wOTUsNTMuMiwyNC40Myw2Mi43NTVDMTkuNzY2LDcyLjMxLDE5Ljc2Niw4MS42OTgsMTkuNzY2LDg2LjM5MkwxOS43NjYsOTEuMDg2Ij48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQxX2lkM18wIiBkPSJNNjguNDcyLDMzLjc1Nkw3My4xMzcsMzguNjE3Qzc3LjgwMiw0My40NzgsODcuMTMxLDUzLjIsOTEuNzk2LDYyLjIyN0M5Ni40NjEsNzEuMjU1LDk2LjQ2MSw3OS41ODksOTYuNDYxLDgzLjc1NUw5Ni40NjEsODcuOTIyIj48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQzX2lkNF8wIiBkPSJNODYuMTYzLDExMy42NjFMODEuNTQsMTE4LjUxNUM3Ni45MTYsMTIzLjM2OCw2Ny42NjksMTMzLjA3NSw2My4wNDUsMTQyLjA5NUM1OC40MjIsMTUxLjExNSw1OC40MjIsMTU5LjQ0OCw1OC40MjIsMTYzLjYxNUw1OC40MjIsMTY3Ljc4MSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkM19pZDVfMCIgZD0iTTEwNi43NTksMTEzLjY2MUwxMTEuMzgyLDExOC41MTVDMTE2LjAwNiwxMjMuMzY4LDEyNS4yNTMsMTMzLjA3NSwxMjkuODc2LDE0Mi41MjJDMTM0LjUsMTUxLjk2OSwxMzQuNSwxNjEuMTU2LDEzNC41LDE2NS43NUwxMzQuNSwxNzAuMzQ0Ij48L3BhdGg+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWxzIj48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjxnIGNsYXNzPSJub2RlcyI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTguMTEzMjgxMjUsIDIyLjk2MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LWlkMS0wIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuOTYwOTM3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcuNDYwOTM3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjE0LjkyMTg3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjEzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOS43NjU2MjUsIDEwMi44NTE1NjI1KSIgaWQ9ImZsb3djaGFydC1pZDItMSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjc2NTYyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuMjY1NjI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC41MzEyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjY8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDk2LjQ2MDkzNzUsIDEwMi44NTE1NjI1KSIgaWQ9ImZsb3djaGFydC1pZDMtMyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjE0LjkyOTY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03LjQyOTY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxNC44NTkzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xMjwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTguNDIxODc1LCAxODIuMTAxNTYyNSkiIGlkPSJmbG93Y2hhcnQtaWQ0LTQiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNC4zMjAzMTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNi44MjAzMTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTMuNjQwNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzNC41LCAxODIuMTAxNTYyNSkiIGlkPSJmbG93Y2hhcnQtaWQ1LTUiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS43NTc4MTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC4yNTc4MTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC41MTU2MjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD40PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48L2c+PC9nPjwvZz48L3N2Zz4=\"/>\n\n\n<div class=\"markdown\"><p>In <code>Herb.jl</code>, the <code>HerbCore.RuleNode</code> is used to represent both an individual node, but also entire ASTs or sub-trees. This is achieved by nesting instances of <code>RuleNode</code>. A <code>RuleNode</code> can be instantiated by providing the index of the grammar rule that the node represents and a vector of child nodes. </p></div>\n\n<pre class='language-julia'><code class='language-julia'>syntaxtree = @rulenode 13{6,12{11,4}}</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-syntaxtree\">13{6,12{11,4}}</pre>\n\n\n<div class=\"markdown\"><p>We can confirm that our AST is correct by displaying it in a more human-readable way, using <code>HerbGrammar.rulenode2expr</code> and by testing it on a few input examples using <code>HerbInterpret.execute_on_input</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>rulenode2expr(syntaxtree, grammar)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash642064\">:(5 * (x + 3))</pre>\n\n<pre class='language-julia'><code class='language-julia'># test solution on inputs\nexecute_on_input(grammar, syntaxtree, Dict(:x =&gt; 10))</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash156207\">65</pre>\n\n\n<div class=\"markdown\"><h2 id=\"Another-example:-FizzBuzz\">Another example: FizzBuzz</h2><p>Let's look at a more interesting example.  The program <code>fizzbuzz()</code> is based on the popular <em>FizzBuzz</em> problem. Given an integer number, the program simply returns a <code>String</code> of that number, but replace numbers divisible by 3 with <code>\"Fizz\"</code>, numbers divisible by 5 with <code>\"Buzz\"</code>, and number divisible by both 3 and 5 with <code>\"FizzBuzz\"</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>function fizzbuzz(x)\n    if x % 5 == 0 && x % 3 == 0\n        return \"FizzBuzz\"\n    else\n        if x % 3 == 0\n            return  \"Fizz\"\n        else\n            if x % 5 == 0\n                return \"Buzz\"\n            else\n                return string(x)\n            end\n        end\n    end\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-fizzbuzz\">fizzbuzz (generic function with 1 method)</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Define-the-grammar\">Define the grammar</h3><p>Let's define a grammar with all the rules that we need.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>grammar_fizzbuzz = @csgrammar begin\n    Int = input1\n    Int = 0 | 3 | 5\n    String = \"Fizz\" | \"Buzz\" | \"FizzBuzz\"\n    String = string(Int)\n    Return = String\n    Int = Int % Int\n    Bool = Int == Int\n    Int = Bool ? Int : Int\n    Bool = Bool && Bool\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-grammar_fizzbuzz\">1: Int = input1\n2: Int = 0\n3: Int = 3\n4: Int = 5\n5: String = Fizz\n6: String = Buzz\n7: String = FizzBuzz\n8: String = string(Int)\n9: Return = String\n10: Int = Int % Int\n11: Bool = Int == Int\n12: Int = if Bool\n    Int\nelse\n    Int\nend\n13: Bool = Bool &amp;&amp; Bool\n</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Construct-the-syntax-tree\">Construct the syntax tree</h3></div>\n\n\n<div class=\"markdown\"><p>Given the grammar, the AST of <code>fizzbuzz()</code> looks like this:</p></div>\n\n\n<img src=\"data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0iZmxvd2NoYXJ0LXYyIiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgdmlld0JveD0iMCAwIDc5Ny4xODM1OTM3NSA0NDEuMTE3MTg3NSIgaGVpZ2h0PSI0NDEuMTE3MTg3NSIgY2xhc3M9ImZsb3djaGFydCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iNzk3LjE4MzU5Mzc1IiBpZD0iY29udGFpbmVyIj48c3R5bGU+I2NvbnRhaW5lcntmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7ZmlsbDojMzMzO31Aa2V5ZnJhbWVzIGVkZ2UtYW5pbWF0aW9uLWZyYW1le2Zyb217c3Ryb2tlLWRhc2hvZmZzZXQ6MDt9fUBrZXlmcmFtZXMgZGFzaHt0b3tzdHJva2UtZGFzaG9mZnNldDowO319I2NvbnRhaW5lciAuZWRnZS1hbmltYXRpb24tc2xvd3tzdHJva2UtZGFzaGFycmF5OjksNSFpbXBvcnRhbnQ7c3Ryb2tlLWRhc2hvZmZzZXQ6OTAwO2FuaW1hdGlvbjpkYXNoIDUwcyBsaW5lYXIgaW5maW5pdGU7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7fSNjb250YWluZXIgLmVkZ2UtYW5pbWF0aW9uLWZhc3R7c3Ryb2tlLWRhc2hhcnJheTo5LDUhaW1wb3J0YW50O3N0cm9rZS1kYXNob2Zmc2V0OjkwMDthbmltYXRpb246ZGFzaCAyMHMgbGluZWFyIGluZmluaXRlO3N0cm9rZS1saW5lY2FwOnJvdW5kO30jY29udGFpbmVyIC5lcnJvci1pY29ue2ZpbGw6IzU1MjIyMjt9I2NvbnRhaW5lciAuZXJyb3ItdGV4dHtmaWxsOiM1NTIyMjI7c3Ryb2tlOiM1NTIyMjI7fSNjb250YWluZXIgLmVkZ2UtdGhpY2tuZXNzLW5vcm1hbHtzdHJva2Utd2lkdGg6MXB4O30jY29udGFpbmVyIC5lZGdlLXRoaWNrbmVzcy10aGlja3tzdHJva2Utd2lkdGg6My41cHg7fSNjb250YWluZXIgLmVkZ2UtcGF0dGVybi1zb2xpZHtzdHJva2UtZGFzaGFycmF5OjA7fSNjb250YWluZXIgLmVkZ2UtdGhpY2tuZXNzLWludmlzaWJsZXtzdHJva2Utd2lkdGg6MDtmaWxsOm5vbmU7fSNjb250YWluZXIgLmVkZ2UtcGF0dGVybi1kYXNoZWR7c3Ryb2tlLWRhc2hhcnJheTozO30jY29udGFpbmVyIC5lZGdlLXBhdHRlcm4tZG90dGVke3N0cm9rZS1kYXNoYXJyYXk6Mjt9I2NvbnRhaW5lciAubWFya2Vye2ZpbGw6IzMzMzMzMztzdHJva2U6IzMzMzMzMzt9I2NvbnRhaW5lciAubWFya2VyLmNyb3Nze3N0cm9rZTojMzMzMzMzO30jY29udGFpbmVyIHN2Z3tmb250LWZhbWlseToidHJlYnVjaGV0IG1zIix2ZXJkYW5hLGFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE2cHg7fSNjb250YWluZXIgcHttYXJnaW46MDt9I2NvbnRhaW5lciAubGFiZWx7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2NvbG9yOiMzMzM7fSNjb250YWluZXIgLmNsdXN0ZXItbGFiZWwgdGV4dHtmaWxsOiMzMzM7fSNjb250YWluZXIgLmNsdXN0ZXItbGFiZWwgc3Bhbntjb2xvcjojMzMzO30jY29udGFpbmVyIC5jbHVzdGVyLWxhYmVsIHNwYW4gcHtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O30jY29udGFpbmVyIC5sYWJlbCB0ZXh0LCNjb250YWluZXIgc3BhbntmaWxsOiMzMzM7Y29sb3I6IzMzMzt9I2NvbnRhaW5lciAubm9kZSByZWN0LCNjb250YWluZXIgLm5vZGUgY2lyY2xlLCNjb250YWluZXIgLm5vZGUgZWxsaXBzZSwjY29udGFpbmVyIC5ub2RlIHBvbHlnb24sI2NvbnRhaW5lciAubm9kZSBwYXRoe2ZpbGw6I0VDRUNGRjtzdHJva2U6IzkzNzBEQjtzdHJva2Utd2lkdGg6MXB4O30jY29udGFpbmVyIC5yb3VnaC1ub2RlIC5sYWJlbCB0ZXh0LCNjb250YWluZXIgLm5vZGUgLmxhYmVsIHRleHQsI2NvbnRhaW5lciAuaW1hZ2Utc2hhcGUgLmxhYmVsLCNjb250YWluZXIgLmljb24tc2hhcGUgLmxhYmVse3RleHQtYW5jaG9yOm1pZGRsZTt9I2NvbnRhaW5lciAubm9kZSAua2F0ZXggcGF0aHtmaWxsOiMwMDA7c3Ryb2tlOiMwMDA7c3Ryb2tlLXdpZHRoOjFweDt9I2NvbnRhaW5lciAucm91Z2gtbm9kZSAubGFiZWwsI2NvbnRhaW5lciAubm9kZSAubGFiZWwsI2NvbnRhaW5lciAuaW1hZ2Utc2hhcGUgLmxhYmVsLCNjb250YWluZXIgLmljb24tc2hhcGUgLmxhYmVse3RleHQtYWxpZ246Y2VudGVyO30jY29udGFpbmVyIC5ub2RlLmNsaWNrYWJsZXtjdXJzb3I6cG9pbnRlcjt9I2NvbnRhaW5lciAucm9vdCAuYW5jaG9yIHBhdGh7ZmlsbDojMzMzMzMzIWltcG9ydGFudDtzdHJva2Utd2lkdGg6MDtzdHJva2U6IzMzMzMzMzt9I2NvbnRhaW5lciAuYXJyb3doZWFkUGF0aHtmaWxsOiMzMzMzMzM7fSNjb250YWluZXIgLmVkZ2VQYXRoIC5wYXRoe3N0cm9rZTojMzMzMzMzO3N0cm9rZS13aWR0aDoyLjBweDt9I2NvbnRhaW5lciAuZmxvd2NoYXJ0LWxpbmt7c3Ryb2tlOiMzMzMzMzM7ZmlsbDpub25lO30jY29udGFpbmVyIC5lZGdlTGFiZWx7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO3RleHQtYWxpZ246Y2VudGVyO30jY29udGFpbmVyIC5lZGdlTGFiZWwgcHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7fSNjb250YWluZXIgLmVkZ2VMYWJlbCByZWN0e29wYWNpdHk6MC41O2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTtmaWxsOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7fSNjb250YWluZXIgLmxhYmVsQmtne2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsIDIzMiwgMjMyLCAwLjUpO30jY29udGFpbmVyIC5jbHVzdGVyIHJlY3R7ZmlsbDojZmZmZmRlO3N0cm9rZTojYWFhYTMzO3N0cm9rZS13aWR0aDoxcHg7fSNjb250YWluZXIgLmNsdXN0ZXIgdGV4dHtmaWxsOiMzMzM7fSNjb250YWluZXIgLmNsdXN0ZXIgc3Bhbntjb2xvcjojMzMzO30jY29udGFpbmVyIGRpdi5tZXJtYWlkVG9vbHRpcHtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcjttYXgtd2lkdGg6MjAwcHg7cGFkZGluZzoycHg7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMnB4O2JhY2tncm91bmQ6aHNsKDgwLCAxMDAlLCA5Ni4yNzQ1MDk4MDM5JSk7Ym9yZGVyOjFweCBzb2xpZCAjYWFhYTMzO2JvcmRlci1yYWRpdXM6MnB4O3BvaW50ZXItZXZlbnRzOm5vbmU7ei1pbmRleDoxMDA7fSNjb250YWluZXIgLmZsb3djaGFydFRpdGxlVGV4dHt0ZXh0LWFuY2hvcjptaWRkbGU7Zm9udC1zaXplOjE4cHg7ZmlsbDojMzMzO30jY29udGFpbmVyIHJlY3QudGV4dHtmaWxsOm5vbmU7c3Ryb2tlLXdpZHRoOjA7fSNjb250YWluZXIgLmljb24tc2hhcGUsI2NvbnRhaW5lciAuaW1hZ2Utc2hhcGV7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO3RleHQtYWxpZ246Y2VudGVyO30jY29udGFpbmVyIC5pY29uLXNoYXBlIHAsI2NvbnRhaW5lciAuaW1hZ2Utc2hhcGUgcHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7cGFkZGluZzoycHg7fSNjb250YWluZXIgLmljb24tc2hhcGUgcmVjdCwjY29udGFpbmVyIC5pbWFnZS1zaGFwZSByZWN0e29wYWNpdHk6MC41O2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTtmaWxsOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7fSNjb250YWluZXIgOnJvb3R7LS1tZXJtYWlkLWZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjt9PC9zdHlsZT48Zz48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSI4IiBtYXJrZXJXaWR0aD0iOCIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSI1IiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1wb2ludEVuZCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMCAwIEwgMTAgNSBMIDAgMTAgeiI+PC9wYXRoPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjgiIG1hcmtlcldpZHRoPSI4IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjQuNSIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgaWQ9ImNvbnRhaW5lcl9mbG93Y2hhcnQtdjItcG9pbnRTdGFydCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMCA1IEwgMTAgMTAgTCAxMCAwIHoiPjwvcGF0aD48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjExIiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1jaXJjbGVFbmQiPjxjaXJjbGUgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHI9IjUiIGN5PSI1IiBjeD0iNSI+PC9jaXJjbGU+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSItMSIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgaWQ9ImNvbnRhaW5lcl9mbG93Y2hhcnQtdjItY2lyY2xlU3RhcnQiPjxjaXJjbGUgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHI9IjUiIGN5PSI1IiBjeD0iNSI+PC9jaXJjbGU+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1LjIiIHJlZlg9IjEyIiB2aWV3Qm94PSIwIDAgMTEgMTEiIGNsYXNzPSJtYXJrZXIgY3Jvc3MgZmxvd2NoYXJ0LXYyIiBpZD0iY29udGFpbmVyX2Zsb3djaGFydC12Mi1jcm9zc0VuZCI+PHBhdGggc3R5bGU9InN0cm9rZS13aWR0aDogMjsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIGQ9Ik0gMSwxIGwgOSw5IE0gMTAsMSBsIC05LDkiPjwvcGF0aD48L21hcmtlcj48bWFya2VyIG9yaWVudD0iYXV0byIgbWFya2VySGVpZ2h0PSIxMSIgbWFya2VyV2lkdGg9IjExIiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUuMiIgcmVmWD0iLTEiIHZpZXdCb3g9IjAgMCAxMSAxMSIgY2xhc3M9Im1hcmtlciBjcm9zcyBmbG93Y2hhcnQtdjIiIGlkPSJjb250YWluZXJfZmxvd2NoYXJ0LXYyLWNyb3NzU3RhcnQiPjxwYXRoIHN0eWxlPSJzdHJva2Utd2lkdGg6IDI7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBkPSJNIDEsMSBsIDksOSBNIDEwLDEgbCAtOSw5Ij48L3BhdGg+PC9tYXJrZXI+PGcgY2xhc3M9InJvb3QiPjxnIGNsYXNzPSJjbHVzdGVycyI+PC9nPjxnIGNsYXNzPSJlZGdlUGF0aHMiPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMV9pZDIxXzAiIGQ9Ik0zMTAuNjM5LDI2LjY2N0wyODcuMzExLDMyLjY5OUMyNjMuOTgyLDM4LjczMSwyMTcuMzI1LDUwLjc5NSwxOTMuOTk3LDYwLjk5NEMxNzAuNjY4LDcxLjE5MywxNzAuNjY4LDc5LjUyNiwxNzAuNjY4LDgzLjY5M0wxNzAuNjY4LDg3Ljg1OSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMV9pZDIyXzAiIGQ9Ik0zMjUuMDk0LDM3Ljg1OUwzMjUuMDk0LDQyLjAyNkMzMjUuMDk0LDQ2LjE5MywzMjUuMDk0LDU0LjUyNiwzMjUuMDk0LDYzLjQwMkMzMjUuMDk0LDcyLjI3OSwzMjUuMDk0LDgxLjY5OCwzMjUuMDk0LDg2LjQwOEwzMjUuMDk0LDkxLjExNyI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMV9pZDIzXzAiIGQ9Ik0zMzkuNzAyLDI2LjAxM0wzNjguNzk5LDMyLjE1NEMzOTcuODk2LDM4LjI5NSw0NTYuMDkxLDUwLjU3Nyw0ODUuMTg4LDYwLjg5QzUxNC4yODUsNzEuMjAzLDUxNC4yODUsNzkuNTQ3LDUxNC4yODUsODMuNzE5TDUxNC4yODUsODcuODkxIj48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQyMV9pZDMxXzAiIGQ9Ik0xNTcuMzkzLDEwOS43MkwxNDYuNzksMTE1LjIzQzEzNi4xODgsMTIwLjc0LDExNC45ODIsMTMxLjc2MSwxMDQuMzgsMTQxLjUzOUM5My43NzcsMTUxLjMxOCw5My43NzcsMTU5Ljg1NCw5My43NzcsMTY0LjEyMkw5My43NzcsMTY4LjM5MSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMjFfaWQzMl8wIiBkPSJNMTgzLjk0MywxMDkuNzJMMTk0LjU0NiwxMTUuMjNDMjA1LjE0OCwxMjAuNzQsMjI2LjM1MywxMzEuNzYxLDIzNi45NTYsMTQxLjUzOUMyNDcuNTU5LDE1MS4zMTgsMjQ3LjU1OSwxNTkuODU0LDI0Ny41NTksMTY0LjEyMkwyNDcuNTU5LDE2OC4zOTEiPjwvcGF0aD48cGF0aCBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDMxX2lkNDFfMCIgZD0iTTgzLjg0NSwxOTMuMDI3TDc5LjA5MywxOTcuOTYyQzc0LjM0MSwyMDIuODk4LDY0LjgzNiwyMTIuNzY5LDYwLjA4NCwyMjEuODcyQzU1LjMzMiwyMzAuOTc0LDU1LjMzMiwyMzkuMzA3LDU1LjMzMiwyNDMuNDc0TDU1LjMzMiwyNDcuNjQxIj48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQzMV9pZDQyXzAiIGQ9Ik0xMDMuNzEsMTkzLjAyN0wxMDguNDYyLDE5Ny45NjJDMTEzLjIxNCwyMDIuODk4LDEyMi43MTgsMjEyLjc2OSwxMjcuNDcxLDIyMi41MzNDMTMyLjIyMywyMzIuMjk3LDEzMi4yMjMsMjQxLjk1MywxMzIuMjIzLDI0Ni43ODFMMTMyLjIyMywyNTEuNjA5Ij48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ0MV9pZDUxXzAiIGQ9Ik00NS4wMTQsMjc0LjU0Mkw0MC42NzMsMjc5LjM2OUMzNi4zMzIsMjg0LjE5NSwyNy42NSwyOTMuODQ3LDIzLjMxLDMwMy41ODRDMTguOTY5LDMxMy4zMiwxOC45NjksMzIzLjE0MSwxOC45NjksMzI4LjA1MUwxOC45NjksMzMyLjk2MSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkNDFfaWQ1Ml8wIiBkPSJNNjYuMjU2LDI3My45NjhMNzEuMTksMjc4Ljg5Qzc2LjEyNCwyODMuODEyLDg1Ljk5MSwyOTMuNjU2LDkwLjkyNSwzMDMuMzU3Qzk1Ljg1OSwzMTMuMDU3LDk1Ljg1OSwzMjIuNjE1LDk1Ljg1OSwzMjcuMzkzTDk1Ljg1OSwzMzIuMTcyIj48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQzMl9pZDQzXzAiIGQ9Ik0yMzcuNjI2LDE5My4wMjdMMjMyLjg3NCwxOTcuOTYyQzIyOC4xMjIsMjAyLjg5OCwyMTguNjE4LDIxMi43NjksMjEzLjg2NSwyMjEuODcyQzIwOS4xMTMsMjMwLjk3NCwyMDkuMTEzLDIzOS4zMDcsMjA5LjExMywyNDMuNDc0TDIwOS4xMTMsMjQ3LjY0MSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMzJfaWQ0NF8wIiBkPSJNMjU3LjQ5MSwxOTMuMDI3TDI2Mi4yNDMsMTk3Ljk2MkMyNjYuOTk1LDIwMi44OTgsMjc2LjUsMjEyLjc2OSwyODEuMjUyLDIyMi41MzNDMjg2LjAwNCwyMzIuMjk3LDI4Ni4wMDQsMjQxLjk1MywyODYuMDA0LDI0Ni43ODFMMjg2LjAwNCwyNTEuNjA5Ij48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ0M19pZDUzXzAiIGQ9Ik0xOTguMTksMjczLjk2OEwxOTMuMjU2LDI3OC44OUMxODguMzIyLDI4My44MTIsMTc4LjQ1NCwyOTMuNjU2LDE3My41MiwzMDMuNDg4QzE2OC41ODYsMzEzLjMyLDE2OC41ODYsMzIzLjE0MSwxNjguNTg2LDMyOC4wNTFMMTY4LjU4NiwzMzIuOTYxIj48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ0M19pZDU0XzAiIGQ9Ik0yMjAuMDU1LDI3My45NUwyMjUuMDA4LDI3OC44NzVDMjI5Ljk2MSwyODMuOCwyMzkuODY3LDI5My42NSwyNDQuODIsMzAzLjM5OEMyNDkuNzczLDMxMy4xNDYsMjQ5Ljc3MywzMjIuNzkyLDI0OS43NzMsMzI3LjYxNUwyNDkuNzczLDMzMi40MzgiPjwvcGF0aD48cGF0aCBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDIyX2lkMzNfMCIgZD0iTTMyNS4wOTQsMTE0LjUyM0wzMjUuMDk0LDExOS4yMzNDMzI1LjA5NCwxMjMuOTQzLDMyNS4wOTQsMTMzLjM2MiwzMjUuMDk0LDE0Mi44ODRDMzI1LjA5NCwxNTIuNDA2LDMyNS4wOTQsMTYyLjAzMSwzMjUuMDk0LDE2Ni44NDRMMzI1LjA5NCwxNzEuNjU2Ij48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQyM19pZDM0XzAiIGQ9Ik01MDAuMjEsMTA3LjhMNDgzLjczMiwxMTMuNjNDNDY3LjI1NCwxMTkuNDYsNDM0LjI5NywxMzEuMTIxLDQxNy44MTgsMTQxLjIxOUM0MDEuMzQsMTUxLjMxOCw0MDEuMzQsMTU5Ljg1NCw0MDEuMzQsMTY0LjEyMkw0MDEuMzQsMTY4LjM5MSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMzRfaWQ0NV8wIiBkPSJNMzkxLjQwNywxOTMuMDI3TDM4Ni42NTUsMTk3Ljk2MkMzODEuOTAzLDIwMi44OTgsMzcyLjM5OSwyMTIuNzY5LDM2Ny42NDcsMjIxLjg3MkMzNjIuODk1LDIzMC45NzQsMzYyLjg5NSwyMzkuMzA3LDM2Mi44OTUsMjQzLjQ3NEwzNjIuODk1LDI0Ny42NDEiPjwvcGF0aD48cGF0aCBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDM0X2lkNDZfMCIgZD0iTTQxMS4yNzIsMTkzLjAyN0w0MTYuMDI0LDE5Ny45NjJDNDIwLjc3NywyMDIuODk4LDQzMC4yODEsMjEyLjc2OSw0MzUuMDMzLDIyMi41MzNDNDM5Ljc4NSwyMzIuMjk3LDQzOS43ODUsMjQxLjk1Myw0MzkuNzg1LDI0Ni43ODFMNDM5Ljc4NSwyNTEuNjA5Ij48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ0NV9pZDU1XzAiIGQ9Ik0zNTEuOTUzLDI3My45NUwzNDcsMjc4Ljg3NUMzNDIuMDQ3LDI4My44LDMzMi4xNDEsMjkzLjY1LDMyNy4xODgsMzAzLjQ4NUMzMjIuMjM0LDMxMy4zMiwzMjIuMjM0LDMyMy4xNDEsMzIyLjIzNCwzMjguMDUxTDMyMi4yMzQsMzMyLjk2MSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkNDVfaWQ1Nl8wIiBkPSJNMzc2LjQ1MSwyNzAuNDM4TDM4Ni41OSwyNzUuOTQ4QzM5Ni43MjksMjgxLjQ1OSw0MTcuMDA3LDI5Mi40NzksNDI3LjE0NiwzMDIuODEzQzQzNy4yODUsMzEzLjE0Niw0MzcuMjg1LDMyMi43OTIsNDM3LjI4NSwzMjcuNjE1TDQzNy4yODUsMzMyLjQzOCI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMjNfaWQzNV8wIiBkPSJNNTE0LjI4NSwxMTcuNzVMNTE0LjI4NSwxMjEuOTIyQzUxNC4yODUsMTI2LjA5NCw1MTQuMjg1LDEzNC40MzgsNTE0LjI4NSwxNDMuMzE0QzUxNC4yODUsMTUyLjE5LDUxNC4yODUsMTYxLjU5OSw1MTQuMjg1LDE2Ni4zMDNMNTE0LjI4NSwxNzEuMDA4Ij48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQzNV9pZDQ3XzAiIGQ9Ik01MTQuMjg1LDE5NC40MTRMNTE0LjI4NSwxOTkuMTE4QzUxNC4yODUsMjAzLjgyMyw1MTQuMjg1LDIxMy4yMzIsNTE0LjI4NSwyMjIuNzU1QzUxNC4yODUsMjMyLjI3OSw1MTQuMjg1LDI0MS45MTcsNTE0LjI4NSwyNDYuNzM2TDUxNC4yODUsMjUxLjU1NSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMjNfaWQzNl8wIiBkPSJNNTI4Ljg5MiwxMDUuOTFMNTU3Ljk0MiwxMTIuMDU1QzU4Ni45OTIsMTE4LjIwMSw2NDUuMDkxLDEzMC40OTEsNjc0LjE0MSwxNDAuODAzQzcwMy4xOTEsMTUxLjExNSw3MDMuMTkxLDE1OS40NDgsNzAzLjE5MSwxNjMuNjE1TDcwMy4xOTEsMTY3Ljc4MSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMzZfaWQ0OF8wIiBkPSJNNjg5LjExOSwxODcuNjk4TDY3Mi42ODYsMTkzLjUyMkM2NTYuMjUzLDE5OS4zNDYsNjIzLjM4NiwyMTAuOTkzLDYwNi45NTMsMjIxLjE2OEM1OTAuNTIsMjMxLjM0NCw1OTAuNTIsMjQwLjA0Nyw1OTAuNTIsMjQ0LjM5OEw1OTAuNTIsMjQ4Ljc1Ij48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQ0OF9pZDU3XzAiIGQ9Ik01ODAuNTk4LDI3My4zOTdMNTc1Ljc3OCwyNzguNDE0QzU3MC45NTcsMjgzLjQzMSw1NjEuMzE3LDI5My40NjYsNTU2LjQ5NiwzMDIuNjQ5QzU1MS42NzYsMzExLjgzMyw1NTEuNjc2LDMyMC4xNjcsNTUxLjY3NiwzMjQuMzMzTDU1MS42NzYsMzI4LjUiPjwvcGF0aD48cGF0aCBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDU3X2lkNjFfMCIgZD0iTTU0MS4zNTgsMzU1LjQwMkw1MzcuMDE3LDM2MC4yMjhDNTMyLjY3NiwzNjUuMDU0LDUyMy45OTQsMzc0LjcwNyw1MTkuNjUzLDM4My44MzFDNTE1LjMxMywzOTIuOTU2LDUxNS4zMTMsNDAxLjU1Miw1MTUuMzEzLDQwNS44NUw1MTUuMzEzLDQxMC4xNDgiPjwvcGF0aD48cGF0aCBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDU3X2lkNjJfMCIgZD0iTTU2NS4yNzksMzUxLjIxMUw1NzUuNjAxLDM1Ni43MzZDNTg1LjkyMywzNjIuMjYsNjA2LjU2NywzNzMuMzEsNjE2Ljg4OSwzODMuMDAxQzYyNy4yMTEsMzkyLjY5Myw2MjcuMjExLDQwMS4wMjYsNjI3LjIxMSw0MDUuMTkzTDYyNy4yMTEsNDA5LjM1OSI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkNDhfaWQ1OF8wIiBkPSJNNjAwLjMzNCwyNzMuNDk5TDYwNS4wMzksMjc4LjQ5OUM2MDkuNzQ0LDI4My40OTksNjE5LjE1NSwyOTMuNSw2MjMuODYxLDMwMy4zMjhDNjI4LjU2NiwzMTMuMTU2LDYyOC41NjYsMzIyLjgxMyw2MjguNTY2LDMyNy42NDFMNjI4LjU2NiwzMzIuNDY5Ij48L3BhdGg+PHBhdGggc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfaWQzNl9pZDQ5XzAiIGQ9Ik03MDMuMzQsMTk3LjY0TDcwMy4zODIsMjAxLjgwN0M3MDMuNDI0LDIwNS45NzMsNzAzLjUwNywyMTQuMzA3LDcwMy41NDgsMjIzLjI2MkM3MDMuNTksMjMyLjIxNiw3MDMuNTksMjQxLjc5Miw3MDMuNTksMjQ2LjU3OUw3MDMuNTksMjUxLjM2NyI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkNDlfaWQ1OV8wIiBkPSJNNzAzLjU5LDI3NC43NzNMNzAzLjU5LDI3OS41NjFDNzAzLjU5LDI4NC4zNDksNzAzLjU5LDI5My45MjQsNzAzLjU5LDMwMy40OUM3MDMuNTksMzEzLjA1NSw3MDMuNTksMzIyLjYwOSw3MDMuNTksMzI3LjM4N0w3MDMuNTksMzMyLjE2NCI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkMzZfaWQ0MTBfMCIgZD0iTTcxNi4zMzMsMTg5Ljc5NUw3MjYuNDg5LDE5NS4yNjlDNzM2LjY0NiwyMDAuNzQzLDc1Ni45NTgsMjExLjY5Miw3NjcuMTE0LDIyMS45NTRDNzc3LjI3LDIzMi4yMTYsNzc3LjI3LDI0MS43OTIsNzc3LjI3LDI0Ni41NzlMNzc3LjI3LDI1MS4zNjciPjwvcGF0aD48cGF0aCBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9pZDQxMF9pZDUxMF8wIiBkPSJNNzc3LjI3LDI3NC43NzNMNzc3LjI3LDI3OS41NjFDNzc3LjI3LDI4NC4zNDksNzc3LjI3LDI5My45MjQsNzc3LjI3LDMwMy40NjVDNzc3LjI3LDMxMy4wMDUsNzc3LjI3LDMyMi41MSw3NzcuMjcsMzI3LjI2M0w3NzcuMjcsMzMyLjAxNiI+PC9wYXRoPjxwYXRoIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX2lkNTEwX2lkNjNfMCIgZD0iTTc3Ny4yNywzNTUuODQ0TDc3Ny4yNywzNjAuNTk2Qzc3Ny4yNywzNjUuMzQ5LDc3Ny4yNywzNzQuODU0LDc3Ny4yNywzODMuOTA1Qzc3Ny4yNywzOTIuOTU2LDc3Ny4yNyw0MDEuNTUyLDc3Ny4yNyw0MDUuODVMNzc3LjI3LDQxMC4xNDgiPjwvcGF0aD48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbHMiPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjxnIGNsYXNzPSJub2RlcyI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzI1LjA5Mzc1LCAyMi45Mjk2ODc1KSIgaWQ9ImZsb3djaGFydC1pZDEtMCIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjE0LjkyOTY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03LjQyOTY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxNC44NTkzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xMjwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcwLjY2Nzk2ODc1LCAxMDIuODIwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQyMS0xIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuOTYwOTM3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcuNDYwOTM3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjE0LjkyMTg3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjEzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMjUuMDkzNzUsIDEwMi44MjAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDIyLTMiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS43MDMxMjUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjIwMzEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjguNDA2MjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD45PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MTQuMjg1MTU2MjUsIDEwMi44MjAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDIzLTUiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNC45Mjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNy40Mjk2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTQuODU5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTI8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDkzLjc3NzM0Mzc1LCAxODIuNzEwOTM3NSkiIGlkPSJmbG93Y2hhcnQtaWQzMS03IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTQuMzIwMzEyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYuODIwMzEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEzLjY0MDYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjExPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNDcuNTU4NTkzNzUsIDE4Mi43MTA5Mzc1KSIgaWQ9ImZsb3djaGFydC1pZDMyLTkiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNC4zMjAzMTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNi44MjAzMTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTMuNjQwNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU1LjMzMjAzMTI1LCAyNjMuMDcwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQ0MS0xMSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjE1LjQyOTY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03LjkyOTY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxNS44NTkzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4xMDwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTMyLjIyMjY1NjI1LCAyNjMuMDcwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQ0Mi0xMyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjQ2MDkzNzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjk2MDkzNzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI3LjkyMTg3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjI8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE4Ljk2ODc1LCAzNDMuOTI5Njg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ1MS0xNSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjEwLjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy40Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjYuOTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDk1Ljg1OTM3NSwgMzQzLjkyOTY4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNTItMTciIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS43NTc4MTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC4yNTc4MTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC41MTU2MjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD40PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMDkuMTEzMjgxMjUsIDI2My4wNzAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDQzLTE5IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTUuNDI5Njg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTcuOTI5Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjE1Ljg1OTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjEwPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyODYuMDAzOTA2MjUsIDI2My4wNzAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDQ0LTIxIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNDYwOTM3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMuOTYwOTM3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjcuOTIxODc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MjwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTY4LjU4NTkzNzUsIDM0My45Mjk2ODc1KSIgaWQ9ImZsb3djaGFydC1pZDUzLTIzIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTAuOTY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjQ2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iNi45Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjQ5Ljc3MzQzNzUsIDM0My45Mjk2ODc1KSIgaWQ9ImZsb3djaGFydC1pZDU0LTI1IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNDkyMTg3NSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMuOTkyMTg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjcuOTg0Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MzwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzI1LjA5Mzc1LCAxODIuNzEwOTM3NSkiIGlkPSJmbG93Y2hhcnQtaWQzMy0yNyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjA1NDY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjU1NDY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI3LjEwOTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjc8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQwMS4zMzk4NDM3NSwgMTgyLjcxMDkzNzUpIiBpZD0iZmxvd2NoYXJ0LWlkMzQtMjkiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNC4zMjAzMTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNi44MjAzMTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTMuNjQwNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM2Mi44OTQ1MzEyNSwgMjYzLjA3MDMxMjUpIiBpZD0iZmxvd2NoYXJ0LWlkNDUtMzEiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNS40Mjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNy45Mjk2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTUuODU5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTA8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQzOS43ODUxNTYyNSwgMjYzLjA3MDMxMjUpIiBpZD0iZmxvd2NoYXJ0LWlkNDYtMzMiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS40NjA5Mzc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy45NjA5Mzc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iNy45MjE4NzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4yPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMjIuMjM0Mzc1LCAzNDMuOTI5Njg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ1NS0zNSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjEwLjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy40Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjYuOTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQzNy4yODUxNTYyNSwgMzQzLjkyOTY4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNTYtMzciIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS40OTIxODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy45OTIxODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iNy45ODQzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4zPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MTQuMjg1MTU2MjUsIDE4Mi43MTA5Mzc1KSIgaWQ9ImZsb3djaGFydC1pZDM1LTM5IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNzAzMTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC4yMDMxMjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI4LjQwNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+OTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTE0LjI4NTE1NjI1LCAyNjMuMDcwMzEyNSkiIGlkPSJmbG93Y2hhcnQtaWQ0Ny00MSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjUxNTYyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuMDE1NjI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC4wMzEyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjU8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDcwMy4xOTE0MDYyNSwgMTgyLjcxMDkzNzUpIiBpZD0iZmxvd2NoYXJ0LWlkMzYtNDMiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNC45Mjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNy40Mjk2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTQuODU5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTI8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU5MC41MTk1MzEyNSwgMjYzLjA3MDMxMjUpIiBpZD0iZmxvd2NoYXJ0LWlkNDgtNDUiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNC4zMjAzMTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNi44MjAzMTI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTMuNjQwNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDU1MS42NzU3ODEyNSwgMzQzLjkyOTY4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNTctNDciIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxNS40Mjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNy45Mjk2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTUuODU5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTA8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUxNS4zMTI1LCA0MjEuMTE3MTg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ2MS00OSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjEwLjk2ODc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy40Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdD48L3JlY3Q+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjYuOTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjE8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyNy4yMTA5Mzc1LCA0MjEuMTE3MTg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ2Mi01MSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjc1NzgxMjUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjI1NzgxMjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI4LjUxNTYyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjQ8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDYyOC41NjY0MDYyNSwgMzQzLjkyOTY4NzUpIiBpZD0iZmxvd2NoYXJ0LWlkNTgtNTMiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS40NjA5Mzc1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMy45NjA5Mzc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iNy45MjE4NzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD4yPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3MDMuNTg5ODQzNzUsIDI2My4wNzAzMTI1KSIgaWQ9ImZsb3djaGFydC1pZDQ5LTU1IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNzAzMTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC4yMDMxMjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI4LjQwNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+OTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzAzLjU4OTg0Mzc1LCAzNDMuOTI5Njg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ1OS01NyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PGNpcmNsZSBjeT0iMCIgY3g9IjAiIHI9IjExLjc2NTYyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciI+PC9jaXJjbGU+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTQuMjY1NjI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC41MzEyNSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPjY8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDc3Ny4yNjk1MzEyNSwgMjYzLjA3MDMxMjUpIiBpZD0iZmxvd2NoYXJ0LWlkNDEwLTU5IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTEuNzAzMTI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC4yMDMxMjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3Q+PC9yZWN0Pjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSI4LjQwNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+OTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzc3LjI2OTUzMTI1LCAzNDMuOTI5Njg3NSkiIGlkPSJmbG93Y2hhcnQtaWQ1MTAtNjEiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxjaXJjbGUgY3k9IjAiIGN4PSIwIiByPSIxMS45MTQwNjI1IiBzdHlsZT0iIiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIj48L2NpcmNsZT48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC40MTQwNjI1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iOC44MjgxMjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD44PC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NzcuMjY5NTMxMjUsIDQyMS4xMTcxODc1KSIgaWQ9ImZsb3djaGFydC1pZDYzLTYzIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48Y2lyY2xlIGN5PSIwIiBjeD0iMCIgcj0iMTAuOTY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiPjwvY2lyY2xlPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zLjQ2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0PjwvcmVjdD48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iNi45Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+MTwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjwvZz48L2c+PC9zdmc+\"/>\n\n\n<div class=\"markdown\"><p>As before, we use nested instance of <code>RuleNode</code> to implement the AST.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>fizzbuzz_syntaxtree = @rulenode 12{13{11{10{1,4},2},11{10{1,3},2}},9{7},12{11{10{1,3},2},9{5},12{11{10{1,4},2},9{6},9{8{1}}}}}</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-fizzbuzz_syntaxtree\">12{13{11{10{1,4},2},11{10{1,3},2}},9{7},12{11{10{1,3},2},9{5},12{11{10{1,4},2},9{6},9{8{1}}}}}</pre>\n\n\n<div class=\"markdown\"><p>And we check our syntax tree is correct:</p></div>\n\n<pre class='language-julia'><code class='language-julia'>rulenode2expr(fizzbuzz_syntaxtree, grammar_fizzbuzz)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash153198\">:(if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0\n      \"FizzBuzz\"\n  else\n      if input1 % 3 == 0\n          \"Fizz\"\n      else\n          if input1 % 5 == 0\n              \"Buzz\"\n          else\n              string(input1)\n          end\n      end\n  end)</pre>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    # test solution on inputs\n    input = [Dict(:input1 =&gt; 3), Dict(:input1 =&gt; 5), Dict(:input1 =&gt;15), Dict(:input1 =&gt; 22)]\n    output1 = execute_on_input(grammar_fizzbuzz, fizzbuzz_syntaxtree, input)\n    output1\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-output1\">4-element Vector{Any}:\n \"Fizz\"\n \"Buzz\"\n \"FizzBuzz\"\n \"22\"</pre>\n\n\n<div class=\"markdown\"><h3 id=\"Modify-the-AST/program\">Modify the AST/program</h3><p>There are several ways to modify an AST and hence, a program. You can</p><ul><li><p>directly replace a node with <code>HerbCore.swap_node()</code></p></li><li><p>insert a rule node with <code>insert!</code></p></li></ul><p>Let's modify our example such that if the input number is divisible by 3, the program returns \"Buzz\" instead of \"Fizz\".  We use <code>swap_node()</code> to replace the node of the AST that corresponds to rule 5 in the grammar (<code>String = Fizz</code>) with rule 6 (<code>String = Buzz</code>). To do so, <code>swap_node()</code> needs the tree that contains the node we want to modify, the new node we want to replace the node with, and the path to that node.</p><p>Note that <code>swap_node()</code> modifies the tree, hence we make a deep copy of it first.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    modified_fizzbuzz_syntaxtree = deepcopy(fizzbuzz_syntaxtree)\n    newnode = RuleNode(6)\n    path = [3, 2, 1]\n    swap_node(modified_fizzbuzz_syntaxtree, newnode, path)\n    rulenode2expr(modified_fizzbuzz_syntaxtree, grammar_fizzbuzz)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-newnode\">:(if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0\n      \"FizzBuzz\"\n  else\n      if input1 % 3 == 0\n          \"Buzz\"\n      else\n          if input1 % 5 == 0\n              \"Buzz\"\n          else\n              string(input1)\n          end\n      end\n  end)</pre>\n\n\n<div class=\"markdown\"><p>Let's confirm that we modified the AST, and hence the program, correctly:</p></div>\n\n<pre class='language-julia'><code class='language-julia'># test solution on same inputs as before\nexecute_on_input(grammar_fizzbuzz, modified_fizzbuzz_syntaxtree, input)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash144804\">4-element Vector{Any}:\n \"Buzz\"\n \"Buzz\"\n \"FizzBuzz\"\n \"22\"</pre>\n\n\n<div class=\"markdown\"><p>An alternative way to modify the AST is by using <code>insert!()</code>. This requires to provide the location of the node that we want to as <code>NodeLoc</code>. <code>NodeLoc</code> points to a node in the tree and consists of the parent and the child index of the node. Again, we make a deep copy of the original AST first.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    anothermodified_fizzbuzz_syntaxtree = deepcopy(fizzbuzz_syntaxtree)\n    # get the node we want to modify and instantiate a NodeLoc from it.\n    node = get_node_at_location(anothermodified_fizzbuzz_syntaxtree, [3, 2, 1])\n    nodeloc = NodeLoc(node, 0)\n    # replace the node\n    insert!(node, nodeloc, newnode)\n    rulenode2expr(anothermodified_fizzbuzz_syntaxtree, grammar_fizzbuzz)\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-anothermodified_fizzbuzz_syntaxtree\">:(if input1 % 5 == 0 &amp;&amp; input1 % 3 == 0\n      \"FizzBuzz\"\n  else\n      if input1 % 3 == 0\n          \"Buzz\"\n      else\n          if input1 % 5 == 0\n              \"Buzz\"\n          else\n              string(input1)\n          end\n      end\n  end)</pre>\n\n\n<div class=\"markdown\"><p>Again, we check that we modified the program as intended:</p></div>\n\n<pre class='language-julia'><code class='language-julia'># test on same inputs as before\nexecute_on_input(grammar_fizzbuzz, anothermodified_fizzbuzz_syntaxtree, input)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-hash112966\">4-element Vector{Any}:\n \"Buzz\"\n \"Buzz\"\n \"FizzBuzz\"\n \"22\"</pre>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/abstract_syntax_trees/","page":"Abstract Syntax Trees","title":"Abstract Syntax Trees","text":"","category":"page"},{"location":"tutorials/basic_getting_started/","page":"Getting Started","title":"Getting Started","text":"<style>\n    #documenter-page table {\n        display: table !important;\n        margin: 2rem auto !important;\n        border-top: 2pt solid rgba(0,0,0,0.2);\n        border-bottom: 2pt solid rgba(0,0,0,0.2);\n    }\n\n    #documenter-page pre, #documenter-page div {\n        margin-top: 1.4rem !important;\n        margin-bottom: 1.4rem !important;\n    }\n\n    .code-output {\n        padding: 0.7rem 0.5rem !important;\n    }\n\n    .admonition-body {\n        padding: 0em 1.25em !important;\n    }\n</style>\n\n<!-- PlutoStaticHTML.Begin -->\n<!--\n    # This information is used for caching.\n    [PlutoStaticHTML.State]\n    input_sha = \"5a5b0b4ed7d9eaf092f255f46a1168530ce1e0bcf6a06d280d7fc8788ea7f129\"\n    julia_version = \"1.12.1\"\n-->\n\n<div class=\"markdown\"><h1 id=\"Getting-Started\">Getting Started</h1><p>You can either paste this code into the Julia REPL or into a separate file, e.g. <code>get_started.jl</code>. If using a separate file you can execute using <code>julia get_started.jl</code> or <code>julia --project=. get_started.jl</code> depending on whether you installed Herb.jl globally or in a project.</p><p>To begin, we need to import <code>Herb</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>begin\n    import Pkg\n    Pkg.activate(Base.current_project())\n    Pkg.instantiate()\nend</code></pre>\n\n\n<pre class='language-julia'><code class='language-julia'>using Herb</code></pre>\n\n\n\n<div class=\"markdown\"><p>To define a program synthesis problem, we need a grammar and specification. </p><p>First, a grammar can be constructed using the <code>@csgrammar</code> macro included in <code>HerbGrammar</code>. </p><p>Here, we describe a simple integer arithmetic example, that can add and multiply an input variable <code>x</code> or the integers <code>1,2</code>, using</p></div>\n\n<pre class='language-julia'><code class='language-julia'>g = @csgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-g\">1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n</pre>\n\n\n<div class=\"markdown\"><p>Second, the problem specification can be provided using e.g. input/output examples using <code>HerbSpecification</code>. Inputs are provided as a <code>Dict</code> assigning values to variables, and outputs as arbitrary values. The problem itself is then a list of <code>IOExample</code>s using</p></div>\n\n<pre class='language-julia'><code class='language-julia'>problem = Problem([IOExample(Dict(:x =&gt; x), 2x+1) for x âˆˆ 1:5])</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-problem\">Problem{Vector{IOExample{Int64, Int64}}}(\"\", IOExample{Int64, Int64}[IOExample{Int64, Int64}(Dict(:x =&gt; 1), 3), IOExample{Int64, Int64}(Dict(:x =&gt; 2), 5), IOExample{Int64, Int64}(Dict(:x =&gt; 3), 7), IOExample{Int64, Int64}(Dict(:x =&gt; 4), 9), IOExample{Int64, Int64}(Dict(:x =&gt; 5), 11)])</pre>\n\n\n<div class=\"markdown\"><p>For the search to produce programs that use the input examples, we need to ensure that there is a rule where the right-hand side matches the symbol used in the input to the <code>IOExample</code>. For an example like <code>IOExample(Dict(:x =&gt; 1), 2)</code>, there must be some rule like <code>Number = x</code>â€“the <code>x</code>'s must match, otherwise the input value will never be used in any of the programs. If you have multiple input arguments, like <code>IOExample(Dict(:x =&gt; 1, :name =&gt; \"Alice\", \"1. Alice\"))</code>, then you need two rules, such as <code>Number = x</code> and <code>String = name</code>, to construct programs that use both inputs.</p><p>The problem is given now, let us search for a solution with <code>HerbSearch</code>. For now, we will just use the default parameters searching for a satisfying program over the grammar, given the problem and a starting symbol using</p></div>\n\n<pre class='language-julia'><code class='language-julia'>iterator = BFSIterator(g, :Number, max_depth=5)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-iterator\">BFSIterator(GenericSolver(1: Number = 1\n2: Number = 2\n3: Number = x\n4: Number = Number + Number\n5: Number = Number * Number\n, SolverState(Hole[Bool[1, 1, 1, 1, 1]], Set{AbstractLocalConstraint}(), true), DataStructures.PriorityQueue{AbstractLocalConstraint, Int64, Base.Order.ForwardOrdering}(), nothing, false, 9223372036854775807, 5))</pre>\n\n<pre class='language-julia'><code class='language-julia'>solution, flag = synth(problem, iterator)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-flag\">(4{4{1,3},3}, optimal_program)</pre>\n\n\n<div class=\"markdown\"><p>There are various ways to adapt the search technique to your needs. Please have a look at the <a href=\"@ref\"><code>synth</code></a> documentation.</p><p>Eventually, we want to test our solution on some other inputs using <code>HerbInterpret</code>. We transform our grammar <code>g</code> to a Julia expression with <code>grammar2symboltable(g)</code>, add our solution and the input, assigning the value <code>6</code> to the variable <code>x</code>.</p></div>\n\n<pre class='language-julia'><code class='language-julia'>program = rulenode2expr(solution, g)</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-program\">:((1 + x) + x)</pre>\n\n<pre class='language-julia'><code class='language-julia'>output = execute_on_input(grammar2symboltable(g), program, Dict(:x =&gt; 6))  # should yield 2*6+1</code></pre>\n<pre class=\"code-output documenter-example-output\" id=\"var-output\">13</pre>\n\n\n<div class=\"markdown\"><p>If you run the completed code it will output both the generated Julia expression and the result from assigning value.</p><p>Just like that we tackled (almost) all modules of Herb.jl.</p><h2 id=\"Where-to-go-from-here?\">Where to go from here?</h2><p>See our other tutorials!</p><h2 id=\"The-full-code-example\">The full code example</h2></div>\n\n\n<div class=\"markdown\"><pre><code class=\"language-julia\">using Herb\n\n# define our very simple context-free grammar\n# Can add and multiply an input variable x or the integers 1,2.\ng = @csgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend\n\nproblem = Problem([IOExample(Dict(:x =&gt; x), 2x+1) for x âˆˆ 1:5])\niterator = BFSIterator(g, :Number, max_depth=5)\n\nsolution, flag = synth(problem, iterator)\nprogram = rulenode2expr(solution, g)\nprintln(program)\n\noutput = execute_on_input(grammar2symboltable(g), program, Dict(:x =&gt; 6)) \nprintln(output)\n</code></pre></div>\n\n<!-- PlutoStaticHTML.End -->","category":"page"},{"location":"tutorials/basic_getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"}]
}
