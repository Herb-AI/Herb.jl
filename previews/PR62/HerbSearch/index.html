<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HerbSearch.jl · Herb.jl</title><meta name="title" content="HerbSearch.jl · Herb.jl"/><meta property="og:title" content="HerbSearch.jl · Herb.jl"/><meta property="twitter:title" content="HerbSearch.jl · Herb.jl"/><meta name="description" content="Documentation for Herb.jl."/><meta property="og:description" content="Documentation for Herb.jl."/><meta property="twitter:description" content="Documentation for Herb.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Herb.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../">Herb.jl</a></li><li><a class="tocitem" href="../install/">Installation Guide</a></li><li><a class="tocitem" href="../get_started/">Getting Started</a></li><li><a class="tocitem" href="../concepts/">Architecture and core concepts</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/getting_started_with_herb/">A more verbose getting started with Herb.jl</a></li><li><a class="tocitem" href="../tutorials/defining_grammars/">Defining Grammars in Herb.jl</a></li><li><a class="tocitem" href="../tutorials/advanced_search/">Advanced Search Procedures</a></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../HerbCore/">HerbCore.jl</a></li><li><a class="tocitem" href="../HerbGrammar/">HerbGrammar.jl</a></li><li><a class="tocitem" href="../HerbSpecification/">HerbSpecification.jl</a></li><li><a class="tocitem" href="../HerbInterpret/">HerbInterpret.jl</a></li><li><a class="tocitem" href="../HerbConstraints/">HerbConstraints.jl</a></li><li class="is-active"><a class="tocitem" href>HerbSearch.jl</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Sub-Modules</a></li><li class="is-active"><a href>HerbSearch.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>HerbSearch.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl/blob/master/docs/src/HerbSearch/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="HerbSearch_docs"><a class="docs-heading-anchor" href="#HerbSearch_docs">HerbSearch.jl Documentation</a><a id="HerbSearch_docs-1"></a><a class="docs-heading-anchor-permalink" href="#HerbSearch_docs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.BFSIterator" href="#HerbSearch.BFSIterator"><code>HerbSearch.BFSIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@programiterator BFSIterator() &lt;: TopDownIterator</code></pre><p>Returns a breadth-first iterator given a grammar and a starting symbol. Returns trees in the grammar in increasing order of size. Inherits all stop-criteria from TopDownIterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.DFSIterator" href="#HerbSearch.DFSIterator"><code>HerbSearch.DFSIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@programiterator DFSIterator() &lt;: TopDownIterator</code></pre><p>Returns a depth-first search enumerator given a grammar and a starting symbol. Returns trees in the grammar in decreasing order of size. Inherits all stop-criteria from TopDownIterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.ExpandFailureReason" href="#HerbSearch.ExpandFailureReason"><code>HerbSearch.ExpandFailureReason</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum ExpandFailureReason limit_reached=1 already_complete=2</code></pre><p>Representation of the different reasons why expanding a partial tree failed.  Currently, there are two possible causes of the expansion failing:</p><ul><li><code>limit_reached</code>: The depth limit or the size limit of the partial tree would   be violated by the expansion</li><li><code>already_complete</code>: There is no hole left in the tree, so nothing can be   expanded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.GeneticSearchIterator" href="#HerbSearch.GeneticSearchIterator"><code>HerbSearch.GeneticSearchIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneticSearchIterator{FitnessFunction,CrossOverFunction,MutationFunction,SelectParentsFunction,EvaluationFunction} &lt;: ProgramIterator</code></pre><p>Defines an <a href="#HerbSearch.ProgramIterator"><code>ProgramIterator</code></a> using genetic search. </p><p>Consists of:</p><ul><li><p><code>examples::Vector{&lt;:IOExample}</code>: a collection of examples defining the specification </p></li><li><p><code>evaluation_function::EvaluationFunction</code>: interpreter to evaluate the individual programs</p></li><li><p><code>population_size::Int64</code>: number of inviduals in the population</p></li><li><p><code>mutation_probability::Float64</code>: probability of mutation for each individual</p></li><li><p><code>maximum_initial_population_depth::Int64</code>: maximum depth of trees when population is initialized </p></li></ul><p>end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L9-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.MHSearchIterator" href="#HerbSearch.MHSearchIterator"><code>HerbSearch.MHSearchIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MHSearchIterator(examples::AbstractArray{&lt;:IOExample}, cost_function::Function, evaluation_function::Function=HerbInterpret.execute_on_input)</code></pre><p>Returns an enumerator that runs according to the Metropolis Hastings algorithm.</p><ul><li><code>spec</code> : array of examples</li><li><code>cost_function</code> : cost function to evaluate the programs proposed</li><li><code>evaluation_function</code> : evaluation function that evaluates the program generated and produces an output</li></ul><p>The propose function is random<em>fill</em>propose and the accept function is probabilistic. The temperature value of the algorithm remains constant over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_iterator.jl#L155-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.MLFSIterator" href="#HerbSearch.MLFSIterator"><code>HerbSearch.MLFSIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@programiterator MLFSIterator() &lt;: TopDownIterator</code></pre><p>Iterator that enumerates expressions in the grammar in decreasing order of probability (Only use this iterator with probabilistic grammars). Inherits all stop-criteria from TopDownIterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.PriorityQueueItem" href="#HerbSearch.PriorityQueueItem"><code>HerbSearch.PriorityQueueItem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PriorityQueueItem</code></pre><p>Represents an item in the priority enumerator priority queue. An item contains of:</p><ul><li><code>tree</code>: A partial AST</li><li><code>size</code>: The size of the tree. This is a cached value which prevents  having to traverse the entire tree each time the size is needed.</li><li><code>constraints</code>: The local constraints that apply to this tree.   These constraints are enforced each time the tree is modified.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L148-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.PriorityQueueItem-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.PriorityQueueItem-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.PriorityQueueItem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PriorityQueueItem(tree::AbstractRuleNode, size::Int)</code></pre><p>Constructs <a href="#HerbSearch.PriorityQueueItem"><code>PriorityQueueItem</code></a> given only a tree and the size, but no constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.ProgramIterator" href="#HerbSearch.ProgramIterator"><code>HerbSearch.ProgramIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ProgramIterator</code></pre><p>Generic iterator for all possible search strategies.     All iterators are expected to have the following fields:</p><ul><li><code>grammar::ContextSensitiveGrammar</code>: the grammar to search over</li><li><code>sym::Symbol</code>: defines the start symbol from which the search should be started </li><li><code>max_depth::Int</code>: maximum depth of program trees</li><li><code>max_size::Int</code>: maximum number of <a href="../HerbCore/#HerbCore.AbstractRuleNode"><code>AbstractRuleNode</code></a>s of program trees</li><li><code>max_time::Int</code>: maximum time the iterator may take</li><li><code>max_enumerations::Int</code>: maximum number of enumerations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/program_iterator.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.PropagateResult" href="#HerbSearch.PropagateResult"><code>HerbSearch.PropagateResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum PropagateResult tree_complete=1 tree_incomplete=2 tree_infeasible=3</code></pre><p>Representation of the possible results of a constraint propagation.  At the moment there are three possible outcomes:</p><ul><li><code>tree_complete</code>: The propagation was applied successfully and the tree does not contain any holes anymore. Thus no constraints can be applied anymore.</li><li><code>tree_incomplete</code>: The propagation was applied successfully and the tree does contain more holes. Thus more constraints may be applied to further prune the respective domains.</li><li><code>tree_infeasible</code>: The propagation was succesful, but there are holes with empty domains. Hence, the tree is now infeasible.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L133-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.SASearchIterator" href="#HerbSearch.SASearchIterator"><code>HerbSearch.SASearchIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SASearchIterator(spec, cost_function, initial_temperature=1, temperature_decreasing_factor = 0.99, evaluation_function::Function=HerbInterpret.execute_on_input)</code></pre><p>Returns an enumerator that runs according to the Simulated Annealing Search algorithm.</p><ul><li><code>spec</code> : array of examples</li><li><code>cost_function</code> : cost function to evaluate the programs proposed</li><li><code>initial_temperature</code> : the starting temperature of the algorithm</li><li><code>temperature_decreasing_factor</code> : the decreasing factor of the temperature of the time</li><li><code>evaluation_function</code> : evaluation function that evaluates the program generated and produces an output</li></ul><p>The propose function is <code>random_fill_propose</code> (the same as for Metropolis Hastings). The accept function is probabilistic but takes into account the tempeerature too.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_iterator.jl#L206-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.StochasticSearchIterator" href="#HerbSearch.StochasticSearchIterator"><code>HerbSearch.StochasticSearchIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type StochasticSearchIterator &lt;: ProgramIterator</code></pre><p>A unified abstract type for the algorithms Metropolis Hastings, Very Large Scale Neighbourhood and Simulated Annealing.  Each algorithm implements <code>neighbourhood</code>, <code>propose</code>, <code>accept</code> and <code>temperature</code> functions. Below the signatures of each function is shown.</p><p><strong>Signatures</strong></p><hr/><p>Returns a node location from the program that is the neighbourhood. It can also return other information using  <code>dict</code></p><p><strong>neighbourhood(iter::T, current_program::RuleNode) where T &lt;: StochasticSearchIterator -&gt; (loc::NodeLocation, dict::Dict)</strong></p><p>Proposes a list of programs using the location provided by <code>neighbourhood</code> and the <code>dict</code>.</p><pre><code class="nohighlight hljs">propose(iter::T, current_program::RuleNode, neighbourhood_node_loc::NodeLoc, dmap::AbstractVector{Int}, dict::Union{Nothing,Dict{String,Any}}) where T &lt;: StochasticSearchIterator -&gt; Iter[RuleNode]</code></pre><hr/><p>Based on the current program and possible cost and temperature it accepts the program or not. Usually we would always want to accept better programs but we might get stuck if we do so. That is why some implementations of the <code>accept</code> function accept with a probability  costs that are worse.  <code>cost</code> means how different are the outcomes of the program compared to the correct outcomes. The lower the <code>cost</code> the better the program performs on the examples. The <code>cost</code> is provided by the <code>cost_function</code></p><p><strong>accept(::T, current<em>cost::Real, next</em>cost::Real, temperature::Real) where T &lt;: StochasticSearchIterator -&gt; Bool</strong></p><p>Returns the new temperature based on the previous temperature. Higher the <code>temperature</code> means that the algorithm will explore more.</p><p><strong>temperature(::T, current_temperature::Real) where T &lt;: StochasticSearchIterator -&gt; Real</strong></p><p>Returns the cost of the current program. It receives a list of tuples <code>(expected, found)</code> and gives back a cost.</p><pre><code class="nohighlight hljs">cost_function(outcomes::Tuple{&lt;:Number,&lt;:Number}[]) -&gt; Real</code></pre><hr/><p><strong>Fields</strong></p><ul><li><p><code>grammar::ContextSensitiveGrammar</code> grammar that the algorithm uses</p></li><li><p><code>sym::Symbol</code> the start symbol of the algorithm <code>:Real</code> or <code>:Int</code></p></li><li><p><code>examples::Vector{IOExample}</code> example used to check the program</p></li><li><p><code>cost_function::Function</code></p></li><li><p><code>initial_temperature::Real</code> = 1 </p></li><li><p><code>evaluation_function</code>::Function that evaluates the julia expressions</p></li></ul><p>An iterator over all possible expressions of a grammar up to max<em>depth with start symbol sym. Also inherits all stop criteria like `max</em>depth<code>from</code>ProgramIterator`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_iterator.jl#L3-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.SynthResult" href="#HerbSearch.SynthResult"><code>HerbSearch.SynthResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum SynthResult optimal_program=1 suboptimal_program=2</code></pre><p>Representation of the possible results of the synth procedure.  At the moment there are two possible outcomes:</p><ul><li><code>optimal_program</code>: The synthesized program satisfies the entire program specification.</li><li><code>suboptimal_program</code>: The synthesized program does not satisfy the entire program specification, but got the best score from the evaluator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/search_procedure.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.TopDownIterator" href="#HerbSearch.TopDownIterator"><code>HerbSearch.TopDownIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct TopDownIterator &lt;: ProgramIterator</code></pre><p>Enumerates a context-free grammar starting at <a href="@ref"><code>Symbol</code></a> <code>sym</code> with respect to the grammar up to a given depth and a given size.  The exploration is done using the given priority function for derivations, and the expand function for discovered nodes. Concrete iterators may overload the following methods:</p><ul><li>priority_function</li><li>derivation_heuristic</li><li>hole_heuristic</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.VLSNSearchIterator" href="#HerbSearch.VLSNSearchIterator"><code>HerbSearch.VLSNSearchIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VLSNSearchIterator(spec, cost_function, enumeration_depth = 2, evaluation_function::Function=HerbInterpret.execute_on_input) = StochasticSearchIterator(</code></pre><p>Returns an iterator that runs according to the Very Large Scale Neighbourhood Search algorithm.</p><ul><li><code>spec</code> : array of examples</li><li><code>cost_function</code> : cost function to evaluate the programs proposed</li><li><code>vlsn_neighbourhood_depth</code> : the enumeration depth to search for a best program at a time</li><li><code>evaluation_function</code> : evaluation function that evaluates the program generated and produces an output</li></ul><p>The propose function consists of all possible programs of the given <code>enumeration_depth</code>. The accept function accepts the program with the lowest cost according to the <code>cost_function</code>. The temperature value of the algorithm remains constant over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_iterator.jl#L179-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.@programiterator-Tuple{Any, Any}" href="#HerbSearch.@programiterator-Tuple{Any, Any}"><code>HerbSearch.@programiterator</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@programiterator</code></pre><p>Canonical way of creating a program iterator. The macro automatically declares the expected fields listed in the <code>ProgramIterator</code> documentation. Syntax accepted by the macro is as follows (anything enclosed in square brackets is optional):     <code>@programiterator [mutable] &lt;IteratorName&gt;(         &lt;arg₁&gt;,         ...,         &lt;argₙ&gt;     ) [&lt;: &lt;SupertypeIterator&gt;]</code> Note that the macro emits an assertion that the <code>SupertypeIterator</code>  is a subtype of <code>ProgramIterator</code> which otherwise throws an ArgumentError. If no supertype is given, the new iterator extends <code>ProgramIterator</code> directly. Each &lt;argᵢ&gt; may be (almost) any expression valid in a struct declaration, and they must be comma separated. One known exception is that an inner constructor must always be given using the extended <code>function &lt;name&gt;(...) ... end</code> syntax. The <code>mutable</code> keyword determines whether the declared struct is mutable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/program_iterator.jl#L20-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{GeneticSearchIterator, HerbSearch.GeneticIteratorState}" href="#Base.iterate-Tuple{GeneticSearchIterator, HerbSearch.GeneticIteratorState}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::GeneticSearchIterator, current_state::GeneticIteratorState)</code></pre><p>Iterates the search space using a genetic algorithm. Takes the iterator and the current state to mutate and crossover random inviduals. Returns the best program-so-far and the state of the iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{GeneticSearchIterator}" href="#Base.iterate-Tuple{GeneticSearchIterator}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::GeneticSearchIterator)</code></pre><p>Iterates the search space using a genetic algorithm. First generates a population sampling random programs. Returns the best program-so-far, and the state of the iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{HerbSearch.StochasticSearchIterator, HerbSearch.IteratorState}" href="#Base.iterate-Tuple{HerbSearch.StochasticSearchIterator, HerbSearch.IteratorState}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::StochasticSearchIterator, current_state::IteratorState)</code></pre><p>The algorithm that constructs the iterator of StochasticSearchIterator. It has the following structure:</p><ol><li>get a random node location -&gt; location,dict = neighbourhood(current_program)</li><li>call propose on the current program getting a list of possbile replacements in the node location </li><li>iterate through all the possible replacements and perform the replacement in the current program </li><li>accept the new program by modifying the next_program or reject the new program</li><li>return the new next_program</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_iterator.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{TopDownIterator, DataStructures.PriorityQueue}" href="#Base.iterate-Tuple{TopDownIterator, DataStructures.PriorityQueue}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::TopDownIterator, pq::DataStructures.PriorityQueue)</code></pre><p>Describes the iteration for a given <a href="#HerbSearch.TopDownIterator"><code>TopDownIterator</code></a> and a <a href="@ref"><code>PriorityQueue</code></a> over the grammar without enqueueing new items to the priority queue. Recursively returns the result for the priority queue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{TopDownIterator}" href="#Base.iterate-Tuple{TopDownIterator}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::TopDownIterator)</code></pre><p>Describes the iteration for a given <a href="#HerbSearch.TopDownIterator"><code>TopDownIterator</code></a> over the grammar. The iteration constructs a <a href="@ref"><code>PriorityQueue</code></a> first and then prunes it propagating the active constraints. Recursively returns the result for the priority queue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand(::Type{RuleNode}, grammar::AbstractGrammar, max_depth::Int=10)</code></pre><p>Generates a random <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> of arbitrary type and maximum depth max_depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/sampling_grammar.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand(::Type{RuleNode}, grammar::AbstractGrammar, typ::Symbol, max_depth::Int=10)</code></pre><p>Generates a random <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> of return type typ and maximum depth max_depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/sampling_grammar.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand(::Type{RuleNode}, grammar::AbstractGrammar, typ::Symbol, dmap::AbstractVector{Int}, max_depth::Int=10)</code></pre><p>Generates a random <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a>, i.e. an expression tree, of root type typ and maximum depth max_depth guided by a depth map dmap if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/sampling_grammar.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch._calculate_cost-Tuple{RuleNode, Function, AbstractVector{IOExample}, AbstractGrammar, Function}" href="#HerbSearch._calculate_cost-Tuple{RuleNode, Function, AbstractVector{IOExample}, AbstractGrammar, Function}"><code>HerbSearch._calculate_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calculate_cost(program::RuleNode, cost_function::Function, spec::AbstractVector{IOExample}, grammar::AbstractGrammar, evaluation_function::Function)</code></pre><p>Returns the cost of the <code>program</code> using the examples and the <code>cost_function</code>. It first convert the program to an expression and evaluates it on all the examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_iterator.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, TopDownIterator}" href="#HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, TopDownIterator}"><code>HerbSearch._expand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_expand(node::Hole, grammar::ContextSensitiveGrammar, ::Int, max_holes::Int, context::GrammarContext, iter::TopDownIterator)::Union{ExpandFailureReason, Vector{TreeConstraints}}</code></pre><p>Expands a given hole that was found in <a href="#HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, TopDownIterator}"><code>_expand</code></a> using the given derivation heuristic. Returns the list of discovered nodes in that order and with their respective constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L377-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch._expand-Tuple{RuleNode, ContextSensitiveGrammar, Int64, Int64, GrammarContext, TopDownIterator}" href="#HerbSearch._expand-Tuple{RuleNode, ContextSensitiveGrammar, Int64, Int64, GrammarContext, TopDownIterator}"><code>HerbSearch._expand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_expand(root::RuleNode, grammar::ContextSensitiveGrammar, max_depth::Int, max_holes::Int, context::GrammarContext, iter::TopDownIterator)::Union{ExpandFailureReason, Vector{TreeConstraints}}</code></pre><p>Recursive expand function used in multiple enumeration techniques. Expands one hole/undefined leaf of the given RuleNode tree found using the given hole heuristic. If the expansion was successful, returns a list of new trees and a list of lists of hole locations, corresponding to the holes of each newly expanded tree.  Returns <code>nothing</code> if tree is already complete (i.e. contains no holes). Returns an empty list if the tree is partial (i.e. contains holes), but they could not be expanded because of the depth limit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L324-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch._find_next_complete_tree-Tuple{ContextSensitiveGrammar, Int64, Int64, DataStructures.PriorityQueue, TopDownIterator}" href="#HerbSearch._find_next_complete_tree-Tuple{ContextSensitiveGrammar, Int64, Int64, DataStructures.PriorityQueue, TopDownIterator}"><code>HerbSearch._find_next_complete_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_find_next_complete_tree(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, pq::PriorityQueue, iter::TopDownIterator)::Union{Tuple{RuleNode, PriorityQueue}, Nothing}</code></pre><p>Takes a priority queue and returns the smallest AST from the grammar it can obtain from the queue or by (repeatedly) expanding trees that are in the queue. Returns <code>nothing</code> if there are no trees left within the depth limit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L276-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.best_accept-Tuple{Real, Real, Real}" href="#HerbSearch.best_accept-Tuple{Real, Real, Real}"><code>HerbSearch.best_accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">best_accept(current_cost::Real, next_cost::Real, temperature::Real)</code></pre><p>Returns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns false.</p><p><strong>Arguments</strong></p><ul><li><code>current_cost::Real</code>: the cost of the current program.</li><li><code>next_cost::Real</code>: the cost of the proposed program.</li><li><code>temperature::Real</code>: the temperature; not used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/accept.jl#L37-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.calculate_cost-Union{Tuple{T}, Tuple{T, RuleNode}} where T&lt;:HerbSearch.StochasticSearchIterator" href="#HerbSearch.calculate_cost-Union{Tuple{T}, Tuple{T, RuleNode}} where T&lt;:HerbSearch.StochasticSearchIterator"><code>HerbSearch.calculate_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_cost(iter::T, program::RuleNode) where T &lt;: StochasticSearchIterator</code></pre><p>Wrapper around <a href="#HerbSearch._calculate_cost-Tuple{RuleNode, Function, AbstractVector{IOExample}, AbstractGrammar, Function}"><code>_calculate_cost</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_iterator.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.const_temperature-Tuple{Real}" href="#HerbSearch.const_temperature-Tuple{Real}"><code>HerbSearch.const_temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">const_temperature(current_temperature::Real)</code></pre><p>Returns the temperature unchanged. This function is used by Metropolis Hastings and Very Large Neighbourhood Search algorithms.</p><p><strong>Arguments</strong></p><ul><li><code>current_temperature::Real</code>: the current temperature of the search.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/temperature.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.constructNeighbourhood-Tuple{RuleNode, AbstractGrammar}" href="#HerbSearch.constructNeighbourhood-Tuple{RuleNode, AbstractGrammar}"><code>HerbSearch.constructNeighbourhood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructNeighbourhood(current_program::RuleNode, grammar::AbstractGrammar)</code></pre><p>The neighbourhood node location is chosen at random. The dictionary is nothing.</p><p><strong>Arguments</strong></p><ul><li><code>current_program::RuleNode</code>: the current program.</li><li><code>grammar::AbstractGrammar</code>: the grammar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/neighbourhood.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, AbstractGrammar}" href="#HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, AbstractGrammar}"><code>HerbSearch.constructNeighbourhoodRuleSubset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructNeighbourhoodRuleSubset(current_program::RuleNode, grammar::AbstractGrammar)</code></pre><p>The neighbourhood node location is chosen at random. The dictionary is contains one entry with key &quot;rule_subset&quot; and value of type Vector{Any} being a random subset of grammar rules.</p><p><strong>Arguments</strong></p><ul><li><code>current_program::RuleNode</code>: the current program.</li><li><code>grammar::AbstractGrammar</code>: the grammar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/neighbourhood.jl#L24-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.count_expressions-Tuple{AbstractGrammar, Int64, Int64, Symbol}" href="#HerbSearch.count_expressions-Tuple{AbstractGrammar, Int64, Int64, Symbol}"><code>HerbSearch.count_expressions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_expressions(grammar::AbstractGrammar, max_depth::Int, max_size::Int, sym::Symbol)</code></pre><p>Counts and returns the number of possible expressions of a grammar up to max_depth with start symbol sym.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/count_expressions.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.count_expressions-Tuple{ProgramIterator}" href="#HerbSearch.count_expressions-Tuple{ProgramIterator}"><code>HerbSearch.count_expressions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_expressions(iter::ProgramIterator)</code></pre><p>Counts and returns the number of possible expressions in the expression iterator. The Iterator is not modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/count_expressions.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.cross_over-Tuple{GeneticSearchIterator, RuleNode, RuleNode}" href="#HerbSearch.cross_over-Tuple{GeneticSearchIterator, RuleNode, RuleNode}"><code>HerbSearch.cross_over</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cross_over(::GeneticSearchIterator, parent_1::RuleNode, parent_2::RuleNode)</code></pre><p>Combines the program from two parent individuals to create one or more offspring individuals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}" href="#HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crossover_swap_children_1(parent_1::RuleNode, parent_2::RuleNode)</code></pre><p>Performs a random crossover of two parents of type <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a>. The subprograms are swapped and only one altered parent program is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_functions/crossover.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}" href="#HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crossover_swap_children_2(parent_1::RuleNode, parent_2::RuleNode)</code></pre><p>Performs a random crossover of two parents of type <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a>. The subprograms are swapped and both altered parent programs are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_functions/crossover.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.decreasing_temperature-Tuple{Real}" href="#HerbSearch.decreasing_temperature-Tuple{Real}"><code>HerbSearch.decreasing_temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decreasing_temperature(percentage::Real)</code></pre><p>Returns a function that produces a temperature decreased by <code>percentage</code>%. This function is used by the Simmulated Annealing algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>percentage::Real</code>: the percentage to decrease the temperature by.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/temperature.jl#L18-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.default_fitness-Tuple{Any, Any}" href="#HerbSearch.default_fitness-Tuple{Any, Any}"><code>HerbSearch.default_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_fitness(program, results)</code></pre><p>Defines the default fitness function taking the program and its results. Results are a vector of tuples, where each tuple is in the form <code>Tuple{expected_output, actual_output}</code>. As we are looking for individuals with the highest fitness function, the error is inverted. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_functions/fitness.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.derivation_heuristic-Tuple{TopDownIterator, Vector{RuleNode}, GrammarContext}" href="#HerbSearch.derivation_heuristic-Tuple{TopDownIterator, Vector{RuleNode}, GrammarContext}"><code>HerbSearch.derivation_heuristic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivation_heuristic(::TopDownIterator, nodes::Vector{RuleNode}, ::GrammarContext)::Vector{AbstractRuleNode}</code></pre><p>Returns an ordered sublist of <code>nodes</code>, based on which ones are most promising to fill the hole at the given <code>context</code>.</p><ul><li><code>nodes::Vector{RuleNode}</code>: a list of nodes the hole can be filled with</li><li><code>context::GrammarContext</code>: holds the location of the to be filled hole</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.enumerate_neighbours_propose-Tuple{Int64}" href="#HerbSearch.enumerate_neighbours_propose-Tuple{Int64}"><code>HerbSearch.enumerate_neighbours_propose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enumerate_neighbours_propose(enumeration_depth::Int64)</code></pre><p>The return function is a function that produces a list with all the subprograms with depth at most <code>enumeration_depth</code>.</p><p><strong>Arguments</strong></p><ul><li><code>enumeration_depth::Int64</code>: the maximum enumeration depth.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/propose.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.evaluate-Tuple{Problem{Vector{IOExample}}, Any, Dict{Symbol, Any}}" href="#HerbSearch.evaluate-Tuple{Problem{Vector{IOExample}}, Any, Dict{Symbol, Any}}"><code>HerbSearch.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(problem::Problem{Vector{IOExample}}, expr::Any, tab::SymbolTable; allow_evaluation_errors::Bool=false)</code></pre><p>Evaluate the expression on the examples.</p><p>Optional parameters:</p><pre><code class="nohighlight hljs">- `shortcircuit` - Whether to stop evaluating after finding single example fails, to speed up the [synth](@ref) procedure. If true, the returned score is an underapproximation of the actual score.
- `allow_evaluation_errors` - Whether the search should continue if an exception is thrown in the evaluation or throw the error</code></pre><p>Returns a score in the interval [0, 1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/evaluate.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.extractname-Tuple{Any}" href="#HerbSearch.extractname-Tuple{Any}"><code>HerbSearch.extractname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractname(ex)</code></pre><p>Extracts the name of a field declaration, otherwise throws an <code>ArgumentError</code>. A field declaration is of the form <code>&lt;name&gt;[::&lt;type&gt;]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/program_iterator.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.fitness-Tuple{GeneticSearchIterator, RuleNode, AbstractVector{&lt;:Tuple{Any, Any}}}" href="#HerbSearch.fitness-Tuple{GeneticSearchIterator, RuleNode, AbstractVector{&lt;:Tuple{Any, Any}}}"><code>HerbSearch.fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fitness(::GeneticSearchIterator, program, results)</code></pre><p>Assigns a numerical value (fitness score) to each individual based on how closely it meets the desired objective.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.get_best_program-Tuple{Array{RuleNode}, GeneticSearchIterator}" href="#HerbSearch.get_best_program-Tuple{Array{RuleNode}, GeneticSearchIterator}"><code>HerbSearch.get_best_program</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_best_program(population::Array{RuleNode}, iter::GeneticSearchIterator)::RuleNode</code></pre><p>Returns the best program within the population with respect to the fitness function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_leftmost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heuristic_leftmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over holes, where the left-most hole always gets considered first. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found. This is the default option for enumerators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/heuristics.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_random</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heuristic_random(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over holes, where random holes get chosen randomly using random exploration. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/heuristics.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_rightmost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heuristic_rightmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over holes, where the right-most hole always gets considered first. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/heuristics.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_smallest_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heuristic_smallest_domain(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over all available holes in the unfinished AST, by considering the size of their respective domains. A domain here describes the number of possible derivations with respect to the constraints. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/heuristics.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.hole_heuristic-Tuple{TopDownIterator, AbstractRuleNode, Int64}" href="#HerbSearch.hole_heuristic-Tuple{TopDownIterator, AbstractRuleNode, Int64}"><code>HerbSearch.hole_heuristic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hole_heuristic(::TopDownIterator, node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over holes. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.is_field_decl-Tuple{Any}" href="#HerbSearch.is_field_decl-Tuple{Any}"><code>HerbSearch.is_field_decl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_field_decl(ex)</code></pre><p>Check if <code>extractname(ex)</code> returns a name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/program_iterator.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.mean_squared_error-Tuple{AbstractVector{&lt;:Tuple{Number, Number}}}" href="#HerbSearch.mean_squared_error-Tuple{AbstractVector{&lt;:Tuple{Number, Number}}}"><code>HerbSearch.mean_squared_error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean_squared_error(results::AbstractVector{Tuple{&lt;:Number,&lt;:Number}})</code></pre><p>Returns the mean squared error of <code>results</code>.</p><p><strong>Arguments</strong></p><ul><li><code>results&lt;:AbstractVector{&lt;:Tuple{Number,Number}}</code>: the vector of tuples, where each tuple is in the form <code>Tuple{expected_output, actual_output}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/cost_functions.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.misclassification-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})" href="#HerbSearch.misclassification-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})"><code>HerbSearch.misclassification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">misclassification(results::AbstractVector{Tuple{&lt;:Number,&lt;:Number}})</code></pre><p>Returns the amount of misclassified examples, i.e. how many tuples with non-matching entries are there in <code>results</code>.</p><p><strong>Arguments</strong></p><ul><li><code>results&lt;:AbstractVector{&lt;:Tuple{Number,Number}}</code>: the vector of tuples, where each tuple is in the form <code>Tuple{expected_output, actual_output}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/cost_functions.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.mutate!" href="#HerbSearch.mutate!"><code>HerbSearch.mutate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mutate!(::GeneticSearchIterator, program::RuleNode, grammar::AbstractGrammar, max_depth::Int = 2)</code></pre><p>Mutates the program of an invididual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.mutate_random!" href="#HerbSearch.mutate_random!"><code>HerbSearch.mutate_random!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mutate_random!(program::RuleNode, grammar::AbstractGrammar, max_depth::Int64 = 2)</code></pre><p>Mutates the given program by inserting a randomly generated sub-program at a random location.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_functions/mutation.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.priority_function-Tuple{BFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}" href="#HerbSearch.priority_function-Tuple{BFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.priority_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">priority_function(::BFSIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}})</code></pre><p>Assigns priority such that the search tree is traversed like in a BFS manner</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.priority_function-Tuple{DFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}" href="#HerbSearch.priority_function-Tuple{DFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.priority_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">priority_function(::DFSIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}})</code></pre><p>Assigns priority such that the search tree is traversed like in a DFS manner</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.priority_function-Tuple{MLFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}" href="#HerbSearch.priority_function-Tuple{MLFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.priority_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">priority_function(::MLFSIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}})</code></pre><p>Calculates logit for all possible derivations for a node in a tree and returns them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.priority_function-Tuple{TopDownIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}" href="#HerbSearch.priority_function-Tuple{TopDownIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.priority_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">priority_function(::TopDownIterator, g::AbstractGrammar, tree::AbstractRuleNode, parent_value::Union{Real, Tuple{Vararg{Real}}})</code></pre><p>Assigns a priority value to a <code>tree</code> that needs to be considered later in the search. Trees with the lowest priority value are considered first.</p><ul><li><code>g</code>: The grammar used for enumeration</li><li><code>tree</code>: The tree that is about to be stored in the priority queue</li><li><code>parent_value</code>: The priority value of the parent <a href="#HerbSearch.PriorityQueueItem"><code>PriorityQueueItem</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}" href="#HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probabilistic_accept(current_cost::Real, next_cost::Real, temperature::Real)</code></pre><p>Probabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program. Returns <code>True</code> if the new program is accepted, <code>False</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>current_cost::Real</code>: the cost of the current program.</li><li><code>next_cost::Real</code>: the cost of the proposed program.</li><li><code>temperature::Real</code>: the temperature; not used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/accept.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}" href="#HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probabilistic_accept_with_temperature(current_cost::Real, next_cost::Real, temperature::Real)</code></pre><p>Returns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns true with the probability equal to: </p><p class="math-container">\[1 / (1 + exp(delta / temperature))\]</p><p>In any other case, returns false.</p><p><strong>Arguments</strong></p><ul><li><code>current_cost::Real</code>: the cost of the current program.</li><li><code>next_cost::Real</code>: the cost of the proposed program.</li><li><code>temperature::Real</code>: the temperature of the search.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/accept.jl#L51-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}" href="#HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature_fraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probabilistic_accept_with_temperature_fraction(current_cost::Real, program_to_consider_cost::Real, temperature::Real)</code></pre><p>Probabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program multiplied by the temperature. Returns <code>True</code> if the new program is accepted, <code>False</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>current_cost::Real</code>: the cost of the current program.</li><li><code>next_cost::Real</code>: the cost of the proposed program.</li><li><code>temperature::Real</code>: the current temperature </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/accept.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.processkwarg!-Tuple{Vector{Expr}, Union{Expr, Symbol}}" href="#HerbSearch.processkwarg!-Tuple{Vector{Expr}, Union{Expr, Symbol}}"><code>HerbSearch.processkwarg!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">processkwarg!(keywords::Vector{Expr}, ex::Union{Expr, Symbol})</code></pre><p>Checks if <code>ex</code> has a default value specified, if so it returns only the field declaration,  and pushes <code>ex</code> to <code>keywords</code>. Otherwise it returns <code>ex</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/program_iterator.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.propagate_constraints" href="#HerbSearch.propagate_constraints"><code>HerbSearch.propagate_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function propagate_constraints(root::AbstractRuleNode, grammar::ContextSensitiveGrammar, local_constraints::Set{LocalConstraint}, max_holes::Int, filled_hole::Union{HoleReference, Nothing}=nothing)::Tuple{PropagateResult, Set{LocalConstraint}}</code></pre><p>Propagates a set of local constraints recursively to all children of a given root node. As <code>propagate_constraints</code> gets often called when a hole was just filled, <code>filled_hole</code> helps keeping track to propagate the constraints to relevant nodes, e.g. children of <code>filled_hole</code>. <code>max_holes</code> makes sure that <code>max_size</code> of <a href="#Base.iterate-Tuple{GeneticSearchIterator, HerbSearch.GeneticIteratorState}"><code>Base.iterate</code></a> is not violated.  The function returns the <a href="#HerbSearch.PropagateResult"><code>PropagateResult</code></a> and the set of relevant <a href="../HerbConstraints/#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/top_down_iterator.jl#L210-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.random_fill_propose-Tuple{RuleNode, NodeLoc, AbstractGrammar, Int64, AbstractVector{Int64}, Union{Nothing, Dict{String, Any}}}" href="#HerbSearch.random_fill_propose-Tuple{RuleNode, NodeLoc, AbstractGrammar, Int64, AbstractVector{Int64}, Union{Nothing, Dict{String, Any}}}"><code>HerbSearch.random_fill_propose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_fill_propose(current_program::RuleNode, neighbourhood_node_loc::NodeLoc, grammar::AbstractGrammar, max_depth::Int, dmap::AbstractVector{Int}, dict::Union{Nothing,Dict{String,Any}})</code></pre><p>Returns a list with only one proposed, completely random, subprogram.</p><p><strong>Arguments</strong></p><ul><li><code>current_program::RuleNode</code>: the current program.</li><li><code>neighbourhood_node_loc::NodeLoc</code>: the location of the program to replace.</li><li><code>grammar::AbstractGrammar</code>: the grammar used to create programs.</li><li><code>max_depth::Int</code>: the maximum depth of the resulting programs.</li><li><code>dmap::AbstractVector{Int} : the minimum possible depth to reach for each rule</code></li><li><code>dict::Dict{String, Any}</code>: the dictionary with additional arguments; not used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/stochastic_functions/propose.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{&lt;:Real}}" href="#HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_chromosome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_chromosome(population::Array{RuleNode}, fitness_array::Array{&lt;:Real})::RuleNode</code></pre><p>Selects a chromosome (individual) from the population based on a fitness array. The function uses a fitness-proportionate selection strategy, often referred to as &quot;roulette wheel&quot; selection. Assumes <code>fitness_array</code> to be normalized already.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_functions/select_parents.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{&lt;:Real}}" href="#HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_fitness_proportional_parents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_fitness_proportional_parents(population::Array{RuleNode}, fitness_array::Array{&lt;:Real})::Tuple{RuleNode,RuleNode}</code></pre><p>Selects two parent chromosomes (individuals) from a population based on fitness-proportionate selection. The selected parents can be used for genetic crossover in the next steps of the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_functions/select_parents.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.select_parents-Tuple{GeneticSearchIterator, Array{RuleNode}, Array{&lt;:Real}}" href="#HerbSearch.select_parents-Tuple{GeneticSearchIterator, Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_parents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_parents(::GeneticSearchIterator, population::Array{RuleNode}, fitness_array::Array{&lt;:Real})</code></pre><p>Selects two parents for the crossover.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.synth-Tuple{Problem, ProgramIterator}" href="#HerbSearch.synth-Tuple{Problem, ProgramIterator}"><code>HerbSearch.synth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">synth(problem::Problem, iterator::ProgramIterator; shortcircuit::Bool=true, allow_evaluation_errors::Bool=false, mod::Module=Main)::Union{Tuple{RuleNode, SynthResult}, Nothing}</code></pre><p>Synthesize a program that satisfies the maximum number of examples in the problem.         - problem                 - The problem definition with IO examples         - iterator                - The iterator that will be used         - shortcircuit            - Whether to stop evaluating after finding a single example that fails, to speed up the <a href="#HerbSearch.synth-Tuple{Problem, ProgramIterator}">synth</a> procedure. If true, the returned score is an underapproximation of the actual score.         - allow<em>evaluation</em>errors - Whether the search should crash if an exception is thrown in the evaluation         - mod                     - A module containing definitions for the functions in the grammar that do not exist in Main</p><p>Returns a tuple of the rulenode representing the solution program and a synthresult that indicates if that program is optimal. <code>synth</code> uses <code>evaluate</code> which returns a score in the interval [0, 1] and checks whether that score reaches 1. If not it will return the best program so far, with the proper flag</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/search_procedure.jl#L12-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="HerbSearch.validate_iterator-Tuple{Any}" href="#HerbSearch.validate_iterator-Tuple{Any}"><code>HerbSearch.validate_iterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_iterator(iter)</code></pre><p>Validates the parameters of the iterator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/genetic_search_iterator.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(root::RuleNode, typ::Symbol, grammar::AbstractGrammar, maxdepth::Int=typemax(Int))</code></pre><p>Uniformly samples a random node from the tree limited to maxdepth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/sampling_grammar.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(::Type{NodeLoc}, root::RuleNode, maxdepth::Int=typemax(Int))</code></pre><p>Uniformly selects a random node in the tree no deeper than maxdepth using reservoir sampling. Returns a <a href="../HerbGrammar/#HerbGrammar.NodeLoc"><code>NodeLoc</code></a> that specifies the location using its parent so that the subtree can be replaced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/sampling_grammar.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(::Type{NodeLoc}, root::RuleNode, typ::Symbol, grammar::AbstractGrammar)</code></pre><p>Uniformly selects a random node in the tree of a given type, specified using its parent such that the subtree can be replaced. Returns a <a href="../HerbGrammar/#HerbGrammar.NodeLoc"><code>NodeLoc</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/sampling_grammar.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(root::RuleNode, typ::Symbol, grammar::AbstractGrammar,
                      maxdepth::Int=typemax(Int))</code></pre><p>Uniformly selects a random node of the given return type typ limited by maxdepth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Herb-AI/HerbSearch.jl/blob/5b315ce7ebf6c78df9609e01a7bf2d9c784dba65/src/sampling_grammar.jl#L86-L91">source</a></section></article><p>The HerbSearch package takes care of all operations related to searching for the desired program. This includes</p><ul><li>the functionality to sample a certain program given a grammar,</li><li>the implementation of several heuristic functions,</li><li>searching for a program that satisfies the specification, and</li><li>implementations of several search algorithms in terms of how they enumerate the search space<ul><li>Breadth-First Search </li><li>Depth-First Search </li><li>Metropolis Hastings </li><li>Very Large Scale Neighbourhood Search </li><li>Simulated Annealing</li><li>Genetic Search</li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="../HerbConstraints/#HerbConstraints.AbstractMatchNode"><code>HerbConstraints.AbstractMatchNode</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.ComesAfter"><code>HerbConstraints.ComesAfter</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.ComesAfter-Tuple{Int64, Int64}"><code>HerbConstraints.ComesAfter</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.Condition"><code>HerbConstraints.Condition</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.Forbidden"><code>HerbConstraints.Forbidden</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.ForbiddenPath"><code>HerbConstraints.ForbiddenPath</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.GrammarContext"><code>HerbConstraints.GrammarContext</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalCondition"><code>HerbConstraints.LocalCondition</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalConstraint"><code>HerbConstraints.LocalConstraint</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalForbidden"><code>HerbConstraints.LocalForbidden</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalOneOf"><code>HerbConstraints.LocalOneOf</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalOrdered"><code>HerbConstraints.LocalOrdered</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.MatchFail"><code>HerbConstraints.MatchFail</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.MatchNode"><code>HerbConstraints.MatchNode</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.MatchVar"><code>HerbConstraints.MatchVar</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.OneOf"><code>HerbConstraints.OneOf</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.Ordered"><code>HerbConstraints.Ordered</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.PropagatorConstraint"><code>HerbConstraints.PropagatorConstraint</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.RequireOnLeft"><code>HerbConstraints.RequireOnLeft</code></a></li><li><a href="../HerbCore/#HerbCore.AbstractGrammar"><code>HerbCore.AbstractGrammar</code></a></li><li><a href="../HerbCore/#HerbCore.AbstractRuleNode"><code>HerbCore.AbstractRuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.Constraint"><code>HerbCore.Constraint</code></a></li><li><a href="../HerbCore/#HerbCore.Hole"><code>HerbCore.Hole</code></a></li><li><a href="../HerbCore/#HerbCore.HoleReference"><code>HerbCore.HoleReference</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode-Tuple{Int64, Any}"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode-Tuple{Int64, Vector{AbstractRuleNode}}"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.ContextSensitiveGrammar"><code>HerbGrammar.ContextSensitiveGrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.NodeLoc"><code>HerbGrammar.NodeLoc</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.SymbolTable"><code>HerbGrammar.SymbolTable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.SymbolTable"><code>HerbGrammar.SymbolTable</code></a></li><li><a href="#HerbSearch.BFSIterator"><code>HerbSearch.BFSIterator</code></a></li><li><a href="#HerbSearch.DFSIterator"><code>HerbSearch.DFSIterator</code></a></li><li><a href="#HerbSearch.ExpandFailureReason"><code>HerbSearch.ExpandFailureReason</code></a></li><li><a href="#HerbSearch.GeneticSearchIterator"><code>HerbSearch.GeneticSearchIterator</code></a></li><li><a href="#HerbSearch.MHSearchIterator"><code>HerbSearch.MHSearchIterator</code></a></li><li><a href="#HerbSearch.MLFSIterator"><code>HerbSearch.MLFSIterator</code></a></li><li><a href="#HerbSearch.PriorityQueueItem"><code>HerbSearch.PriorityQueueItem</code></a></li><li><a href="#HerbSearch.PriorityQueueItem-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.PriorityQueueItem</code></a></li><li><a href="#HerbSearch.ProgramIterator"><code>HerbSearch.ProgramIterator</code></a></li><li><a href="#HerbSearch.PropagateResult"><code>HerbSearch.PropagateResult</code></a></li><li><a href="#HerbSearch.SASearchIterator"><code>HerbSearch.SASearchIterator</code></a></li><li><a href="#HerbSearch.StochasticSearchIterator"><code>HerbSearch.StochasticSearchIterator</code></a></li><li><a href="#HerbSearch.SynthResult"><code>HerbSearch.SynthResult</code></a></li><li><a href="#HerbSearch.TopDownIterator"><code>HerbSearch.TopDownIterator</code></a></li><li><a href="#HerbSearch.VLSNSearchIterator"><code>HerbSearch.VLSNSearchIterator</code></a></li><li><a href="../HerbSpecification/#HerbSpecification.AbstractDependentTypeSpecification"><code>HerbSpecification.AbstractDependentTypeSpecification</code></a></li><li><a href="../HerbSpecification/#HerbSpecification.AgdaSpecification"><code>HerbSpecification.AgdaSpecification</code></a></li><li><a href="../HerbSpecification/#HerbSpecification.IOExample"><code>HerbSpecification.IOExample</code></a></li><li><a href="../HerbSpecification/#HerbSpecification.MetricProblem"><code>HerbSpecification.MetricProblem</code></a></li><li><a href="../HerbSpecification/#HerbSpecification.Problem"><code>HerbSpecification.Problem</code></a></li><li><a href="../HerbSpecification/#HerbSpecification.SMTSpecification"><code>HerbSpecification.SMTSpecification</code></a></li><li><a href="../HerbSpecification/#HerbSpecification.Trace"><code>HerbSpecification.Trace</code></a></li><li><a href="../HerbGrammar/#Base.get-Tuple{RuleNode, NodeLoc}"><code>Base.get</code></a></li><li><a href="../HerbSpecification/#Base.getindex-Tuple{Problem{Vector{IOExample}}, Any}"><code>Base.getindex</code></a></li><li><a href="../HerbGrammar/#Base.insert!-Tuple{RuleNode, NodeLoc, RuleNode}"><code>Base.insert!</code></a></li><li><a href="../HerbCore/#Base.isless-Tuple{AbstractRuleNode, AbstractRuleNode}"><code>Base.isless</code></a></li><li><a href="#Base.iterate-Tuple{HerbSearch.StochasticSearchIterator, HerbSearch.IteratorState}"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Tuple{GeneticSearchIterator}"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Tuple{TopDownIterator, DataStructures.PriorityQueue}"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Tuple{GeneticSearchIterator, HerbSearch.GeneticIteratorState}"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Tuple{TopDownIterator}"><code>Base.iterate</code></a></li><li><a href="../HerbCore/#Base.length-Tuple{Hole}"><code>Base.length</code></a></li><li><a href="../HerbCore/#Base.length-Tuple{RuleNode}"><code>Base.length</code></a></li><li><a href="#Base.rand"><code>Base.rand</code></a></li><li><a href="#Base.rand"><code>Base.rand</code></a></li><li><a href="#Base.rand"><code>Base.rand</code></a></li><li><a href="../HerbConstraints/#Base.show-Tuple{IO, MatchNode}"><code>Base.show</code></a></li><li><a href="../HerbConstraints/#Base.show-Tuple{IO, MatchVar}"><code>Base.show</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match-Tuple{RuleNode, MatchVar, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match-Tuple{RuleNode, MatchNode, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._rulenode_compare-Tuple{RuleNode, RuleNode}"><code>HerbConstraints._rulenode_compare</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._rulenode_match_with_hole-Tuple{RuleNode, RuleNode, Vector{Int64}}"><code>HerbConstraints._rulenode_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.addparent!-Tuple{GrammarContext, Int64}"><code>HerbConstraints.addparent!</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.annotation2constraint-Tuple{Any, Int64, Vector{String}}"><code>HerbConstraints.annotation2constraint</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{Forbidden, AbstractGrammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{RequireOnLeft, AbstractGrammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{Ordered, AbstractGrammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{ComesAfter, AbstractGrammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{OneOf, AbstractGrammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{ForbiddenPath, AbstractGrammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{HerbConstraints.Condition, AbstractGrammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.copy_and_insert-Tuple{GrammarContext, Int64}"><code>HerbConstraints.copy_and_insert</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.make_smaller_or_equal-Tuple{RuleNode, RuleNode, Vector{Int64}, Vector{Int64}}"><code>HerbConstraints.make_smaller_or_equal</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.matchnode2expr-Tuple{MatchNode, AbstractGrammar}"><code>HerbConstraints.matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.matchnode2expr-Tuple{MatchVar, AbstractGrammar}"><code>HerbConstraints.matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{LocalForbidden, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{LocalCondition, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{LocalOrdered, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{RequireOnLeft, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{Ordered, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{HerbConstraints.LocalOneOf, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{OneOf, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{Forbidden, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{ForbiddenPath, AbstractGrammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbCore/#HerbCore.contains_hole-Tuple{RuleNode}"><code>HerbCore.contains_hole</code></a></li><li><a href="../HerbCore/#HerbCore.depth-Tuple{RuleNode}"><code>HerbCore.depth</code></a></li><li><a href="../HerbCore/#HerbCore.get_node_at_location-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.get_node_at_location</code></a></li><li><a href="../HerbCore/#HerbCore.get_rulesequence-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.get_rulesequence</code></a></li><li><a href="../HerbCore/#HerbCore.node_depth-Tuple{AbstractRuleNode, AbstractRuleNode}"><code>HerbCore.node_depth</code></a></li><li><a href="../HerbCore/#HerbCore.rulesoftype-Tuple{RuleNode, Set{Int64}}"><code>HerbCore.rulesoftype</code></a></li><li><a href="../HerbCore/#HerbCore.rulesonleft-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.rulesonleft</code></a></li><li><a href="../HerbCore/#HerbCore.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}"><code>HerbCore.swap_node</code></a></li><li><a href="../HerbCore/#HerbCore.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}"><code>HerbCore.swap_node</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.add_rule!-Tuple{AbstractGrammar, Expr}"><code>HerbGrammar.add_rule!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.add_rule!-Tuple{AbstractGrammar, Real, Expr}"><code>HerbGrammar.add_rule!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.addconstraint!-Tuple{ContextSensitiveGrammar, Constraint}"><code>HerbGrammar.addconstraint!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.child_types-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.child_types</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.child_types-Tuple{AbstractGrammar, RuleNode}"><code>HerbGrammar.child_types</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.cleanup_removed_rules!-Tuple{AbstractGrammar}"><code>HerbGrammar.cleanup_removed_rules!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.clearconstraints!-Tuple{ContextSensitiveGrammar}"><code>HerbGrammar.clearconstraints!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.containedin-Tuple{Vector, Vector}"><code>HerbGrammar.containedin</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.contains_returntype"><code>HerbGrammar.contains_returntype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2csgrammar-Tuple{Expr}"><code>HerbGrammar.expr2csgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2pcsgrammar-Tuple{Expr}"><code>HerbGrammar.expr2pcsgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_childtypes-Tuple{Any, AbstractVector{Symbol}}"><code>HerbGrammar.get_childtypes</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_domain-Tuple{AbstractGrammar, Vector{Int64}}"><code>HerbGrammar.get_domain</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_domain-Tuple{AbstractGrammar, Symbol}"><code>HerbGrammar.get_domain</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_node_at_location-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.get_node_at_location</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_rulesequence-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.get_rulesequence</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.has_children-Tuple{RuleNode}"><code>HerbGrammar.has_children</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iscomplete-Tuple{AbstractGrammar, RuleNode}"><code>HerbGrammar.iscomplete</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{Any}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{AbstractGrammar}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isprobabilistic-Tuple{AbstractGrammar}"><code>HerbGrammar.isprobabilistic</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{Any, AbstractVector{Symbol}}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{AbstractGrammar, RuleNode}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.isvariable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, RuleNode}"><code>HerbGrammar.isvariable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, Int64, Vararg{Module}}"><code>HerbGrammar.isvariable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isvariable-Tuple{AbstractGrammar, RuleNode, Vararg{Module}}"><code>HerbGrammar.isvariable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.log_probability-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.log_probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.max_arity-Tuple{AbstractGrammar}"><code>HerbGrammar.max_arity</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.merge_grammars!-Tuple{AbstractGrammar, AbstractGrammar}"><code>HerbGrammar.merge_grammars!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.mindepth-Tuple{AbstractGrammar, Symbol, AbstractVector{Int64}}"><code>HerbGrammar.mindepth</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.mindepth_map-Tuple{AbstractGrammar}"><code>HerbGrammar.mindepth_map</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nchildren-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.nchildren</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nchildren-Tuple{AbstractGrammar, RuleNode}"><code>HerbGrammar.nchildren</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nonterminals-Tuple{AbstractGrammar}"><code>HerbGrammar.nonterminals</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.normalize!"><code>HerbGrammar.normalize!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.parse_probabilistic_rule-Tuple{Expr}"><code>HerbGrammar.parse_probabilistic_rule</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.probability-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_csg"><code>HerbGrammar.read_csg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_pcsg"><code>HerbGrammar.read_pcsg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.remove_rule!-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.remove_rule!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.return_type-Tuple{AbstractGrammar, Int64}"><code>HerbGrammar.return_type</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.return_type-Tuple{AbstractGrammar, RuleNode}"><code>HerbGrammar.return_type</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.root_node_loc-Tuple{RuleNode}"><code>HerbGrammar.root_node_loc</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulenode2expr-Tuple{RuleNode, AbstractGrammar}"><code>HerbGrammar.rulenode2expr</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulenode_log_probability-Tuple{RuleNode, AbstractGrammar}"><code>HerbGrammar.rulenode_log_probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, AbstractGrammar, Symbol}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, AbstractGrammar, Symbol, RuleNode}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Set{Int64}, RuleNode}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesonleft-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.rulesonleft</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.store_csg"><code>HerbGrammar.store_csg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.subsequenceof-Tuple{Vector{Int64}, Vector{Int64}}"><code>HerbGrammar.subsequenceof</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}"><code>HerbGrammar.swap_node</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}"><code>HerbGrammar.swap_node</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.evaluate_program-Tuple{RuleNode, Vector{&lt;:IOExample}, AbstractGrammar, Function}"><code>HerbInterpret.evaluate_program</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{Dict{Symbol, Any}, Any, Dict{Symbol, T}}} where T"><code>HerbInterpret.execute_on_input</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{AbstractGrammar, RuleNode, Dict{Symbol, T}}} where T"><code>HerbInterpret.execute_on_input</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{Dict{Symbol, Any}, Any, Vector{T}}} where T&lt;:(Dict{Symbol})"><code>HerbInterpret.execute_on_input</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.execute_on_input-Union{Tuple{T}, Tuple{AbstractGrammar, RuleNode, Vector{T}}} where T&lt;:(Dict{Symbol})"><code>HerbInterpret.execute_on_input</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.interpret-Tuple{Dict{Symbol, Any}, Any}"><code>HerbInterpret.interpret</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.test_all_examples-Tuple{Dict{Symbol, Any}, Any, Vector{IOExample}}"><code>HerbInterpret.test_all_examples</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.test_examples-Tuple{Dict{Symbol, Any}, Any, Vector{IOExample}}"><code>HerbInterpret.test_examples</code></a></li><li><a href="#HerbSearch._calculate_cost-Tuple{RuleNode, Function, AbstractVector{IOExample}, AbstractGrammar, Function}"><code>HerbSearch._calculate_cost</code></a></li><li><a href="#HerbSearch._expand-Tuple{RuleNode, ContextSensitiveGrammar, Int64, Int64, GrammarContext, TopDownIterator}"><code>HerbSearch._expand</code></a></li><li><a href="#HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, TopDownIterator}"><code>HerbSearch._expand</code></a></li><li><a href="#HerbSearch._find_next_complete_tree-Tuple{ContextSensitiveGrammar, Int64, Int64, DataStructures.PriorityQueue, TopDownIterator}"><code>HerbSearch._find_next_complete_tree</code></a></li><li><a href="#HerbSearch.best_accept-Tuple{Real, Real, Real}"><code>HerbSearch.best_accept</code></a></li><li><a href="#HerbSearch.calculate_cost-Union{Tuple{T}, Tuple{T, RuleNode}} where T&lt;:HerbSearch.StochasticSearchIterator"><code>HerbSearch.calculate_cost</code></a></li><li><a href="#HerbSearch.const_temperature-Tuple{Real}"><code>HerbSearch.const_temperature</code></a></li><li><a href="#HerbSearch.constructNeighbourhood-Tuple{RuleNode, AbstractGrammar}"><code>HerbSearch.constructNeighbourhood</code></a></li><li><a href="#HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, AbstractGrammar}"><code>HerbSearch.constructNeighbourhoodRuleSubset</code></a></li><li><a href="#HerbSearch.count_expressions-Tuple{AbstractGrammar, Int64, Int64, Symbol}"><code>HerbSearch.count_expressions</code></a></li><li><a href="#HerbSearch.count_expressions-Tuple{ProgramIterator}"><code>HerbSearch.count_expressions</code></a></li><li><a href="#HerbSearch.cross_over-Tuple{GeneticSearchIterator, RuleNode, RuleNode}"><code>HerbSearch.cross_over</code></a></li><li><a href="#HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_1</code></a></li><li><a href="#HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_2</code></a></li><li><a href="#HerbSearch.decreasing_temperature-Tuple{Real}"><code>HerbSearch.decreasing_temperature</code></a></li><li><a href="#HerbSearch.default_fitness-Tuple{Any, Any}"><code>HerbSearch.default_fitness</code></a></li><li><a href="#HerbSearch.derivation_heuristic-Tuple{TopDownIterator, Vector{RuleNode}, GrammarContext}"><code>HerbSearch.derivation_heuristic</code></a></li><li><a href="#HerbSearch.enumerate_neighbours_propose-Tuple{Int64}"><code>HerbSearch.enumerate_neighbours_propose</code></a></li><li><a href="#HerbSearch.evaluate-Tuple{Problem{Vector{IOExample}}, Any, Dict{Symbol, Any}}"><code>HerbSearch.evaluate</code></a></li><li><a href="#HerbSearch.extractname-Tuple{Any}"><code>HerbSearch.extractname</code></a></li><li><a href="#HerbSearch.fitness-Tuple{GeneticSearchIterator, RuleNode, AbstractVector{&lt;:Tuple{Any, Any}}}"><code>HerbSearch.fitness</code></a></li><li><a href="#HerbSearch.get_best_program-Tuple{Array{RuleNode}, GeneticSearchIterator}"><code>HerbSearch.get_best_program</code></a></li><li><a href="#HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_leftmost</code></a></li><li><a href="#HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_random</code></a></li><li><a href="#HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_rightmost</code></a></li><li><a href="#HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_smallest_domain</code></a></li><li><a href="#HerbSearch.hole_heuristic-Tuple{TopDownIterator, AbstractRuleNode, Int64}"><code>HerbSearch.hole_heuristic</code></a></li><li><a href="#HerbSearch.is_field_decl-Tuple{Any}"><code>HerbSearch.is_field_decl</code></a></li><li><a href="#HerbSearch.mean_squared_error-Tuple{AbstractVector{&lt;:Tuple{Number, Number}}}"><code>HerbSearch.mean_squared_error</code></a></li><li><a href="#HerbSearch.misclassification-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})"><code>HerbSearch.misclassification</code></a></li><li><a href="#HerbSearch.mutate!"><code>HerbSearch.mutate!</code></a></li><li><a href="#HerbSearch.mutate_random!"><code>HerbSearch.mutate_random!</code></a></li><li><a href="#HerbSearch.priority_function-Tuple{MLFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.priority_function</code></a></li><li><a href="#HerbSearch.priority_function-Tuple{TopDownIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.priority_function</code></a></li><li><a href="#HerbSearch.priority_function-Tuple{DFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.priority_function</code></a></li><li><a href="#HerbSearch.priority_function-Tuple{BFSIterator, AbstractGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.priority_function</code></a></li><li><a href="#HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept</code></a></li><li><a href="#HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature</code></a></li><li><a href="#HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature_fraction</code></a></li><li><a href="#HerbSearch.processkwarg!-Tuple{Vector{Expr}, Union{Expr, Symbol}}"><code>HerbSearch.processkwarg!</code></a></li><li><a href="#HerbSearch.propagate_constraints"><code>HerbSearch.propagate_constraints</code></a></li><li><a href="#HerbSearch.random_fill_propose-Tuple{RuleNode, NodeLoc, AbstractGrammar, Int64, AbstractVector{Int64}, Union{Nothing, Dict{String, Any}}}"><code>HerbSearch.random_fill_propose</code></a></li><li><a href="#HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_chromosome</code></a></li><li><a href="#HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_fitness_proportional_parents</code></a></li><li><a href="#HerbSearch.select_parents-Tuple{GeneticSearchIterator, Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_parents</code></a></li><li><a href="#HerbSearch.synth-Tuple{Problem, ProgramIterator}"><code>HerbSearch.synth</code></a></li><li><a href="#HerbSearch.validate_iterator-Tuple{Any}"><code>HerbSearch.validate_iterator</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.@csgrammar_annotated-Tuple{Any}"><code>HerbConstraints.@csgrammar_annotated</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@csgrammar-Tuple{Any}"><code>HerbGrammar.@csgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@pcsgrammar-Tuple{Any}"><code>HerbGrammar.@pcsgrammar</code></a></li><li><a href="#HerbSearch.@programiterator-Tuple{Any, Any}"><code>HerbSearch.@programiterator</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../HerbConstraints/">« HerbConstraints.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 11 April 2024 09:58">Thursday 11 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
