<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Search Procedures · Herb.jl</title><meta name="title" content="Advanced Search Procedures · Herb.jl"/><meta property="og:title" content="Advanced Search Procedures · Herb.jl"/><meta property="twitter:title" content="Advanced Search Procedures · Herb.jl"/><meta name="description" content="Documentation for Herb.jl."/><meta property="og:description" content="Documentation for Herb.jl."/><meta property="twitter:description" content="Documentation for Herb.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Herb.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../">Herb.jl</a></li><li><a class="tocitem" href="../../install/">Installation Guide</a></li><li><a class="tocitem" href="../../get_started/">Getting Started</a></li><li><a class="tocitem" href="../../concepts/">Architecture and core concepts</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_herb/">A more verbose getting started with Herb.jl</a></li><li><a class="tocitem" href="../defining_grammars/">Defining Grammars in Herb.jl</a></li><li class="is-active"><a class="tocitem" href>Advanced Search Procedures</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Search-methods"><span>Search methods</span></a></li><li><a class="tocitem" href="#Stochastic-search"><span>Stochastic search</span></a></li><li><a class="tocitem" href="#Other-functionality"><span>Other functionality</span></a></li><li class="toplevel"><a class="tocitem" href="#More-interesting-domains-and-Use-of-constraints"><span>More interesting domains &amp; Use of constraints</span></a></li></ul></li><li><a class="tocitem" href="../TopDown/">Top Down Iterator</a></li><li><a class="tocitem" href="../getting_started_with_constraints/">Getting started with Constraints</a></li><li><a class="tocitem" href="../working_with_interpreters/">Working with custom interpreters</a></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../../HerbCore/">HerbCore.jl</a></li><li><a class="tocitem" href="../../HerbGrammar/">HerbGrammar.jl</a></li><li><a class="tocitem" href="../../HerbSpecification/">HerbSpecification.jl</a></li><li><a class="tocitem" href="../../HerbInterpret/">HerbInterpret.jl</a></li><li><a class="tocitem" href="../../HerbConstraints/">HerbConstraints.jl</a></li><li><a class="tocitem" href="../../HerbSearch/">HerbSearch.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Advanced Search Procedures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Search Procedures</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl/blob/master/docs/src/tutorials/advanced_search.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-Search-Procedures-in-Herb.jl"><a class="docs-heading-anchor" href="#Advanced-Search-Procedures-in-Herb.jl">Advanced Search Procedures in Herb.jl</a><a id="Advanced-Search-Procedures-in-Herb.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Search-Procedures-in-Herb.jl" title="Permalink"></a></h1><p>In this tutorial, we show how to use the search procedure using more advanced methods.</p><pre><code class="language-julia hljs">using Pkg
Pkg.add([&quot;HerbGrammar&quot;, &quot;HerbSpecification&quot;, &quot;HerbSearch&quot;, &quot;HerbInterpret&quot;, &quot;HerbConstraints&quot;])
using HerbGrammar, HerbSpecification, HerbSearch, HerbInterpret, HerbConstraints</code></pre><p>We start with a simple grammar and a simple problem.</p><pre><code class="language-julia hljs">g = @cfgrammar begin
    Number = |(1:2)
    Number = x
    Number = Number + Number
    Number = Number * Number
end

problem = Problem([IOExample(Dict(:x =&gt; x), 2x+1) for x ∈ 1:5])</code></pre><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><p>We can use a search strategy, where we can specify different parameters. For example, by setting the <code>max_depth</code>, we limit the depth of the search. In the next example, we can see the effect of the depth on the number of allocations considered. </p><pre><code class="language-julia hljs">solution = @time search(g, problem, :Number, max_depth=3)
println(solution)

solution = @time search(g, problem, :Number, max_depth=6)
println(solution)</code></pre><p>Another parameter to use is <code>max_enumerations</code>, which limits the number of programs that can be tested at evaluation. We can see the number of enumerations necessary to solve a simple problem in the next example.</p><pre><code class="language-julia hljs">for i in range(1, 50)
    println(i, &quot; enumerations&quot;)
    solution = @time search(g, problem, :Number, max_enumerations=i)
    println(solution)
end</code></pre><p>We see that only when <code>i &gt;= 24</code>, there is a result, after that, increasing <code>i</code> does not have any effect on the number of allocations. </p><p>A final parameter we consider here is <code>allow_evaluation_errors</code>, which is <code>false</code> by default. When this is set to <code>true</code>, the program will still run even when an exception is thrown during evaluation. To see the effect of this, we create a new grammar. We can also retrieve the error together with the solution from the search method.</p><pre><code class="language-julia hljs">g = @cfgrammar begin
    Number = 1
    List = []
    Index = List[Number]
end

problem = Problem([IOExample(Dict(), x) for x ∈ 1:5])
solution = search(g, problem, :Index, max_depth=2, allow_evaluation_errors=true)
println(&quot;solution: &quot;, solution)</code></pre><p>There is another search method called <code>search_best</code> which returns both the solution and the possible error. The method returns the best program found so far. In this case, we can also see the error (<code>typemax(Int)</code>):</p><pre><code class="language-julia hljs">solution, error = search_best(g, problem, :Index, max_depth=2, allow_evaluation_errors=true)
println(&quot;solution: &quot;, solution)
println(&quot;error: &quot;, error)</code></pre><h2 id="Search-methods"><a class="docs-heading-anchor" href="#Search-methods">Search methods</a><a id="Search-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Search-methods" title="Permalink"></a></h2><p>We now show examples of using different search procedures, which are initialized by passing different enumerators to the search function.</p><h3 id="Breadth-First-Search"><a class="docs-heading-anchor" href="#Breadth-First-Search">Breadth-First Search</a><a id="Breadth-First-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Breadth-First-Search" title="Permalink"></a></h3><p>The breadth-first search will first enumerate all possible programs at the same depth before considering programs with a depth of one more. A tree of the grammar is returned with programs ordered in increasing sizes. We can first <code>collect</code> the programs that have a <code>max-depth</code> of 2 and a <code>max_size</code> of infinite (integer maximum value), where the starting symbol is of type <code>Real</code>. This function uses a default heuristic &#39;left-most first&#39;, such that the left-most child in the tree is always explored first.</p><pre><code class="language-julia hljs">g1 = @cfgrammar begin
    Real = 1 | 2
    Real = Real * Real
end
programs = collect(get_bfs_enumerator(g1, 2, typemax(Int), :Real))</code></pre><p>We can test that this function returns all and only the correct functions. </p><pre><code class="language-julia hljs">answer_programs = [
    RuleNode(1),
    RuleNode(2),
    RuleNode(3, [RuleNode(1), RuleNode(1)]),
    RuleNode(3, [RuleNode(1), RuleNode(2)]),
    RuleNode(3, [RuleNode(2), RuleNode(1)]),
    RuleNode(3, [RuleNode(2), RuleNode(2)])
]

println(all(p ∈ programs for p ∈ answer_programs))</code></pre><h3 id="Depth-First-Search"><a class="docs-heading-anchor" href="#Depth-First-Search">Depth-First Search</a><a id="Depth-First-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Depth-First-Search" title="Permalink"></a></h3><p>In depth-first search, we first explore a certain branch of the search tree till the <code>max_depth</code> or a correct program is reached before we consider the next branch. </p><pre><code class="language-julia hljs">g1 = @cfgrammar begin
Real = 1 | 2
Real = Real * Real
end
programs = collect(get_dfs_enumerator(g1, 2, typemax(Int), :Real))
println(programs)</code></pre><p><code>get_dfs_enumerator</code> also has a default left-most heuristic and we consider what the difference is in output. </p><pre><code class="language-julia hljs">g1 = @cfgrammar begin
    Real = 1 | 2
    Real = Real * Real
end
programs = collect(get_dfs_enumerator(g1, 2, typemax(Int), :Real, heuristic_rightmost))
println(programs)</code></pre><h2 id="Stochastic-search"><a class="docs-heading-anchor" href="#Stochastic-search">Stochastic search</a><a id="Stochastic-search-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-search" title="Permalink"></a></h2><p>We now introduce a few stochastic search algorithms, for which we first create a simple grammar and a helper function for problems.</p><pre><code class="language-julia hljs">grammar = @csgrammar begin
    X = |(1:5)
    X = X * X
    X = X + X
    X = X - X
    X = x
end</code></pre><pre><code class="language-julia hljs">function create_problem(f, range=20)
    examples = [IOExample(Dict(:x =&gt; x), f(x)) for x ∈ 1:range]
    return Problem(examples), examples
end</code></pre><h3 id="Metropolis-Hastings"><a class="docs-heading-anchor" href="#Metropolis-Hastings">Metropolis-Hastings</a><a id="Metropolis-Hastings-1"></a><a class="docs-heading-anchor-permalink" href="#Metropolis-Hastings" title="Permalink"></a></h3><p>One of the stochastic search methods that is implemented is Metropolis-Hastings (MH), which samples from a distribution of programs based on the grammar. For more information on MH, see for example <a href="https://stephens999.github.io/fiveMinuteStats/MH_intro.html">this webpage</a>.</p><p>The example below uses a simple arithmetic example. You can try running this code block multiple times, which will give different programs, as the search is stochastic. </p><pre><code class="language-julia hljs">e = x -&gt; x * x + 4
problem, examples = create_problem(e)
enumerator = get_mh_enumerator(examples, mean_squared_error)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=3)</code></pre><h3 id="Very-Large-Scale-Neighbourhood-Search"><a class="docs-heading-anchor" href="#Very-Large-Scale-Neighbourhood-Search">Very Large Scale Neighbourhood Search</a><a id="Very-Large-Scale-Neighbourhood-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Very-Large-Scale-Neighbourhood-Search" title="Permalink"></a></h3><p>The second implemented stochastic search method is VLSN, which searches for a local optimum in the neighbourhood. For more information, see <a href="https://backend.orbit.dtu.dk/ws/portalfiles/portal/5293785/Pisinger.pdf">this article</a>.</p><p>Given the same grammar as before, we can try it with some simple examples.</p><pre><code class="language-julia hljs">e = x -&gt; 10
max_depth = 2
problem, examples = create_problem(e)
enumerator = get_vlsn_enumerator(examples, mean_squared_error, max_depth)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=max_depth)
</code></pre><pre><code class="language-julia hljs">e = x -&gt; x
max_depth = 1
problem, examples = create_problem(e)
enumerator = get_vlsn_enumerator(examples, mean_squared_error, max_depth)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=max_depth)</code></pre><h3 id="Simulated-Annealing"><a class="docs-heading-anchor" href="#Simulated-Annealing">Simulated Annealing</a><a id="Simulated-Annealing-1"></a><a class="docs-heading-anchor-permalink" href="#Simulated-Annealing" title="Permalink"></a></h3><p>The third stochastic search method is called simulated annealing. This is another hill-climbing method to find local optima. For more information, see <a href="https://www.cs.cmu.edu/afs/cs.cmu.edu/project/learn-43/lib/photoz/.g/web/glossary/anneal.html">this page</a>.</p><p>We try the example from earlier, but now we can additionally define the <code>initial_temperature</code> of the algorithm, which is 1 by default. Change the value below to see the effect.</p><pre><code class="language-julia hljs">e = x -&gt; x * x + 4
initial_temperature = 1
problem, examples = create_problem(e)
enumerator = get_sa_enumerator(examples, mean_squared_error, initial_temperature)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=3)        </code></pre><pre><code class="language-julia hljs">e = x -&gt; x * x + 4
initial_temperature = 2
problem, examples = create_problem(e)
enumerator = get_sa_enumerator(examples, mean_squared_error, initial_temperature)
program, cost = @time search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=3)</code></pre><h3 id="Genetic-Search"><a class="docs-heading-anchor" href="#Genetic-Search">Genetic Search</a><a id="Genetic-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Genetic-Search" title="Permalink"></a></h3><p>Genetic search is a type of evolutionary algorithm, which will simulate the process of natural selection and return the &#39;fittest&#39; program of the population. For more information, see <a href="https://www.geeksforgeeks.org/genetic-algorithms/">here</a>.</p><p>We show the example of finding a lambda function. Try varying the parameters of the genetic search to see what happens.</p><pre><code class="language-julia hljs">e = x -&gt; 3 * x * x + (x + 2)
problem, examples = create_problem(e)
enumerator = get_genetic_enumerator(examples, 
    initial_population_size = 10,
    mutation_probability = 0.8,
    maximum_initial_population_depth = 3,
)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=nothing, max_time=20)    </code></pre><h2 id="Other-functionality"><a class="docs-heading-anchor" href="#Other-functionality">Other functionality</a><a id="Other-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functionality" title="Permalink"></a></h2><p>Finally, we showcase two other functionalities of HerbSearch, sampling and heuristics.</p><h3 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h3><p>Sampling is implemented for the different stochastic search methods.</p><p>We consider here a simple grammar, which gives different programs for different search depths.</p><pre><code class="language-julia hljs">grammar = @cfgrammar begin 
    A = B | C | F
    F = G
    C = D
    D = E
end

# A-&gt;B (depth 1) or A-&gt;F-&gt;G (depth 2) or A-&gt;C-&gt;D-&gt;E (depth 3)

# For depth ≤ 1 the only option is A-&gt;B
expression = rand(RuleNode, grammar, :A, 1)
@assert rulenode2expr(expression, grammar) in [:B,:C,:F]

# For depth ≤ 2 the two options are A-&gt;B (depth 1) and A-&gt;B-&gt;G| A-&gt;C-&gt;G | A-&gt;F-&gt;G (depth 2)
expression = rand(RuleNode, grammar, :A, 2)
@assert rulenode2expr(expression,grammar) in [:B,:C,:F,:G]</code></pre><h3 id="Heuristics"><a class="docs-heading-anchor" href="#Heuristics">Heuristics</a><a id="Heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Heuristics" title="Permalink"></a></h3><h1 id="More-interesting-domains-and-Use-of-constraints"><a class="docs-heading-anchor" href="#More-interesting-domains-and-Use-of-constraints">More interesting domains &amp; Use of constraints</a><a id="More-interesting-domains-and-Use-of-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#More-interesting-domains-and-Use-of-constraints" title="Permalink"></a></h1><p>In the following examples, we introduce some larger grammars and show that Herb can still efficiently find the correct program.</p><pre><code class="language-julia hljs">#Expects to return a program equivalent to 1 + (1 - x) = 2 - x

g₁ = @csgrammar begin
    Element = |(1 : 3)          # 1 - 3
    Element = Element + Element # 4
    Element = 1 - Element       # 5
    Element = x                 # 6
end

addconstraint!(g₁, ComesAfter(6, [5]))

examples = [
    IOExample(Dict(:x =&gt; 0), 2),
    IOExample(Dict(:x =&gt; 1), 1),
    IOExample(Dict(:x =&gt; 2), 0)
]
problem = Problem(examples)
solution = search(g₁, problem, :Element, max_depth=3)

@assert test_with_input(SymbolTable(g₁), solution, Dict(:x =&gt; -2)) == 4</code></pre><pre><code class="language-julia hljs"># Expects to return a program equivalent to 4 + x * (x + 3 + 3) = x^2 + 6x + 4

g₂ = @csgrammar begin
    Element = Element + Element + Element # 1
    Element = Element + Element * Element # 2
    Element = x                           # 3
    Element = |(3 : 5)                    # 4
end

# Restrict .. + x * x
addconstraint!(g₂, Forbidden(MatchNode(2, [MatchVar(:x), MatchNode(3), MatchNode(3)])))
# Restrict 4 and 5 in lower level
addconstraint!(g₂, ForbiddenPath([2, 1, 5]))
addconstraint!(g₂, ForbiddenPath([2, 1, 6]))

examples = [
    IOExample(Dict(:x =&gt; 1), 11)
    IOExample(Dict(:x =&gt; 2), 20)
    IOExample(Dict(:x =&gt; -1), -1)
]
problem = Problem(examples)
solution = search(g₂, problem, :Element)

@assert test_with_input(SymbolTable(g₂), solution, Dict(:x =&gt; 0)) == 4</code></pre><pre><code class="language-julia hljs"># Expects to return a program equivalent to (1 - (((1 - x) - 1) - 1)) - 1 = x + 1

g₃ = @csgrammar begin
    Element = |(1 : 20)   # 1 - 20
    Element = Element - 1 # 21
    Element = 1 - Element # 22
    Element = x           # 23
end

addconstraint!(g₃, ComesAfter(23, [22, 21]))
addconstraint!(g₃, ComesAfter(22, [21]))

examples = [
    IOExample(Dict(:x =&gt; 1), 2)
    IOExample(Dict(:x =&gt; 10), 11)
]
problem = Problem(examples)
solution = search(g₃, problem, :Element)

@assert test_with_input(SymbolTable(g₃), solution, Dict(:x =&gt; 0)) == 1
@assert test_with_input(SymbolTable(g₃), solution, Dict(:x =&gt; 100)) == 101</code></pre><pre><code class="language-julia hljs"># Expects to return a program equivalent to 18 + 4x

g₄ = @csgrammar begin
    Element = |(0 : 20)                   # 1 - 20
    Element = Element + Element + Element # 21
    Element = Element + Element * Element # 22
    Element = x                           # 23
end

# Enforce ordering on + +
addconstraint!(g₄, Ordered(
    MatchNode(21, [MatchVar(:x), MatchVar(:y), MatchVar(:z)]),
    [:x, :y, :z]
))

examples = [
    IOExample(Dict(:x =&gt; 1), 22),
    IOExample(Dict(:x =&gt; 0), 18),
    IOExample(Dict(:x =&gt; -1), 14)
]
problem = Problem(examples)
solution = search(g₄, problem, :Element)

@assert test_with_input(SymbolTable(g₄), solution, Dict(:x =&gt; 100)) == 418</code></pre><pre><code class="language-julia hljs"># Expects to return a program equivalent to (x == 2) ? 1 : (x + 2)

g₅ = @csgrammar begin
    Element = Number # 1
    Element = Bool # 2

    Number = |(1 : 3) # 3-5
    
    Number = Number + Number # 6
    Bool = Number ≡ Number # 7
    Number = x # 8
    
    Number = Bool ? Number : Number # 9
    Bool = Bool ? Bool : Bool # 10
end

# Forbid ? = ?
addconstraint!(g₅, Forbidden(MatchNode(7, [MatchVar(:x), MatchVar(:x)])))
# Order =
addconstraint!(g₅, Ordered(MatchNode(7, [MatchVar(:x), MatchVar(:y)]), [:x, :y]))
# Order +
addconstraint!(g₅, Ordered(MatchNode(6, [MatchVar(:x), MatchVar(:y)]), [:x, :y]))

examples = [
    IOExample(Dict(:x =&gt; 0), 2)
    IOExample(Dict(:x =&gt; 1), 3)
    IOExample(Dict(:x =&gt; 2), 1)
]
problem = Problem(examples)
solution = search(g₅, problem, :Element)

@assert test_with_input(SymbolTable(g₅), solution, Dict(:x =&gt; 3)) == 5</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../defining_grammars/">« Defining Grammars in Herb.jl</a><a class="docs-footer-nextpage" href="../TopDown/">Top Down Iterator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 9 July 2024 11:24">Tuesday 9 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
