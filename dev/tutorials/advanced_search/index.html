<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Search Procedures · Herb.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Herb.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Herb.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../">Herb.jl</a></li><li><a class="tocitem" href="../../install/">Installation Guide</a></li><li><a class="tocitem" href="../../get_started/">Getting Started</a></li><li><a class="tocitem" href="../../concepts/">Architecture and core concepts</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_herb/">A more verbose getting started with Herb.jl</a></li><li><a class="tocitem" href="../defining_grammars/">Defining Grammars in Herb.jl</a></li><li class="is-active"><a class="tocitem" href>Advanced Search Procedures</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Search-methods"><span>Search methods</span></a></li><li><a class="tocitem" href="#Other-functionality"><span>Other functionality</span></a></li><li class="toplevel"><a class="tocitem" href="#Examples-with-larger-domains-and-constraints"><span>Examples with larger domains and constraints</span></a></li></ul></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../../HerbGrammar/">HerbGrammar.jl</a></li><li><a class="tocitem" href="../../HerbSearch/">HerbSearch.jl</a></li><li><a class="tocitem" href="../../HerbConstraints/">HerbConstraints.jl</a></li><li><a class="tocitem" href="../../HerbData/">HerbCore.jl</a></li><li><a class="tocitem" href="../../HerbInterpret/">HerbInterpret.jl</a></li><li><a class="tocitem" href="../../HerbData/">HerbData.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Advanced Search Procedures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Search Procedures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Herb-AI/Herb.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h1><p>You can either paste this code into the Julia REPL or into a seperate file, e.g. <code>get_started.jl</code> followed by running <code>julia get_started.jl</code>.</p><p>To start, we import the necessary packages.</p><pre><code class="language-julia hljs">using HerbGrammar, HerbData, HerbSearch, HerbInterpret</code></pre><p>We start with the same simple grammar from the main file <a href="../../get_started/">get_started.md</a>.</p><pre><code class="language-julia hljs">g = @cfgrammar begin
    Number = |(1:2)
    Number = x
    Number = Number + Number
    Number = Number * Number
end</code></pre><p>We use a simple problem.</p><pre><code class="language-julia hljs">    problem = Problem([IOExample(Dict(:x =&gt; x), 2x+1) for x ∈ 1:5])</code></pre><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><p>We can use a search strategy, where we can specify different parameters. For example, by setting the <code>max_depth</code>, we limit the depth of the search. In the next example, we can see the effect of the depth on the number of allocations considered. </p><pre><code class="language-julia hljs">solution = @time search(g, problem, :Number, max_depth=3)
&gt;&gt;&gt; 0.003284 seconds (50.08 k allocations: 2.504 MiB)
println(solution)
&gt;&gt;&gt; (x + 1) + x

solution = @time search(g, problem, :Number, max_depth=6)
&gt;&gt;&gt; 0.005696 seconds (115.28 k allocations: 5.910 MiB)
println(solution)
&gt;&gt;&gt; (1 + x) + x</code></pre><p>Another parameter to use is <code>max_enumerations</code>, which limits the number of programs that can be tested at evaluation. We can see the number of enumerations necessary to solve a simple problem in the next example.</p><pre><code class="language-julia hljs">for i in range(1, 50)
    println(i, &quot; enumerations&quot;)
    solution = @time search(g, problem, :Number, max_enumerations=i)
    println(solution)
end

&gt;&gt;&gt; ....
&gt;&gt;&gt; 23 enums: nothing
&gt;&gt;&gt;  0.010223 seconds (117.01 k allocations: 5.935 MiB, 44.23% gc time)
&gt;&gt;&gt; 24 enums: (1 + x) + x
&gt;&gt;&gt;  0.005305 seconds (117.01 k allocations: 5.935 MiB)
&gt;&gt;&gt; 25 enums: (1 + x) + x
&gt;&gt;&gt;  0.005381 seconds (117.01 k allocations: 5.935 MiB)
&gt;&gt;&gt; ...</code></pre><p>We see that only when <code>i &gt;= 24</code>, there is a result, after that, increasing <code>i</code> does not have any effect on the number of allocations. </p><p>A final parameter we consider here is <code>allow_evaluation_errors</code>, which is <code>false</code> by default. When this is set to <code>true</code>, the program will still run even when an exception is thrown during evaluation. To see the effect of this, we create a new grammar. We can also retrieve the error together with the solution from the search method.</p><pre><code class="language-julia hljs">g = @cfgrammar begin
    Number = 1
    List = []
    Index = List[Number]
end

problem = Problem([IOExample(Dict(), x) for x ∈ 1:5])
solution = search(g, problem, :Index, max_depth=2, allow_evaluation_errors=true)
println(solution)
&gt;&gt;&gt; nothing</code></pre><p>There is also another search method called <code>search_best</code> which return both the solution and the possible error. The method returns the best program found so far. In this case, we can also see the error:</p><pre><code class="language-julia hljs">solution, error = search_best(g, problem, :Index, max_depth=2, allow_evaluation_errors=true)
println(solution)
&gt;&gt;&gt; nothing
println(error)
&gt;&gt;&gt; 9223372036854775807 # or: typemax(Int)</code></pre><h2 id="Search-methods"><a class="docs-heading-anchor" href="#Search-methods">Search methods</a><a id="Search-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Search-methods" title="Permalink"></a></h2><p>We now show examples of using different search procedures.</p><h3 id="Breadth-First-Search"><a class="docs-heading-anchor" href="#Breadth-First-Search">Breadth-First Search</a><a id="Breadth-First-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Breadth-First-Search" title="Permalink"></a></h3><p>The breadth-first search will first enumerate all possible programs at the same depth before considering a program with a depth of one more. A tree of the grammar is returned with programs ordered in increasing sizes. We can first <code>collect</code> the programs that have a <code>max-depth</code> of 2 and a <code>max_size</code> of infinite (integer maximum value), where the starting symbol is of type <code>Real</code>. This function uses a default heuristic &#39;left-most first&#39;, such that the left-most child in the tree is always explored first. </p><pre><code class="language-julia hljs">g1 = @cfgrammar begin
    Real = 1 | 2
    Real = Real * Real
end
programs = collect(get_bfs_enumerator(g1, 2, typemax(Int), :Real))</code></pre><p>We can test that this function returns the correct functions and all functions. </p><pre><code class="language-julia hljs">answer_programs = [
    RuleNode(1),
    RuleNode(2),
    RuleNode(3, [RuleNode(1), RuleNode(1)]),
    RuleNode(3, [RuleNode(1), RuleNode(2)]),
    RuleNode(3, [RuleNode(2), RuleNode(1)]),
    RuleNode(3, [RuleNode(2), RuleNode(2)])
]

println(all(p ∈ programs for p ∈ answer_programs))
&gt;&gt;&gt; true</code></pre><h3 id="Depth-First-Search"><a class="docs-heading-anchor" href="#Depth-First-Search">Depth-First Search</a><a id="Depth-First-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Depth-First-Search" title="Permalink"></a></h3><p>In depth-first search, we first explore a certain branch of the search tree till the <code>max_depth</code> or a correct program is reached before we consider the next branch. </p><pre><code class="language-julia hljs">g1 = @cfgrammar begin
Real = 1 | 2
Real = Real * Real
end
programs = collect(get_dfs_enumerator(g1, 2, typemax(Int), :Real))
println(programs)
&gt;&gt;&gt; RuleNode[1,, 3{1,1}, 3{1,2}, 3{2,1}, 3{2,2}, 2,]</code></pre><p><code>get_dfs_enumerator</code> also has a default left-most heuristic and we consider what the difference is in output. </p><pre><code class="language-julia hljs">g1 = @cfgrammar begin
    Real = 1 | 2
    Real = Real * Real
end
programs = collect(get_dfs_enumerator(g1, 2, typemax(Int), :Real, heuristic_rightmost))
println(programs)
&gt;&gt;&gt; RuleNode[1,, 3{1,1}, 3{2,1}, 3{1,2}, 3{2,2}, 2,]</code></pre><h3 id="Metropolis-Hastings"><a class="docs-heading-anchor" href="#Metropolis-Hastings">Metropolis-Hastings</a><a id="Metropolis-Hastings-1"></a><a class="docs-heading-anchor-permalink" href="#Metropolis-Hastings" title="Permalink"></a></h3><p>One of the stochastic search methods that is implemented is Metropolis-Hastings (MH), which samples from a distribution of programs based on the grammar. For more information on MH, see for example <a href="https://stephens999.github.io/fiveMinuteStats/MH_intro.html">this webpage</a>.</p><p>For the example below, we use this grammar and helper function.</p><pre><code class="language-julia hljs">grammar = @csgrammar begin
    X = |(1:5)
    X = X * X
    X = X + X
    X = X - X
    X = x
end
function create_problem(f, range=20)
    examples = [IOExample(Dict(:x =&gt; x), f(x)) for x ∈ 1:range]
    return Problem(examples), examples
end</code></pre><p>The below example uses a simple arithmetic example. As the search method is stochastic, different programs may be returned, as shown below.</p><pre><code class="language-julia hljs">e = Meta.parse(&quot;x -&gt; x * x + 4&quot;)
problem, examples = create_problem(eval(e))
enumerator = get_mh_enumerator(examples, mean_squared_error)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=3)

&gt;&gt;&gt; (:(x * x - (1 - 5)), 0)
&gt;&gt;&gt; (:(4 + x * x), 0)
&gt;&gt;&gt; (:(x * x + 4), 0)</code></pre><h3 id="Very-Large-Scale-Neighbourhood-Search"><a class="docs-heading-anchor" href="#Very-Large-Scale-Neighbourhood-Search">Very Large Scale Neighbourhood Search</a><a id="Very-Large-Scale-Neighbourhood-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Very-Large-Scale-Neighbourhood-Search" title="Permalink"></a></h3><p>The second implemented stochastic search method is VLSN, which search for a local optimum in the neighbourhood. For more information, see <a href="https://backend.orbit.dtu.dk/ws/portalfiles/portal/5293785/Pisinger.pdf">this article</a>.</p><p>Given the same grammar as before, we can try with some simple examples.</p><pre><code class="language-julia hljs">e = Meta.parse(&quot;x -&gt; 10&quot;)
max_depth = 2
problem, examples = create_problem(eval(e))
enumerator = get_vlsn_enumerator(examples, mean_squared_error, max_depth)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=max_depth)
&gt;&gt;&gt; (:(5 + 5), 0)</code></pre><pre><code class="language-julia hljs">e = Meta.parse(&quot;x -&gt; x&quot;)
max_depth = 1
problem, examples = create_problem(eval(e))
enumerator = get_vlsn_enumerator(examples, mean_squared_error, max_depth)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=max_depth)
&gt;&gt;&gt; (:x, 0)</code></pre><h3 id="Simulated-Annealing"><a class="docs-heading-anchor" href="#Simulated-Annealing">Simulated Annealing</a><a id="Simulated-Annealing-1"></a><a class="docs-heading-anchor-permalink" href="#Simulated-Annealing" title="Permalink"></a></h3><p>The third stochastic search method is called simulated annealing, is another hill-climbing method to find local optima. For more information, see <a href="https://www.cs.cmu.edu/afs/cs.cmu.edu/project/learn-43/lib/photoz/.g/web/glossary/anneal.html">this page</a>.</p><p>We try the example from earlier, but now we can additionally define the <code>initial_temperature</code> of the algorithm, which is 1 by default. Two possible answers to the program are given as well.</p><pre><code class="language-julia hljs">e = Meta.parse(&quot;x -&gt; x * x + 4&quot;)
initial_temperature = 2
problem, examples = create_problem(eval(e))
enumerator = get_sa_enumerator(examples, mean_squared_error, initial_temperature)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=3)
&gt;&gt;&gt; (:(4 + x * x), 0)
&gt;&gt;&gt; (:(x * x + (5 - 1)), 0)</code></pre><h3 id="Genetic-Search"><a class="docs-heading-anchor" href="#Genetic-Search">Genetic Search</a><a id="Genetic-Search-1"></a><a class="docs-heading-anchor-permalink" href="#Genetic-Search" title="Permalink"></a></h3><p>Genetic search is a type of evolutionary algorithm, which will simulate the process of natural selection and return the &#39;fittest&#39; program of the population. For more information, see <a href="https://www.geeksforgeeks.org/genetic-algorithms/">here</a>.</p><p>We show the example of finding a lambda function.</p><pre><code class="language-julia hljs">e = Meta.parse(&quot;x -&gt; 3 * x * x + (x + 2)&quot;)
problem, examples = create_problem(eval(e))
enumerator = get_genetic_enumerator(examples, 
    initial_population_size = 10,
    mutation_probability = 0.8,
    maximum_initial_population_depth = 3,
)
program, cost = search_best(grammar, problem, :X, enumerator=enumerator, error_function=mse_error_function, max_depth=nothing, max_time=20)
&gt;&gt;&gt; (:(((((x - 5) + x) + x * x) + 1) + (((((2 + x * x) + 3) + x * x) + 1) - ((x - x) + x))), 0)
&gt;&gt;&gt; (:(x * 1 + (x * ((x + x) + x * 1) + (1 + 1) * 1)), 0)
&gt;&gt;&gt; (:((((x + x) + x) + 2) * x + ((x - x) + (2 - x))), 0)</code></pre><h2 id="Other-functionality"><a class="docs-heading-anchor" href="#Other-functionality">Other functionality</a><a id="Other-functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Other-functionality" title="Permalink"></a></h2><p>Finally, we showcase two other functionalities of HerbSearch, sampling and heuristics.</p><h3 id="Sampling"><a class="docs-heading-anchor" href="#Sampling">Sampling</a><a id="Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling" title="Permalink"></a></h3><p>Sampling is implemented for the different stochastic search methods.</p><p>We consider here a simple grammar, which gives different programs for different search depths.</p><pre><code class="language-julia hljs">grammar = @cfgrammar begin 
    A = B | C | F
    F = G
    C = D
    D = E
end

# A-&gt;B (depth 1) or A-&gt;F-&gt;G (depth 2) or A-&gt;C-&gt;D-&gt;E (depth 3)

# For depth ≤ 1 the only option is A-&gt;B
expression = rand(RuleNode, grammar, :A, 1)
@assert rulenode2expr(expression, grammar) in [:B,:C,:F]

# For depth ≤ 2 the two options are A-&gt;B (depth 1) and A-&gt;B-&gt;G| A-&gt;C-&gt;G | A-&gt;F-&gt;G (depth 2)
expression = rand(RuleNode, grammar, :A, 2)
@assert rulenode2expr(expression,grammar) in [:B,:C,:F,:G]</code></pre><h3 id="Heuristics"><a class="docs-heading-anchor" href="#Heuristics">Heuristics</a><a id="Heuristics-1"></a><a class="docs-heading-anchor-permalink" href="#Heuristics" title="Permalink"></a></h3><h1 id="Examples-with-larger-domains-and-constraints"><a class="docs-heading-anchor" href="#Examples-with-larger-domains-and-constraints">Examples with larger domains and constraints</a><a id="Examples-with-larger-domains-and-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-with-larger-domains-and-constraints" title="Permalink"></a></h1><p>Here, we showcase a few examples using a more complicated grammar and a few types of constraints</p><pre><code class="language-julia hljs"># Expects to return a program equivalent to 1 + (1 - x) = 2 - x

g₁ = @csgrammar begin
    Element = |(1 : 3)          # 1 - 3
    Element = Element + Element # 4
    Element = 1 - Element       # 5
    Element = x                 # 6
end

addconstraint!(g₁, ComesAfter(6, [5]))

examples = [
    IOExample(Dict(:x =&gt; 0), 2),
    IOExample(Dict(:x =&gt; 1), 1),
    IOExample(Dict(:x =&gt; 2), 0)
]
problem = Problem(examples)
solution = search(g₁, problem, :Element, max_depth=3)

@assert test_with_input(SymbolTable(g₁), solution, Dict(:x =&gt; -2)) == 4

# Expects to return a program equivalent to 4 + x * (x + 3 + 3) = x^2 + 6x + 4

g₂ = @csgrammar begin
    Element = Element + Element + Element # 1
    Element = Element + Element * Element # 2
    Element = x                           # 3
    Element = |(3 : 5)                    # 4
end

# Restrict .. + x * x
addconstraint!(g₂, Forbidden(MatchNode(2, [MatchVar(:x), MatchNode(3), MatchNode(3)])))
# Restrict 4 and 5 in lower level
addconstraint!(g₂, ForbiddenPath([2, 1, 5]))
addconstraint!(g₂, ForbiddenPath([2, 1, 6]))

examples = [
    IOExample(Dict(:x =&gt; 1), 11)
    IOExample(Dict(:x =&gt; 2), 20)
    IOExample(Dict(:x =&gt; -1), -1)
]
problem = Problem(examples)
solution = search(g₂, problem, :Element)

@assert test_with_input(SymbolTable(g₂), solution, Dict(:x =&gt; 0)) == 4

# Expects to return a program equivalent to (1 - (((1 - x) - 1) - 1)) - 1 = x + 1

g₃ = @csgrammar begin
    Element = |(1 : 20)   # 1 - 20
    Element = Element - 1 # 21
    Element = 1 - Element # 22
    Element = x           # 23
end

addconstraint!(g₃, ComesAfter(23, [22, 21]))
addconstraint!(g₃, ComesAfter(22, [21]))

examples = [
    IOExample(Dict(:x =&gt; 1), 2)
    IOExample(Dict(:x =&gt; 10), 11)
]
problem = Problem(examples)
solution = search(g₃, problem, :Element)

@assert test_with_input(SymbolTable(g₃), solution, Dict(:x =&gt; 0)) == 1
@assert test_with_input(SymbolTable(g₃), solution, Dict(:x =&gt; 100)) == 101

# Expects to return a program equivalent to 18 + 4x

g₄ = @csgrammar begin
    Element = |(0 : 20)                   # 1 - 20
    Element = Element + Element + Element # 21
    Element = Element + Element * Element # 22
    Element = x                           # 23
end

# Enforce ordering on + +
addconstraint!(g₄, Ordered(
    MatchNode(21, [MatchVar(:x), MatchVar(:y), MatchVar(:z)]),
    [:x, :y, :z]
))

examples = [
    IOExample(Dict(:x =&gt; 1), 22),
    IOExample(Dict(:x =&gt; 0), 18),
    IOExample(Dict(:x =&gt; -1), 14)
]
problem = Problem(examples)
solution = search(g₄, problem, :Element)

@assert test_with_input(SymbolTable(g₄), solution, Dict(:x =&gt; 100)) == 418

# Expects to return a program equivalent to (x == 2) ? 1 : (x + 2)

g₅ = @csgrammar begin
    Element = Number # 1
    Element = Bool # 2

    Number = |(1 : 3) # 3-5
    
    Number = Number + Number # 6
    Bool = Number ≡ Number # 7
    Number = x # 8
    
    Number = Bool ? Number : Number # 9
    Bool = Bool ? Bool : Bool # 10
end

# Forbid ? = ?
addconstraint!(g₅, Forbidden(MatchNode(7, [MatchVar(:x), MatchVar(:x)])))
# Order =
addconstraint!(g₅, Ordered(MatchNode(7, [MatchVar(:x), MatchVar(:y)]), [:x, :y]))
# Order +
addconstraint!(g₅, Ordered(MatchNode(6, [MatchVar(:x), MatchVar(:y)]), [:x, :y]))

examples = [
    IOExample(Dict(:x =&gt; 0), 2)
    IOExample(Dict(:x =&gt; 1), 3)
    IOExample(Dict(:x =&gt; 2), 1)
]
problem = Problem(examples)
solution = search(g₅, problem, :Element)

@assert test_with_input(SymbolTable(g₅), solution, Dict(:x =&gt; 3)) == 5</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../defining_grammars/">« Defining Grammars in Herb.jl</a><a class="docs-footer-nextpage" href="../../HerbGrammar/">HerbGrammar.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 18 January 2024 15:20">Thursday 18 January 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
