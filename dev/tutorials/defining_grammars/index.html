<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining Grammars in Herb.jl · Herb.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Herb.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../">Herb.jl</a></li><li><a class="tocitem" href="../../install/">Installation Guide</a></li><li><a class="tocitem" href="../../get_started/">Getting Started</a></li><li><a class="tocitem" href="../../concepts/">Architecture and core concepts</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_herb/">A more verbose getting started with Herb.jl</a></li><li class="is-active"><a class="tocitem" href>Defining Grammars in Herb.jl</a><ul class="internal"><li><a class="tocitem" href="#Context-sensitive-grammars"><span>Context-sensitive grammars</span></a></li><li><a class="tocitem" href="#File-writing"><span>File writing</span></a></li></ul></li><li><a class="tocitem" href="../advanced_search/">Advanced Search Procedures</a></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../../HerbGrammar/">HerbGrammar.jl</a></li><li><a class="tocitem" href="../../HerbSearch/">HerbSearch.jl</a></li><li><a class="tocitem" href="../../HerbConstraints/">HerbConstraints.jl</a></li><li><a class="tocitem" href="../../HerbData/">HerbCore.jl</a></li><li><a class="tocitem" href="../../HerbInterpret/">HerbInterpret.jl</a></li><li><a class="tocitem" href="../../HerbData/">HerbData.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Defining Grammars in Herb.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Defining Grammars in Herb.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Herb-AI/Herb.jl/blob/master/docs/src/tutorials/defining_grammars.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Defining-Grammars-in-Herb.jl-using-HerbGrammar"><a class="docs-heading-anchor" href="#Defining-Grammars-in-Herb.jl-using-HerbGrammar">Defining Grammars in Herb.jl using <code>HerbGrammar</code></a><a id="Defining-Grammars-in-Herb.jl-using-HerbGrammar-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Grammars-in-Herb.jl-using-HerbGrammar" title="Permalink"></a></h1><p>The program space in Herb.jl is defined using a grammar.  This notebook demonstrates how such a grammar can be created.  There are multiple kinds of grammars, but they can all be defined in a very similar way.</p><h3 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h3><pre><code class="language-julia hljs">using HerbGrammar, HerbConstraints</code></pre><h3 id="Creating-a-simple-grammar"><a class="docs-heading-anchor" href="#Creating-a-simple-grammar">Creating a simple grammar</a><a id="Creating-a-simple-grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-simple-grammar" title="Permalink"></a></h3><p>This cell contains a very simple arithmetic grammar.  The grammar is defined using the <code>@cfgrammar</code> macro.  This macro converts the grammar definition in the form of a Julia expression into Herb&#39;s internal grammar representation.  Macro&#39;s are executed during compilation. If you want to load a grammar during execution, have a look at the <code>HerbGrammar.expr2cfgrammar</code> function.</p><pre><code class="language-julia hljs">g₁ = HerbGrammar.@cfgrammar begin
    Int = 1
    Int = 2
    Int = 3
    Int = Int * Int
    Int = Int + Int
end</code></pre><pre><code class="nohighlight hljs">1: Int = 1
2: Int = 2
3: Int = 3
4: Int = Int * Int
5: Int = Int + Int</code></pre><p>Defining every integer one-by-one can be quite tedious. Therefore, it is also possible to use the following syntax that makes use of a Julia iterator:</p><pre><code class="language-julia hljs">g₂ = HerbGrammar.@cfgrammar begin
    Int = |(0:9)
    Int = Int * Int
    Int = Int + Int
end</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int * Int
12: Int = Int + Int</code></pre><p>You can do the same with lists:</p><pre><code class="language-julia hljs">g₃ = HerbGrammar.@cfgrammar begin
    Int = |([0, 2, 4, 6, 8])
    Int = Int * Int
    Int = Int + Int
end</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 2
3: Int = 4
4: Int = 6
5: Int = 8
6: Int = Int * Int
7: Int = Int + Int</code></pre><p>Variables can also be added to the grammar by just using the variable name:</p><pre><code class="language-julia hljs">g₄ = HerbGrammar.@cfgrammar begin
    Int = |(0:9)
    Int = Int * Int
    Int = Int + Int
    Int = x
end</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int * Int
12: Int = Int + Int
13: Int = x</code></pre><p>Grammars can also work with functions.  After all, <code>+</code> and <code>*</code> are just infix operators for Julia&#39;s identically-named functions. You can use functions that are provided by Julia, or functions that you wrote yourself:</p><pre><code class="language-julia hljs">f(a) = a + 1

g₅ = HerbGrammar.@cfgrammar begin
    Int = |(0:9)
    Int = Int * Int
    Int = Int + Int
    Int = f(Int)
    Int = x
end</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int * Int
12: Int = Int + Int
13: Int = f(Int)
14: Int = x</code></pre><p>Similarly, we can also define the operator times (x) manually.</p><pre><code class="language-julia hljs">×(a, b) = a * b

g₆ = HerbGrammar.@cfgrammar begin
    Int = |(0:9)
    Int = a
    Int = Int + Int
    Int = Int × Int
end</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = a
12: Int = Int + Int
13: Int = Int × Int</code></pre><h3 id="Working-with-grammars"><a class="docs-heading-anchor" href="#Working-with-grammars">Working with grammars</a><a id="Working-with-grammars-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-grammars" title="Permalink"></a></h3><p>If you want to implement something using these grammars, it is useful to know about the functions that you can use to manipulate grammars and extract information.  This section is not necessarily complete, but it aims to give an overview of the most important functions. </p><p>It is recommended to also read up on <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">Julia metaprogramming</a> if you are not already familiar with that.</p><p>One of the most important things about grammars is that each rule has an index associated with it:</p><pre><code class="language-julia hljs">g₇ = HerbGrammar.@cfgrammar begin
    Int = |(0:9)
    Int = Int + Int
    Int = Int * Int
    Int = x
end

collect(enumerate(g₇.rules))</code></pre><pre><code class="nohighlight hljs">13-element Vector{Tuple{Int64, Any}}:
 (1, 0)
 (2, 1)
 (3, 2)
 (4, 3)
 (5, 4)
 (6, 5)
 (7, 6)
 (8, 7)
 (9, 8)
 (10, 9)
 (11, :(Int + Int))
 (12, :(Int * Int))
 (13, :x)</code></pre><p>We can use this index to extract information from the grammar.</p><h3 id="isterminal"><a class="docs-heading-anchor" href="#isterminal">isterminal</a><a id="isterminal-1"></a><a class="docs-heading-anchor-permalink" href="#isterminal" title="Permalink"></a></h3><p><code>isterminal</code> returns <code>true</code> if a rule is terminal, i.e. it cannot be expanded. For example, rule 1 is terminal, but rule 11 is not, since it contains the non-terminal symbol <code>:Int</code>. </p><pre><code class="language-julia hljs">HerbGrammar.isterminal(g₇, 1)</code></pre><pre><code class="nohighlight hljs">true</code></pre><pre><code class="language-julia hljs">HerbGrammar.isterminal(g₇, 11)</code></pre><pre><code class="nohighlight hljs">false</code></pre><h3 id="return_type"><a class="docs-heading-anchor" href="#return_type">return_type</a><a id="return_type-1"></a><a class="docs-heading-anchor-permalink" href="#return_type" title="Permalink"></a></h3><p>This function is rather obvious; it returns the non-terminal symbol that corresponds to a certain rule. The return type for all rules in our grammar is <code>:Int</code>.</p><pre><code class="language-julia hljs">HerbGrammar.return_type(g₇, 11)</code></pre><pre><code class="nohighlight hljs">:Int</code></pre><h3 id="child_types"><a class="docs-heading-anchor" href="#child_types">child_types</a><a id="child_types-1"></a><a class="docs-heading-anchor-permalink" href="#child_types" title="Permalink"></a></h3><p><code>child_types</code> returns the types of the nonterminal children of a rule in a vector. If you just want to know how many children a rule has, and not necessarily which types they have, you can use <code>nchildren</code></p><pre><code class="language-julia hljs">HerbGrammar.child_types(g₇, 11)</code></pre><pre><code class="nohighlight hljs">2-element Vector{Symbol}:
 :Int
 :Int</code></pre><pre><code class="language-julia hljs">HerbGrammar.nchildren(g₇, 11)</code></pre><pre><code class="nohighlight hljs">2</code></pre><h3 id="nonterminals"><a class="docs-heading-anchor" href="#nonterminals">nonterminals</a><a id="nonterminals-1"></a><a class="docs-heading-anchor-permalink" href="#nonterminals" title="Permalink"></a></h3><p>The <code>nonterminals</code> function can be used to obtain a list of all nonterminals in the grammar.</p><pre><code class="language-julia hljs">HerbGrammar.nonterminals(g₇)</code></pre><pre><code class="nohighlight hljs">1-element Vector{Symbol}:
 :Int</code></pre><h3 id="Adding-rules"><a class="docs-heading-anchor" href="#Adding-rules">Adding rules</a><a id="Adding-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-rules" title="Permalink"></a></h3><p>It is also possible to add rules to a grammar during execution. This can be done using the <code>add_rule!</code> function. As with most functions in Julia that end with an exclamation mark, this function modifies its argument (the grammar).</p><p>A rule can be provided in the same syntax as is used in the grammar definition. The rule should be of the <code>Expr</code> type, which is a built-in type for representing expressions.  An easy way of creating <code>Expr</code> values in Julia is to encapsulate it in brackets and use a colon as prefix:</p><pre><code class="language-julia hljs">HerbGrammar.add_rule!(g₇, :(Int = Int - Int))</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int + Int
12: Int = Int * Int
13: Int = x
14: Int = Int - Int</code></pre><h3 id="Removing-rules"><a class="docs-heading-anchor" href="#Removing-rules">Removing rules</a><a id="Removing-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-rules" title="Permalink"></a></h3><p>It is also possible to remove rules in Herb.jl, however, this is a bit more involved.  As said before, rules have an index associated with them.  The internal representation of programs that are defined by the grammar makes use of those indices for efficiency. Blindly removing a rule would shift the indices of other rules, and this could mean that existing programs get a different meaning or become invalid. </p><p>Therefore, there are two functions for removing rules:</p><ul><li><code>remove_rule!</code> removes a rule from the grammar, but fills its place with a placeholder. Therefore, the indices stay the same, and only programs that use the removed rule become invalid.</li><li><code>cleanup_removed_rules!</code> removes all placeholders and shifts the indices of the other rules.</li></ul><pre><code class="language-julia hljs">HerbGrammar.remove_rule!(g₇, 11)</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: nothing = nothing
12: Int = Int * Int
13: Int = x
14: Int = Int - Int</code></pre><pre><code class="language-julia hljs">HerbGrammar.cleanup_removed_rules!(g₇)</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int * Int
12: Int = x
13: Int = Int - Int</code></pre><h2 id="Context-sensitive-grammars"><a class="docs-heading-anchor" href="#Context-sensitive-grammars">Context-sensitive grammars</a><a id="Context-sensitive-grammars-1"></a><a class="docs-heading-anchor-permalink" href="#Context-sensitive-grammars" title="Permalink"></a></h2><p>Context-sensitive grammars allow additional constraints to be added with respect to context-free grammars. The syntax for defining a context-sensitive grammar is identical to defining a context-sensitive grammar:</p><pre><code class="language-julia hljs">g₈ = HerbGrammar.@csgrammar begin
    Int = |(0:9)
    Int = Int + Int
    Int = Int * Int
    Int = x
end</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int + Int
12: Int = Int * Int
13: Int = x</code></pre><p>Constraints can be added using the <code>addconstraint!</code> function, which takes a context-sensitive grammar and a constraint and adds the constraint to the grammar. Currently, Herb.jl only has propagators constraints.  These constraints each have a corresponding <code>propagate</code> function that removes all options that violate that constraint from the domain.  At the moment, there are three propagator constraints:</p><ul><li><code>ComesAfter(rule, predecessors)</code>: It is only possible to use rule <code>rule</code> when <code>predecessors</code> are in its path to the root.</li><li><code>Forbidden(sequence)</code>: Forbids the derivation specified as a path in an expression tree.</li><li><code>Ordered(order)</code>: Rules have to be used in the specified order. That is, rule at index K can only be used if rules at indices <code>[1...K-1]</code> are used in the left subtree of the current expression.</li></ul><p>Below, an example is given of a context-sensitive grammar with a <code>ComesAfter</code> constraint:</p><pre><code class="language-julia hljs">HerbGrammar.addconstraint!(g₈, HerbConstraints.ComesAfter(1, [9]))</code></pre><pre><code class="nohighlight hljs">1-element Vector{Main.HerbCore.Constraint}:
 Main.HerbConstraints.ComesAfter(1, [9])</code></pre><h3 id="Probabilistic-grammars"><a class="docs-heading-anchor" href="#Probabilistic-grammars">Probabilistic grammars</a><a id="Probabilistic-grammars-1"></a><a class="docs-heading-anchor-permalink" href="#Probabilistic-grammars" title="Permalink"></a></h3><p>Herb.jl also supports probabilistic grammars.  These grammars allow the user to assign a probability to each rule in the grammar. A probabilistic grammar can be defined in a very similar way to a standard grammar, but has some slightly different syntax:</p><pre><code class="language-julia hljs">g₉ = HerbGrammar.@pcfgrammar begin
    0.4 : Int = |(0:9)
    0.2 : Int = Int + Int
    0.1 : Int = Int * Int
    0.3 : Int = x
end

for r ∈ 1:length(g₃.rules)
    p = HerbGrammar.probability(g₈, r)

    println(&quot;$p : $r&quot;)
end</code></pre><pre><code class="nohighlight hljs">0.07692307692307693 : 1
0.07692307692307693 : 2
0.07692307692307693 : 3
0.07692307692307693 : 4
0.07692307692307693 : 5
0.07692307692307693 : 6
0.07692307692307693 : 7


┌ Warning: Requesting probability in a non-probabilistic grammar.
│ Uniform distribution is assumed.
└ @ Main.HerbGrammar d:\GitHub\HerbGrammar.jl\src\grammar_base.jl:155
┌ Warning: Requesting probability in a non-probabilistic grammar.
│ Uniform distribution is assumed.
└ @ Main.HerbGrammar d:\GitHub\HerbGrammar.jl\src\grammar_base.jl:155
┌ Warning: Requesting probability in a non-probabilistic grammar.
│ Uniform distribution is assumed.
└ @ Main.HerbGrammar d:\GitHub\HerbGrammar.jl\src\grammar_base.jl:155
┌ Warning: Requesting probability in a non-probabilistic grammar.
│ Uniform distribution is assumed.
└ @ Main.HerbGrammar d:\GitHub\HerbGrammar.jl\src\grammar_base.jl:155
┌ Warning: Requesting probability in a non-probabilistic grammar.
│ Uniform distribution is assumed.
└ @ Main.HerbGrammar d:\GitHub\HerbGrammar.jl\src\grammar_base.jl:155
┌ Warning: Requesting probability in a non-probabilistic grammar.
│ Uniform distribution is assumed.
└ @ Main.HerbGrammar d:\GitHub\HerbGrammar.jl\src\grammar_base.jl:155
┌ Warning: Requesting probability in a non-probabilistic grammar.
│ Uniform distribution is assumed.
└ @ Main.HerbGrammar d:\GitHub\HerbGrammar.jl\src\grammar_base.jl:155</code></pre><p>The numbers before each rule represent the probability assigned to that rule. The total probability for each return type should add up to 1.0. If this isn&#39;t the case, Herb.jl will normalize the probabilities.</p><p>If a single line in the grammar definition represents multiple rules, such as <code>0.4 : Int = |(0:9)</code>, the probability will be evenly divided over all these rules.</p><h2 id="File-writing"><a class="docs-heading-anchor" href="#File-writing">File writing</a><a id="File-writing-1"></a><a class="docs-heading-anchor-permalink" href="#File-writing" title="Permalink"></a></h2><h3 id="Saving-and-loading-context-free-grammars"><a class="docs-heading-anchor" href="#Saving-and-loading-context-free-grammars">Saving &amp; loading context-free grammars</a><a id="Saving-and-loading-context-free-grammars-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-loading-context-free-grammars" title="Permalink"></a></h3><p>If you want to store a grammar on the disk, you can use the <code>store_cfg</code>, <code>read_cfg</code> and functions to store and read grammars respectively.  The <code>store_cfg</code> grammar can also be used to store probabilistic grammars. Reading probabilistic grammars can be done using <code>read_pcfg</code>. The stored grammar files can also be opened using a text editor to be modified, as long as the contents of the file doesn&#39;t violate the syntax for defining grammars.</p><pre><code class="language-julia hljs">HerbGrammar.store_cfg(&quot;demo.txt&quot;, g₇)</code></pre><pre><code class="language-julia hljs">HerbGrammar.read_cfg(&quot;demo.txt&quot;)</code></pre><pre><code class="nohighlight hljs">1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int * Int
12: Int = x
13: Int = Int - Int</code></pre><h3 id="Saving-and-loading-context-sensitive-grammars"><a class="docs-heading-anchor" href="#Saving-and-loading-context-sensitive-grammars">Saving &amp; loading context-sensitive grammars</a><a id="Saving-and-loading-context-sensitive-grammars-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-and-loading-context-sensitive-grammars" title="Permalink"></a></h3><p>Saving and loading context-sensitive grammars is very similar to how it is done with context-free grammars. The only difference is that an additional file is created for the constraints.  The file that contains the grammars can be edited and can also be read using the reader for context-free grammars. The file that contains the constraints cannot be edited.</p><pre><code class="language-julia hljs">HerbGrammar.store_csg(&quot;demo.grammar&quot;, &quot;demo.constraints&quot;, g₈)
g₈, g₈.constraints</code></pre><pre><code class="nohighlight hljs">(1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int + Int
12: Int = Int * Int
13: Int = x
, Main.HerbCore.Constraint[Main.HerbConstraints.ComesAfter(1, [9])])</code></pre><pre><code class="language-julia hljs">g₉ = HerbGrammar.read_csg(&quot;demo.grammar&quot;, &quot;demo.constraints&quot;)
g₉, g₉.constraints</code></pre><pre><code class="nohighlight hljs">(1: Int = 0
2: Int = 1
3: Int = 2
4: Int = 3
5: Int = 4
6: Int = 5
7: Int = 6
8: Int = 7
9: Int = 8
10: Int = 9
11: Int = Int + Int
12: Int = Int * Int
13: Int = x
, Main.HerbCore.Constraint[Main.HerbConstraints.ComesAfter(1, [9])])</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started_with_herb/">« A more verbose getting started with Herb.jl</a><a class="docs-footer-nextpage" href="../advanced_search/">Advanced Search Procedures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 15 March 2024 09:11">Friday 15 March 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
