<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HerbConstraints.jl · Herb.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Herb.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Herb.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../">Herb.jl</a></li><li><a class="tocitem" href="../install/">Installation Guide</a></li><li><a class="tocitem" href="../get_started/">Getting Started</a></li><li><a class="tocitem" href="../concepts/">Architecture and core concepts</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/getting_started_with_herb/">A more verbose getting started with Herb.jl</a></li><li><a class="tocitem" href="../tutorials/defining_grammars/">Defining Grammars in Herb.jl</a></li><li><a class="tocitem" href="../tutorials/advanced_search/">Advanced Search Procedures</a></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../HerbGrammar/">HerbGrammar.jl</a></li><li><a class="tocitem" href="../HerbSearch/">HerbSearch.jl</a></li><li class="is-active"><a class="tocitem" href>HerbConstraints.jl</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../HerbData/">HerbCore.jl</a></li><li><a class="tocitem" href="../HerbInterpret/">HerbInterpret.jl</a></li><li><a class="tocitem" href="../HerbData/">HerbData.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Sub-Modules</a></li><li class="is-active"><a href>HerbConstraints.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>HerbConstraints.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Herb-AI/Herb.jl/blob/master/docs/src/HerbConstraints/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="HerbConstraints_docs"><a class="docs-heading-anchor" href="#HerbConstraints_docs">HerbConstraints.jl Documentation</a><a id="HerbConstraints_docs-1"></a><a class="docs-heading-anchor-permalink" href="#HerbConstraints_docs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.AbstractMatchNode" href="#HerbConstraints.AbstractMatchNode"><code>HerbConstraints.AbstractMatchNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractMatchNode</code></pre><p>Tree structure to which rulenode trees can be matched. Consists of MatchNodes, which can match a specific RuleNode, and MatchVars, which is a variable that can be filled in with any RuleNode.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.ComesAfter" href="#HerbConstraints.ComesAfter"><code>HerbConstraints.ComesAfter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComesAfter &lt;: PropagatorConstraint</code></pre><p>A <a href="#HerbConstraints.ComesAfter"><code>ComesAfter</code></a> constraint is a <a href="#HerbConstraints.PropagatorConstraint"><code>PropagatorConstraint</code></a> containing the following:</p><ul><li><code>rule::Int</code>: A reference to a rule in the grammar</li><li><code>predecessors</code>: A list of rules in the grammar</li></ul><p>This <a href="../HerbCore/#HerbCore.Constraint"><code>Constraint</code></a> enforces that the <code>rule</code> can only be applied if every rule in  <code>predecessors</code> is used in the path from the root of the tree  to the current hole in the order  that they are given. Even though the rules must be in order, there might be other rules inbetween.</p><p>For example, consider the tree <code>1(a, 2(b, 3(c, d))))</code>:</p><ul><li><code>ComesAfter(4, [2, 3])</code> would enforce that rule <code>4</code> can only be used if <code>2</code> and <code>3</code>  are used in the path from the root in that order. Therefore, only hole <code>c</code> and <code>d</code> can be filled with <code>4</code>.</li><li><code>ComesAfter(4, [1, 3])</code> also allows <code>c</code> and <code>d</code> to be filled, since <code>1</code> and <code>3</code> are still used in the  correct order. It does not matter that <code>2</code> is also used in the path to the root.</li><li><code>ComesAfter(4, [3, 2])</code> does not allow any hole to be filled with <code>4</code>, since either the predecessors are  either not in the path or in the wrong order for each of the holes. </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.ComesAfter-Tuple{Int64, Int64}" href="#HerbConstraints.ComesAfter-Tuple{Int64, Int64}"><code>HerbConstraints.ComesAfter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ComesAfter(rule::Int, predecessor::Int)</code></pre><p>Creates a <a href="#HerbConstraints.ComesAfter"><code>ComesAfter</code></a> constraint with only a single <code>predecessor</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.Forbidden" href="#HerbConstraints.Forbidden"><code>HerbConstraints.Forbidden</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Forbidden &lt;: PropagatorConstraint</code></pre><p>This [<code>PropagatorConstraint</code>] forbids any subtree that matches the pattern given by <code>tree</code> to be generated. A pattern is a tree of <a href="#HerbConstraints.AbstractMatchNode"><code>AbstractMatchNode</code></a>s.  Such a node can either be a <a href="#HerbConstraints.MatchNode"><code>MatchNode</code></a>, which contains a rule index corresponding to the  rule index in the <a href="../HerbCore/#HerbCore.Grammar"><code>Grammar</code></a> and the appropriate number of children, similar to <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a>s. It can also contain a <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a>, which contains a single identifier symbol. A <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a> can match any subtree, but if there are multiple instances of the same variable in the pattern, the matched subtrees must be identical. Any rule in the domain that makes the match attempt successful is removed.</p><p>For example, consider the tree <code>1(a, 2(b, 3(c, 4))))</code>:</p><ul><li><code>Forbidden(MatchNode(3, [MatchNode(5), MatchNode(4)]))</code> forbids <code>c</code> to be filled with <code>5</code>.</li><li><code>Forbidden(MatchNode(3, [MatchVar(:v), MatchNode(4)]))</code> forbids <code>c</code> to be filled, since a [<code>MatchVar</code>] can  match any rule, thus making the match attempt successful for the entire domain of <code>c</code>.  Therefore, this tree invalid.</li><li><code>Forbidden(MatchNode(3, [MatchVar(:v), MatchVar(:v)]))</code> forbids <code>c</code> to be filled with <code>4</code>, since that would  make both assignments to <code>v</code> equal, which causes a successful match.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <a href="#HerbConstraints.Forbidden"><code>Forbidden</code></a> constraint makes use of <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s to make sure that constraints  are also enforced in the future when the context of a <a href="../HerbCore/#HerbCore.Hole"><code>Hole</code></a> changes.  Therefore, <a href="#HerbConstraints.Forbidden"><code>Forbidden</code></a> can only be used in implementations that keep track of the  <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s and propagate them at the right moments.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.ForbiddenPath" href="#HerbConstraints.ForbiddenPath"><code>HerbConstraints.ForbiddenPath</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForbiddenPath &lt;: PropagatorConstraint</code></pre><p>A [<code>PropagatorConstraint</code>] that forbids a certain derivation sequence. <code>sequence</code> defines the forbidden sequence.  Each rule that would complete the sequence when expanding a <a href="../HerbCore/#HerbCore.Hole"><code>Hole</code></a> in an  <a href="../HerbCore/#HerbCore.AbstractRuleNode"><code>AbstractRuleNode</code></a> tree is removed from the domain. The derivation sequence is the path from the root to the hole.</p><p>For example, consider the tree <code>1(a, 2(b, 3(c, d))))</code>:</p><ul><li><code>ForbiddenPath([1, 2, 4])</code> enforces that rule <code>4</code> cannot be applied at <code>b</code>,  since it completes the sequence. However, it can be applied at <code>a</code>, <code>c</code> and <code>d</code>.</li><li><code>ForbiddenPath([3, 1])</code> enforces that rule <code>1</code> cannot be applied at <code>c</code> or <code>d</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.GrammarContext" href="#HerbConstraints.GrammarContext"><code>HerbConstraints.GrammarContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct GrammarContext</code></pre><p>Structure used to track the context. Contains: 	- the expression being modified  	- the path to the hole that is being expanded, represented as a sequence of child indices. 	  e.g., [2, 1] would point to the first child of the second child of the root. 	- a vector with local constraints that should be propagated upon expansion.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.LocalConstraint" href="#HerbConstraints.LocalConstraint"><code>HerbConstraints.LocalConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type LocalConstraint &lt;: Constraint</code></pre><p>Abstract type representing all local constraints. Local constraints correspond to a specific (partial) <a href="../HerbCore/#HerbCore.AbstractRuleNode"><code>AbstractRuleNode</code></a> tree. Each local constraint contains a <code>path</code> to a specific location in the tree.   Each local constraint has an implementation of a <a href="#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>propagate</code></a>-function that takes</p><ul><li>the <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a></li><li>a <a href="../HerbCore/#HerbCore.Grammar"><code>Grammar</code></a></li><li>a <a href="#HerbConstraints.GrammarContext"><code>GrammarContext</code></a>, which most importantly contains the tree and the location  in the tree where propagation should take place.</li><li>The <code>domain</code> which the <a href="#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>propagate</code></a>-function prunes. </li></ul><p>The <a href="#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>propagate</code></a>-function returns a tuple containing</p><ul><li>The pruned <code>domain</code></li><li>A list of new <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>By default, <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s are only propagated once. Constraints that have to be propagated more frequently should return  themselves in the list of new local constraints.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.LocalForbidden" href="#HerbConstraints.LocalForbidden"><code>HerbConstraints.LocalForbidden</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LocalForbidden</code></pre><p>Forbids the a subtree that matches the MatchNode tree to be generated at the location  provided by the path.  Use a <code>Forbidden</code> constraint for enforcing this throughout the entire search space.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.LocalOneOf" href="#HerbConstraints.LocalOneOf"><code>HerbConstraints.LocalOneOf</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-constraint that enforces the disjunction of its given constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.LocalOrdered" href="#HerbConstraints.LocalOrdered"><code>HerbConstraints.LocalOrdered</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Enforces an order over two or more subtrees that fill the variables  specified in <code>order</code> when the pattern is applied at the location given by <code>path</code>. Use an <code>Ordered</code> constraint for enforcing this throughout the entire search space.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.MatchFail" href="#HerbConstraints.MatchFail"><code>HerbConstraints.MatchFail</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum MatchFail hardfail softfail</code></pre><p>This enum is used for distinguishing between two types of failures when trying to  match a <code>RuleNode</code> either with another <code>RuleNode</code> or with an <code>AbstractMatchNode</code></p><ul><li>Hardfail means that there is no match, and there is no way to fill in the holes to get a match.</li><li>Softfail means that there is no match, but there <em>might</em> be a way to fill the holes that results in a match.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.MatchNode" href="#HerbConstraints.MatchNode"><code>HerbConstraints.MatchNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MatchNode &lt;: AbstractMatchNode</code></pre><p>Match a specific rulenode, where the grammar rule index is <code>rule_ind</code>  and <code>children</code> matches the children of the RuleNode. Example usage:</p><pre><code class="nohighlight hljs">MatchNode(3, [MatchNode(1), MatchNode(2)])</code></pre><p>This matches <code>RuleNode(3, [RuleNode(1), RuleNode(2)])</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.MatchVar" href="#HerbConstraints.MatchVar"><code>HerbConstraints.MatchVar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct MatchVar &lt;: AbstractMatchNode</code></pre><p>Matches anything and assigns it to a variable.  The <code>ForbiddenTree</code> constraint will not match if identical variable symbols match to different trees. Example usage:</p><pre><code class="nohighlight hljs">MatchNode(3, [MatchVar(:x), MatchVar(:x)])</code></pre><p>This matches <code>RuleNode(3, [RuleNode(1), RuleNode(1)])</code>, <code>RuleNode(3, [RuleNode(2), RuleNode(2)])</code>, etc.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.OneOf" href="#HerbConstraints.OneOf"><code>HerbConstraints.OneOf</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Meta-constraint that enforces the disjunction of its given constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.Ordered" href="#HerbConstraints.Ordered"><code>HerbConstraints.Ordered</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ordered &lt;: PropagatorConstraint</code></pre><p>A <a href="#HerbConstraints.PropagatorConstraint"><code>PropagatorConstraint</code></a> that enforces a specific order in <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a>  assignments in the pattern defined by <code>tree</code>. A pattern is a tree of <a href="#HerbConstraints.AbstractMatchNode"><code>AbstractMatchNode</code></a>s.  Such a node can either be a <a href="#HerbConstraints.MatchNode"><code>MatchNode</code></a>, which contains a rule index corresponding to the  rule index in the <a href="../HerbCore/#HerbCore.Grammar"><code>Grammar</code></a> and the appropriate number of children, similar to <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a>s. It can also contain a <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a>, which contains a single identifier symbol. A <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a> can match any subtree, but if there are multiple instances of the same variable in the pattern, the matched subtrees must be identical.</p><p>The <code>order</code> defines an order between the variable assignments.  For example, if the order is <code>[x, y]</code>, the constraint will require  the assignment to <code>x</code> to be less than or equal to the assignment to <code>y</code>. The order is recursively defined by <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> indices.  For more information, see <a href="../HerbCore/#Base.isless-Tuple{AbstractRuleNode, AbstractRuleNode}"><code>Base.isless(rn₁::AbstractRuleNode, rn₂::AbstractRuleNode)</code></a>.</p><p>For example, consider the tree <code>1(a, 2(b, 3(c, 4))))</code>:</p><ul><li><code>Ordered(MatchNode(3, [MatchVar(:v), MatchVar(:w)]), [:v, :w])</code> removes every rule  with an index of 5 or greater from the domain of <code>c</code>, since that would make the index of the  assignment to <code>v</code> greater than the index of the assignment to <code>w</code>, violating the order.</li><li><code>Ordered(MatchNode(3, [MatchVar(:v), MatchVar(:w)]), [:w, :v])</code> removes every rule  with an index of 4 or less from the domain of <code>c</code>, since that would make the index of the  assignment to <code>v</code> less than the index of the assignment to <code>w</code>, violating the order.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <a href="#HerbConstraints.Ordered"><code>Ordered</code></a> constraint makes use of <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s to make sure that constraints  are also enforced in the future when the context of a <a href="../HerbCore/#HerbCore.Hole"><code>Hole</code></a> changes.  Therefore, <a href="#HerbConstraints.Ordered"><code>Ordered</code></a> can only be used in implementations that keep track of the  <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s and propagate them at the right moments.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.PropagatorConstraint" href="#HerbConstraints.PropagatorConstraint"><code>HerbConstraints.PropagatorConstraint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PropagatorConstraint &lt;: Constraint</code></pre><p>Abstract type representing all propagator constraints. Each propagator constraint has an implementation of a <a href="#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>propagate</code></a>-function that takes</p><ul><li>the <a href="#HerbConstraints.PropagatorConstraint"><code>PropagatorConstraint</code></a></li><li>a <a href="../HerbCore/#HerbCore.Grammar"><code>Grammar</code></a></li><li>a <a href="#HerbConstraints.GrammarContext"><code>GrammarContext</code></a>, which most importantly contains the tree and the location  in the tree where propagation should take place.</li><li>The <code>domain</code> which the <a href="#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>propagate</code></a>-function prunes. </li></ul><p>The <a href="#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>propagate</code></a>-function returns a tuple containing</p><ul><li>The pruned <code>domain</code></li><li>A list of new <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.RequireOnLeft" href="#HerbConstraints.RequireOnLeft"><code>HerbConstraints.RequireOnLeft</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Rules have to be used in the specified order. That is, rule at index K can only be used if rules at indices [1...K-1] are used in the left subtree of the current expression</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.@csgrammar_annotated-Tuple{Any}" href="#HerbConstraints.@csgrammar_annotated-Tuple{Any}"><code>HerbConstraints.@csgrammar_annotated</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@csgrammar_annotated Define an annotated grammar and return it as a ContextSensitiveGrammar. Allows for adding optional annotations per rule. As well as that, allows for adding optional labels per rule, which can be referenced in annotations.  Syntax is backwards-compatible with @csgrammar. Examples:</p><pre><code class="language-julia-repl hljs">g₁ = @csgrammar_annotated begin
    Element = 1
    Element = x
    Element = Element + Element := commutative
    Element = Element * Element := (commutative, transitive)
end</code></pre><pre><code class="language-julia-repl hljs">g₁ = @csgrammar_annotated begin
    Element = 1
    Element = x
    Element = Element + Element := forbidden_path([3, 1])
    Element = Element * Element := (commutative, transitive)
end</code></pre><pre><code class="language-julia-repl hljs">g₁ = @csgrammar_annotated begin
    one::            Element = 1
    variable::       Element = x
    addition::       Element = Element + Element := (
                                                       commutative,
                                                       transitive,
                                                       forbidden_path([:addition, :one]) || forbidden_path([:one, :variable])
                                                    )
    multiplication:: Element = Element * Element := (commutative, transitive)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MatchNode}" href="#Base.show-Tuple{IO, MatchNode}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, node::MatchNode; separator=&quot;,&quot;, last_child::Bool=true)</code></pre><p>Prints a found <a href="#HerbConstraints.MatchNode"><code>MatchNode</code></a> given an and the respective children to <code>IO</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MatchVar}" href="#Base.show-Tuple{IO, MatchVar}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, node::MatchVar; separator=&quot;,&quot;, last_child::Bool=true)</code></pre><p>Prints a matching variable assignment described by <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a> to <code>IO</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._matchnode2expr" href="#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_matchnode2expr(expr::Expr, pattern::MatchVar, grammar::Grammar, j=0)</code></pre><p>Internal function for <a href="#HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}"><code>matchnode2expr</code></a>, recursively iterating over a matched variable and converting it to an expression. This is primarily useful for pretty-printing a pattern. Returns the corresponding expression and the current child index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._matchnode2expr" href="#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_matchnode2expr(typ::Symbol, pattern::MatchNode, grammar::Grammar, j=0)</code></pre><p>Internal function for <a href="#HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}"><code>matchnode2expr</code></a>, returning the matched translated symbol. This is primarily useful for pretty-printing a pattern. Returns the corresponding expression, i.e. the variable name and the current child index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._matchnode2expr" href="#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_matchnode2expr(typ::Symbol, pattern::MatchVar, grammar::Grammar, j=0)</code></pre><p>Internal function for <a href="#HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}"><code>matchnode2expr</code></a>. This is primarily useful for pretty-printing a pattern. Returns the corresponding expression, i.e. the variable name and the current child index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._matchnode2expr" href="#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_matchnode2expr(expr::Expr, pattern::MatchNode, grammar::Grammar, j=0)</code></pre><p>Internal function for <a href="#HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}"><code>matchnode2expr</code></a>, recursively iterating over a matched pattern and converting it to an expression. This is primarily useful for pretty-printing a pattern. Returns the corresponding expression and the current child index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._pattern_match-Tuple{RuleNode, MatchNode, Dict{Symbol, AbstractRuleNode}}" href="#HerbConstraints._pattern_match-Tuple{RuleNode, MatchNode, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_pattern_match(rn::RuleNode, mn::MatchNode, vars::Dict{Symbol, AbstractRuleNode})::Union{Nothing, MatchFail}</code></pre><p>Tries to match <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> <code>rn</code> with <a href="#HerbConstraints.MatchNode"><code>MatchNode</code></a> <code>mn</code>. Modifies the variable assignment dictionary <code>vars</code>. Returns <code>nothing</code> if the match is successful. If the match is unsuccessful, it returns whether it is a softfail or hardfail (see <a href="#HerbConstraints.MatchFail"><code>MatchFail</code></a> docstring)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._pattern_match-Tuple{RuleNode, MatchVar, Dict{Symbol, AbstractRuleNode}}" href="#HerbConstraints._pattern_match-Tuple{RuleNode, MatchVar, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_pattern_match(rn::RuleNode, mv::MatchVar, vars::Dict{Symbol, AbstractRuleNode})::Union{Nothing, MatchFail}</code></pre><p>Matching <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> <code>rn</code> with <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a> <code>mv</code>. If the variable is already assigned, the rulenode is matched with the specific variable value. Returns <code>nothing</code> if the match is succesful.  If the match is unsuccessful, it returns whether it is a softfail or hardfail (see <a href="#HerbConstraints.MatchFail"><code>MatchFail</code></a> docstring)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}" href="#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_pattern_match_with_hole(::Hole, mn::MatchNode, hole_location::Vector{Int}, ::Dict{Symbol, AbstractRuleNode})::Union{Int, Symbol, MatchFail, Tuple{Symbol, Vector{Int}}}</code></pre><p>Matches the <a href="../HerbCore/#HerbCore.Hole"><code>Hole</code></a> with the given <a href="#HerbConstraints.MatchNode"><code>MatchNode</code></a>. </p><p>TODO check this behaviour?</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}" href="#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_pattern_match_with_hole(::Hole, mn::MatchNode, hole_location::Vector{Int}, ::Dict{Symbol, AbstractRuleNode})::Union{Int, Symbol, MatchFail, Tuple{Symbol, Vector{Int}}}</code></pre><p>Matches the <a href="../HerbCore/#HerbCore.Hole"><code>Hole</code></a> with the given <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a>, similar to <a href="#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>_pattern_match_with_hole</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}" href="#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_pattern_match_with_hole(rn::RuleNode, mn::MatchNode, hole_location::Vector{Int}, vars::Dict{Symbol, AbstractRuleNode})::Union{Int, Symbol, MatchFail, Tuple{Symbol, Vector{Int}}}</code></pre><p>Tries to match <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> <code>rn</code> with <a href="#HerbConstraints.MatchNode"><code>MatchNode</code></a> <code>mn</code> and fill in the domain of the hole at <code>hole_location</code>.  Returns if match is successful either:</p><ul><li>The id for the node which fills the hole</li><li>A symbol for the variable that fills the hole</li><li>A tuple containing:<ul><li>The variable that matched (the subtree containing) the hole</li><li>The location of the hole in this subtree</li></ul></li></ul><p>If the match is unsuccessful, it returns:</p><ul><li>hardfail if there are no holes that can be filled in such a way that the match will become succesful</li><li>softfail if the match could become successful if the holes are filled in a certain way</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}" href="#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_pattern_match_with_hole(rn::RuleNode, mv::MatchVar, hole_location::Vector{Int}, vars::Dict{Symbol, AbstractRuleNode})::Union{Int, Symbol, MatchFail, Tuple{Symbol, Vector{Int}}}</code></pre><p>Tries to match <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> <code>rn</code> with <a href="#HerbConstraints.MatchVar"><code>MatchVar</code></a> <code>mv</code> and fill in the domain of the hole at <code>hole_location</code>. If the variable name is already assigned in <code>vars</code>, the rulenode is matched with the hole. Otherwise the variable and the hole location are returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._rulenode_compare-Tuple{RuleNode, RuleNode}" href="#HerbConstraints._rulenode_compare-Tuple{RuleNode, RuleNode}"><code>HerbConstraints._rulenode_compare</code></a> — <span class="docstring-category">Method</span></header><section><div><ul><li>Returns -1 if rn₁ &lt; rn₂</li><li>Returns  0 if rn₁ == rn₂  </li><li>Returns  1 if rn₁ &gt; rn₂</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints._rulenode_match_with_hole-Tuple{RuleNode, RuleNode, Vector{Int64}}" href="#HerbConstraints._rulenode_match_with_hole-Tuple{RuleNode, RuleNode, Vector{Int64}}"><code>HerbConstraints._rulenode_match_with_hole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_rulenode_match_with_hole(rn₁::RuleNode, rn₂::RuleNode, hole_location::Vector{Int})::Union{Int, MatchFail}</code></pre><p>Matches two rulenodes.  Returns how to fill in the hole in rn₁ to make it match rn₂ if:</p><ul><li>rn₁ has a single hole at the provided location</li><li>rn₂ doesn&#39;t have any holes</li><li>rn₁ matches rn₂ apart from the single hole location.</li></ul><p>If the match fails, it returns whether it is a softfail or a hardfail (see MatchFail docstring)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.addparent!-Tuple{GrammarContext, Int64}" href="#HerbConstraints.addparent!-Tuple{GrammarContext, Int64}"><code>HerbConstraints.addparent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addparent!(context::GrammarContext, parent::Int)</code></pre><p>Adds a parent to the context. The parent is defined by the grammar rule id.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.annotation2constraint-Tuple{Any, Int64, Vector{String}}" href="#HerbConstraints.annotation2constraint-Tuple{Any, Int64, Vector{String}}"><code>HerbConstraints.annotation2constraint</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Converts an annotation to a constraint. commutative: creates an Ordered constraint transitive: creates an (incorrect) Forbidden constraint forbidden_path(path::Vector{Union{Symbol, Int}}): creates a ForbiddenPath constraint with the original rule included ... || ...: creates a OneOf constraint (also works with ... || ... || ... et cetera, though not very performant)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.check_tree-Tuple{ComesAfter, Grammar, AbstractRuleNode}" href="#HerbConstraints.check_tree-Tuple{ComesAfter, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if the given tree abides the constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.check_tree-Tuple{Forbidden, Grammar, RuleNode}" href="#HerbConstraints.check_tree-Tuple{Forbidden, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_tree(c::Forbidden, g::Grammar, tree::RuleNode)::Bool</code></pre><p>Checks if the given <a href="../HerbCore/#HerbCore.AbstractRuleNode"><code>AbstractRuleNode</code></a> tree abides the <a href="#HerbConstraints.Forbidden"><code>Forbidden</code></a> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.check_tree-Tuple{ForbiddenPath, Grammar, AbstractRuleNode}" href="#HerbConstraints.check_tree-Tuple{ForbiddenPath, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if the given tree abides the constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.check_tree-Tuple{HerbConstraints.Condition, Grammar, RuleNode}" href="#HerbConstraints.check_tree-Tuple{HerbConstraints.Condition, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if the given tree abides the constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.check_tree-Tuple{OneOf, Grammar, AbstractRuleNode}" href="#HerbConstraints.check_tree-Tuple{OneOf, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if the given tree abides the constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.check_tree-Tuple{Ordered, Grammar, RuleNode}" href="#HerbConstraints.check_tree-Tuple{Ordered, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_tree(c::Ordered, g::Grammar, tree::RuleNode)::Bool</code></pre><p>Checks if the given <a href="../HerbCore/#HerbCore.AbstractRuleNode"><code>AbstractRuleNode</code></a> tree abides the <a href="#HerbConstraints.Ordered"><code>Ordered</code></a> constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.check_tree-Tuple{RequireOnLeft, Grammar, AbstractRuleNode}" href="#HerbConstraints.check_tree-Tuple{RequireOnLeft, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if the given tree abides the constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.copy_and_insert-Tuple{GrammarContext, Int64}" href="#HerbConstraints.copy_and_insert-Tuple{GrammarContext, Int64}"><code>HerbConstraints.copy_and_insert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_and_insert(old_context::GrammarContext, parent::Int)</code></pre><p>Copies the given context and insert the parent in the node location.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.make_smaller_or_equal-Tuple{RuleNode, RuleNode, Vector{Int64}, Vector{Int64}}" href="#HerbConstraints.make_smaller_or_equal-Tuple{RuleNode, RuleNode, Vector{Int64}, Vector{Int64}}"><code>HerbConstraints.make_smaller_or_equal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Filters the <code>domain</code> of the hole at <code>hole_location</code> in <code>rn₁</code> to make <code>rn₁</code> be ordered before <code>rn₂</code>.   Returns the filtered domain, and a boolean indicating if this constraint can be deleted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}" href="#HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}"><code>HerbConstraints.matchnode2expr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matchnode2expr(pattern::MatchNode, grammar::Grammar)</code></pre><p>Converts a MatchNode tree into a Julia expression.  This is primarily useful for pretty-printing a pattern. Returns the corresponding expression.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.matchnode2expr-Tuple{MatchVar, Grammar}" href="#HerbConstraints.matchnode2expr-Tuple{MatchVar, Grammar}"><code>HerbConstraints.matchnode2expr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matchnode2expr(pattern::MatchVar, grammar::Grammar)</code></pre><p>Converts a MatchVar into an expression by returning the variable directly. This is primarily useful for pretty-printing a pattern.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}" href="#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate(c::Forbidden, g::Grammar, context::GrammarContext, domain::Vector{Int})::Tuple{Vector{Int}, Vector{LocalConstraint}}</code></pre><p>Propagates the <a href="#HerbConstraints.Forbidden"><code>Forbidden</code></a> constraint. It removes the rules from the <code>domain</code> that would complete the forbidden tree.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <a href="#HerbConstraints.Forbidden"><code>Forbidden</code></a> constraint makes use of <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s to make sure that constraints  are also enforced in the future when the context of a <a href="../HerbCore/#HerbCore.Hole"><code>Hole</code></a> changes.  Therefore, <a href="#HerbConstraints.Forbidden"><code>Forbidden</code></a> can only be used in implementations that keep track of the  <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s and propagate them at the right moments.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.propagate-Tuple{ForbiddenPath, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}" href="#HerbConstraints.propagate-Tuple{ForbiddenPath, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagates the <a href="#HerbConstraints.ForbiddenPath"><code>ForbiddenPath</code></a> constraint. It removes the elements from the domain that would complete the forbidden sequence.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.propagate-Tuple{HerbConstraints.LocalOneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}" href="#HerbConstraints.propagate-Tuple{HerbConstraints.LocalOneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagates the LocalOneOf constraint. It enforces that at least one of its given constraints hold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.propagate-Tuple{LocalForbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}" href="#HerbConstraints.propagate-Tuple{LocalForbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagates the LocalForbidden constraint. It removes rules from the domain that would make the RuleNode at the given path match the pattern defined by the MatchNode.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.propagate-Tuple{LocalOrdered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}" href="#HerbConstraints.propagate-Tuple{LocalOrdered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagates the LocalOrdered constraint. It removes rules from the domain that would violate the order of variables as defined in the  constraint.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.propagate-Tuple{OneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}" href="#HerbConstraints.propagate-Tuple{OneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagates the OneOf constraint. It enforces that at least one of its given constraints hold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.propagate-Tuple{Ordered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}" href="#HerbConstraints.propagate-Tuple{Ordered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate(c::Ordered, g::Grammar, context::GrammarContext, domain::Vector{Int})::Tuple{Vector{Int}, Vector{LocalConstraint}}</code></pre><p>Propagates the <a href="#HerbConstraints.Ordered"><code>Ordered</code></a> constraint. Any rule that violates the order as defined by the contraint is removed from the <code>domain</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <a href="#HerbConstraints.Ordered"><code>Ordered</code></a> constraint makes use of <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s to make sure that constraints  are also enforced in the future when the context of a <a href="../HerbCore/#HerbCore.Hole"><code>Hole</code></a> changes.  Therefore, <a href="#HerbConstraints.Ordered"><code>Ordered</code></a> can only be used in implementations that keep track of the  <a href="#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s and propagate them at the right moments.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbConstraints.propagate-Tuple{RequireOnLeft, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}" href="#HerbConstraints.propagate-Tuple{RequireOnLeft, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagates the RequireOnLeft constraint. It removes every element from the domain that does not have a necessary  predecessor in the left subtree.</p></div></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#HerbConstraints.AbstractMatchNode"><code>HerbConstraints.AbstractMatchNode</code></a></li><li><a href="#HerbConstraints.ComesAfter"><code>HerbConstraints.ComesAfter</code></a></li><li><a href="#HerbConstraints.ComesAfter-Tuple{Int64, Int64}"><code>HerbConstraints.ComesAfter</code></a></li><li><a href="#HerbConstraints.Forbidden"><code>HerbConstraints.Forbidden</code></a></li><li><a href="#HerbConstraints.ForbiddenPath"><code>HerbConstraints.ForbiddenPath</code></a></li><li><a href="#HerbConstraints.GrammarContext"><code>HerbConstraints.GrammarContext</code></a></li><li><a href="#HerbConstraints.LocalConstraint"><code>HerbConstraints.LocalConstraint</code></a></li><li><a href="#HerbConstraints.LocalForbidden"><code>HerbConstraints.LocalForbidden</code></a></li><li><a href="#HerbConstraints.LocalOneOf"><code>HerbConstraints.LocalOneOf</code></a></li><li><a href="#HerbConstraints.LocalOrdered"><code>HerbConstraints.LocalOrdered</code></a></li><li><a href="#HerbConstraints.MatchFail"><code>HerbConstraints.MatchFail</code></a></li><li><a href="#HerbConstraints.MatchNode"><code>HerbConstraints.MatchNode</code></a></li><li><a href="#HerbConstraints.MatchVar"><code>HerbConstraints.MatchVar</code></a></li><li><a href="#HerbConstraints.OneOf"><code>HerbConstraints.OneOf</code></a></li><li><a href="#HerbConstraints.Ordered"><code>HerbConstraints.Ordered</code></a></li><li><a href="#HerbConstraints.PropagatorConstraint"><code>HerbConstraints.PropagatorConstraint</code></a></li><li><a href="#HerbConstraints.RequireOnLeft"><code>HerbConstraints.RequireOnLeft</code></a></li><li><a href="../HerbCore/#HerbCore.AbstractRuleNode"><code>HerbCore.AbstractRuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.Constraint"><code>HerbCore.Constraint</code></a></li><li><a href="../HerbCore/#HerbCore.Grammar"><code>HerbCore.Grammar</code></a></li><li><a href="../HerbCore/#HerbCore.Hole"><code>HerbCore.Hole</code></a></li><li><a href="../HerbCore/#HerbCore.HoleReference"><code>HerbCore.HoleReference</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode-Tuple{Int64, Vector{AbstractRuleNode}}"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode-Tuple{Int64, Any}"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbData/#HerbData.IOExample"><code>HerbData.IOExample</code></a></li><li><a href="../HerbData/#HerbData.IOPExample"><code>HerbData.IOPExample</code></a></li><li><a href="../HerbData/#HerbData.Problem"><code>HerbData.Problem</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.ContextFreeGrammar"><code>HerbGrammar.ContextFreeGrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.ContextSensitiveGrammar"><code>HerbGrammar.ContextSensitiveGrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.NodeLoc"><code>HerbGrammar.NodeLoc</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.SymbolTable"><code>HerbGrammar.SymbolTable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.SymbolTable"><code>HerbGrammar.SymbolTable</code></a></li><li><a href="../HerbSearch/#HerbSearch.ContextSensitivePriorityEnumerator"><code>HerbSearch.ContextSensitivePriorityEnumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.ExpandFailureReason"><code>HerbSearch.ExpandFailureReason</code></a></li><li><a href="../HerbSearch/#HerbSearch.ExpressionIterator"><code>HerbSearch.ExpressionIterator</code></a></li><li><a href="../HerbSearch/#HerbSearch.GeneticSearchIterator"><code>HerbSearch.GeneticSearchIterator</code></a></li><li><a href="../HerbSearch/#HerbSearch.PriorityQueueItem-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.PriorityQueueItem</code></a></li><li><a href="../HerbSearch/#HerbSearch.PriorityQueueItem"><code>HerbSearch.PriorityQueueItem</code></a></li><li><a href="../HerbSearch/#HerbSearch.PropagateResult"><code>HerbSearch.PropagateResult</code></a></li><li><a href="../HerbSearch/#HerbSearch.StochasticSearchEnumerator"><code>HerbSearch.StochasticSearchEnumerator</code></a></li><li><a href="../HerbGrammar/#Base.get-Tuple{RuleNode, NodeLoc}"><code>Base.get</code></a></li><li><a href="../HerbGrammar/#Base.insert!-Tuple{RuleNode, NodeLoc, RuleNode}"><code>Base.insert!</code></a></li><li><a href="../HerbCore/#Base.isless-Tuple{AbstractRuleNode, AbstractRuleNode}"><code>Base.isless</code></a></li><li><a href="../HerbSearch/#Base.iterate-Tuple{ContextSensitivePriorityEnumerator, DataStructures.PriorityQueue}"><code>Base.iterate</code></a></li><li><a href="../HerbSearch/#Base.iterate-Tuple{HerbSearch.GeneticSearchIterator, HerbSearch.GeneticIteratorState}"><code>Base.iterate</code></a></li><li><a href="../HerbSearch/#Base.iterate-Tuple{HerbSearch.GeneticSearchIterator}"><code>Base.iterate</code></a></li><li><a href="../HerbSearch/#Base.iterate-Tuple{ContextSensitivePriorityEnumerator}"><code>Base.iterate</code></a></li><li><a href="../HerbSearch/#Base.iterate-Tuple{HerbSearch.StochasticSearchEnumerator, HerbSearch.IteratorState}"><code>Base.iterate</code></a></li><li><a href="../HerbCore/#Base.length-Tuple{Hole}"><code>Base.length</code></a></li><li><a href="../HerbCore/#Base.length-Tuple{RuleNode}"><code>Base.length</code></a></li><li><a href="../HerbSearch/#Base.rand"><code>Base.rand</code></a></li><li><a href="../HerbSearch/#Base.rand"><code>Base.rand</code></a></li><li><a href="../HerbSearch/#Base.rand"><code>Base.rand</code></a></li><li><a href="#Base.show-Tuple{IO, MatchNode}"><code>Base.show</code></a></li><li><a href="#Base.show-Tuple{IO, MatchVar}"><code>Base.show</code></a></li><li><a href="#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="#HerbConstraints._pattern_match-Tuple{RuleNode, MatchNode, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match</code></a></li><li><a href="#HerbConstraints._pattern_match-Tuple{RuleNode, MatchVar, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match</code></a></li><li><a href="#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="#HerbConstraints._rulenode_compare-Tuple{RuleNode, RuleNode}"><code>HerbConstraints._rulenode_compare</code></a></li><li><a href="#HerbConstraints._rulenode_match_with_hole-Tuple{RuleNode, RuleNode, Vector{Int64}}"><code>HerbConstraints._rulenode_match_with_hole</code></a></li><li><a href="#HerbConstraints.addparent!-Tuple{GrammarContext, Int64}"><code>HerbConstraints.addparent!</code></a></li><li><a href="#HerbConstraints.annotation2constraint-Tuple{Any, Int64, Vector{String}}"><code>HerbConstraints.annotation2constraint</code></a></li><li><a href="#HerbConstraints.check_tree-Tuple{Forbidden, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="#HerbConstraints.check_tree-Tuple{Ordered, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="#HerbConstraints.check_tree-Tuple{HerbConstraints.Condition, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="#HerbConstraints.check_tree-Tuple{ForbiddenPath, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="#HerbConstraints.check_tree-Tuple{ComesAfter, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="#HerbConstraints.check_tree-Tuple{RequireOnLeft, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="#HerbConstraints.check_tree-Tuple{OneOf, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="#HerbConstraints.copy_and_insert-Tuple{GrammarContext, Int64}"><code>HerbConstraints.copy_and_insert</code></a></li><li><a href="#HerbConstraints.make_smaller_or_equal-Tuple{RuleNode, RuleNode, Vector{Int64}, Vector{Int64}}"><code>HerbConstraints.make_smaller_or_equal</code></a></li><li><a href="#HerbConstraints.matchnode2expr-Tuple{MatchVar, Grammar}"><code>HerbConstraints.matchnode2expr</code></a></li><li><a href="#HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}"><code>HerbConstraints.matchnode2expr</code></a></li><li><a href="#HerbConstraints.propagate-Tuple{OneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="#HerbConstraints.propagate-Tuple{LocalForbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="#HerbConstraints.propagate-Tuple{Ordered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="#HerbConstraints.propagate-Tuple{RequireOnLeft, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="#HerbConstraints.propagate-Tuple{LocalOrdered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="#HerbConstraints.propagate-Tuple{ForbiddenPath, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="#HerbConstraints.propagate-Tuple{HerbConstraints.LocalOneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbCore/#HerbCore.contains_hole-Tuple{RuleNode}"><code>HerbCore.contains_hole</code></a></li><li><a href="../HerbCore/#HerbCore.depth-Tuple{RuleNode}"><code>HerbCore.depth</code></a></li><li><a href="../HerbCore/#HerbCore.get_node_at_location-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.get_node_at_location</code></a></li><li><a href="../HerbCore/#HerbCore.get_rulesequence-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.get_rulesequence</code></a></li><li><a href="../HerbCore/#HerbCore.node_depth-Tuple{AbstractRuleNode, AbstractRuleNode}"><code>HerbCore.node_depth</code></a></li><li><a href="../HerbCore/#HerbCore.rulesoftype-Tuple{RuleNode, Set{Int64}}"><code>HerbCore.rulesoftype</code></a></li><li><a href="../HerbCore/#HerbCore.rulesonleft-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.rulesonleft</code></a></li><li><a href="../HerbCore/#HerbCore.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}"><code>HerbCore.swap_node</code></a></li><li><a href="../HerbCore/#HerbCore.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}"><code>HerbCore.swap_node</code></a></li><li><a href="../HerbData/#HerbData.read_IOPexamples-Tuple{AbstractString}"><code>HerbData.read_IOPexamples</code></a></li><li><a href="../HerbData/#HerbData.read_IOexamples-Tuple{AbstractString}"><code>HerbData.read_IOexamples</code></a></li><li><a href="../HerbData/#HerbData.readdata-Tuple{AbstractString, Function}"><code>HerbData.readdata</code></a></li><li><a href="../HerbData/#HerbData.readfile-Tuple{AbstractString, Function}"><code>HerbData.readfile</code></a></li><li><a href="../HerbData/#HerbData.write_IOPexamples-Tuple{AbstractString, Vector{IOPExample}}"><code>HerbData.write_IOPexamples</code></a></li><li><a href="../HerbData/#HerbData.write_IOexamples-Tuple{AbstractString, Vector{IOExample}}"><code>HerbData.write_IOexamples</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.add_rule!-Tuple{Grammar, Expr}"><code>HerbGrammar.add_rule!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.addconstraint!-Tuple{ContextSensitiveGrammar, Constraint}"><code>HerbGrammar.addconstraint!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.cfg2csg-Tuple{ContextFreeGrammar}"><code>HerbGrammar.cfg2csg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.child_types-Tuple{Grammar, Int64}"><code>HerbGrammar.child_types</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.child_types-Tuple{Grammar, RuleNode}"><code>HerbGrammar.child_types</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.cleanup_removed_rules!-Tuple{Grammar}"><code>HerbGrammar.cleanup_removed_rules!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.clearconstraints!-Tuple{ContextSensitiveGrammar}"><code>HerbGrammar.clearconstraints!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.containedin-Tuple{Vector, Vector}"><code>HerbGrammar.containedin</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.contains_returntype"><code>HerbGrammar.contains_returntype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2cfgrammar-Tuple{Expr}"><code>HerbGrammar.expr2cfgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2csgrammar-Tuple{Expr}"><code>HerbGrammar.expr2csgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2pcfgrammar-Tuple{Expr}"><code>HerbGrammar.expr2pcfgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2pcsgrammar-Tuple{Expr}"><code>HerbGrammar.expr2pcsgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_childtypes-Tuple{Any, AbstractVector{Symbol}}"><code>HerbGrammar.get_childtypes</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_domain-Tuple{Grammar, Vector{Int64}}"><code>HerbGrammar.get_domain</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_domain-Tuple{Grammar, Symbol}"><code>HerbGrammar.get_domain</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_node_at_location-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.get_node_at_location</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_rulesequence-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.get_rulesequence</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.has_children-Tuple{RuleNode}"><code>HerbGrammar.has_children</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iscomplete-Tuple{Grammar, RuleNode}"><code>HerbGrammar.iscomplete</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{Any}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{Grammar}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{Grammar, Int64}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isprobabilistic-Tuple{Grammar}"><code>HerbGrammar.isprobabilistic</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{Grammar, Int64}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{Any, AbstractVector{Symbol}}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{Grammar, RuleNode}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isvariable-Tuple{Grammar, RuleNode}"><code>HerbGrammar.isvariable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.log_probability-Tuple{Grammar, Int64}"><code>HerbGrammar.log_probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.max_arity-Tuple{Grammar}"><code>HerbGrammar.max_arity</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.mindepth-Tuple{Grammar, Symbol, AbstractVector{Int64}}"><code>HerbGrammar.mindepth</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.mindepth_map-Tuple{Grammar}"><code>HerbGrammar.mindepth_map</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nchildren-Tuple{Grammar, RuleNode}"><code>HerbGrammar.nchildren</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nchildren-Tuple{Grammar, Int64}"><code>HerbGrammar.nchildren</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nonterminals-Tuple{Grammar}"><code>HerbGrammar.nonterminals</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.probability-Tuple{Grammar, Int64}"><code>HerbGrammar.probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_cfg-Tuple{AbstractString}"><code>HerbGrammar.read_cfg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_csg-Tuple{AbstractString, AbstractString}"><code>HerbGrammar.read_csg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_pcfg-Tuple{AbstractString}"><code>HerbGrammar.read_pcfg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_pcsg-Tuple{AbstractString, AbstractString}"><code>HerbGrammar.read_pcsg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.remove_rule!-Tuple{Grammar, Int64}"><code>HerbGrammar.remove_rule!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.return_type-Tuple{Grammar, Int64}"><code>HerbGrammar.return_type</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.return_type-Tuple{Grammar, RuleNode}"><code>HerbGrammar.return_type</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.root_node_loc-Tuple{RuleNode}"><code>HerbGrammar.root_node_loc</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulenode2expr-Tuple{RuleNode, Grammar}"><code>HerbGrammar.rulenode2expr</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulenode_log_probability-Tuple{RuleNode, Grammar}"><code>HerbGrammar.rulenode_log_probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Grammar, Symbol, RuleNode}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Grammar, Symbol}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Set{Int64}, RuleNode}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesonleft-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.rulesonleft</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.store_cfg-Tuple{AbstractString, ContextFreeGrammar}"><code>HerbGrammar.store_cfg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.store_csg-Tuple{AbstractString, AbstractString, ContextSensitiveGrammar}"><code>HerbGrammar.store_csg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.subsequenceof-Tuple{Vector{Int64}, Vector{Int64}}"><code>HerbGrammar.subsequenceof</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}"><code>HerbGrammar.swap_node</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}"><code>HerbGrammar.swap_node</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.evaluate_program-Tuple{RuleNode, Vector{&lt;:Example}, Grammar, Function}"><code>HerbInterpret.evaluate_program</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.execute_on_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Dict{Symbol, Any}}}"><code>HerbInterpret.execute_on_examples</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.interpret-Tuple{Dict{Symbol, Any}, Any}"><code>HerbInterpret.interpret</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.test_all_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Example}}"><code>HerbInterpret.test_all_examples</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.test_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Example}}"><code>HerbInterpret.test_examples</code></a></li><li><a href="../HerbInterpret/#HerbInterpret.test_with_input-Tuple{Dict{Symbol, Any}, Any, Dict}"><code>HerbInterpret.test_with_input</code></a></li><li><a href="../HerbSearch/#HerbSearch._expand-Tuple{RuleNode, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}"><code>HerbSearch._expand</code></a></li><li><a href="../HerbSearch/#HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}"><code>HerbSearch._expand</code></a></li><li><a href="../HerbSearch/#HerbSearch._find_next_complete_tree-Tuple{ContextSensitiveGrammar, Int64, Int64, Function, Function, DataStructures.PriorityQueue}"><code>HerbSearch._find_next_complete_tree</code></a></li><li><a href="../HerbSearch/#HerbSearch.best_accept-Tuple{Real, Real, Any}"><code>HerbSearch.best_accept</code></a></li><li><a href="../HerbSearch/#HerbSearch.calculate_cost-Tuple{RuleNode, Function, AbstractVector{Example}, Grammar, Function}"><code>HerbSearch.calculate_cost</code></a></li><li><a href="../HerbSearch/#HerbSearch.const_temperature-Tuple{Any}"><code>HerbSearch.const_temperature</code></a></li><li><a href="../HerbSearch/#HerbSearch.constructNeighbourhood-Tuple{RuleNode, Grammar}"><code>HerbSearch.constructNeighbourhood</code></a></li><li><a href="../HerbSearch/#HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, Grammar}"><code>HerbSearch.constructNeighbourhoodRuleSubset</code></a></li><li><a href="../HerbSearch/#HerbSearch.count_expressions-Tuple{ExpressionIterator}"><code>HerbSearch.count_expressions</code></a></li><li><a href="../HerbSearch/#HerbSearch.count_expressions-Tuple{Grammar, Int64, Int64, Symbol}"><code>HerbSearch.count_expressions</code></a></li><li><a href="../HerbSearch/#HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_1</code></a></li><li><a href="../HerbSearch/#HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_2</code></a></li><li><a href="../HerbSearch/#HerbSearch.decreasing_temperature-Tuple{Real}"><code>HerbSearch.decreasing_temperature</code></a></li><li><a href="../HerbSearch/#HerbSearch.default_error_function-Tuple{Any, Any, Any}"><code>HerbSearch.default_error_function</code></a></li><li><a href="../HerbSearch/#HerbSearch.default_fitness-Tuple{Any, Any}"><code>HerbSearch.default_fitness</code></a></li><li><a href="../HerbSearch/#HerbSearch.enumerate_neighbours_propose-Tuple{Int64}"><code>HerbSearch.enumerate_neighbours_propose</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_best_program-Tuple{Array{RuleNode}, HerbSearch.GeneticSearchIterator}"><code>HerbSearch.get_best_program</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_bfs_enumerator"><code>HerbSearch.get_bfs_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_bfs_enumerator"><code>HerbSearch.get_bfs_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_dfs_enumerator"><code>HerbSearch.get_dfs_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_dfs_enumerator"><code>HerbSearch.get_dfs_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_genetic_enumerator-Tuple{Any}"><code>HerbSearch.get_genetic_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_mh_enumerator"><code>HerbSearch.get_mh_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_most_likely_first_enumerator"><code>HerbSearch.get_most_likely_first_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_most_likely_first_enumerator"><code>HerbSearch.get_most_likely_first_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_sa_enumerator"><code>HerbSearch.get_sa_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.get_vlsn_enumerator"><code>HerbSearch.get_vlsn_enumerator</code></a></li><li><a href="../HerbSearch/#HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_leftmost</code></a></li><li><a href="../HerbSearch/#HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_random</code></a></li><li><a href="../HerbSearch/#HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_rightmost</code></a></li><li><a href="../HerbSearch/#HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_smallest_domain</code></a></li><li><a href="../HerbSearch/#HerbSearch.mean_squared_error-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})"><code>HerbSearch.mean_squared_error</code></a></li><li><a href="../HerbSearch/#HerbSearch.misclassification-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})"><code>HerbSearch.misclassification</code></a></li><li><a href="../HerbSearch/#HerbSearch.most_likely_priority_function-Tuple{ContextSensitiveGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.most_likely_priority_function</code></a></li><li><a href="../HerbSearch/#HerbSearch.mse_error_function-Tuple{Any, Any, Any}"><code>HerbSearch.mse_error_function</code></a></li><li><a href="../HerbSearch/#HerbSearch.mutate_random!"><code>HerbSearch.mutate_random!</code></a></li><li><a href="../HerbSearch/#HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept</code></a></li><li><a href="../HerbSearch/#HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature</code></a></li><li><a href="../HerbSearch/#HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature_fraction</code></a></li><li><a href="../HerbSearch/#HerbSearch.propagate_constraints"><code>HerbSearch.propagate_constraints</code></a></li><li><a href="../HerbSearch/#HerbSearch.random_fill_propose-Tuple{RuleNode, NodeLoc, Grammar, Int64, AbstractVector{Int64}, Union{Nothing, Dict{String, Any}}}"><code>HerbSearch.random_fill_propose</code></a></li><li><a href="../HerbSearch/#HerbSearch.search-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search</code></a></li><li><a href="../HerbSearch/#HerbSearch.search_best-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search_best</code></a></li><li><a href="../HerbSearch/#HerbSearch.search_rulenode-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search_rulenode</code></a></li><li><a href="../HerbSearch/#HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_chromosome</code></a></li><li><a href="../HerbSearch/#HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_fitness_proportional_parents</code></a></li><li><a href="../HerbSearch/#HerbSearch.validate_iterator-Tuple{Any}"><code>HerbSearch.validate_iterator</code></a></li><li><a href="../HerbSearch/#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="../HerbSearch/#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="../HerbSearch/#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="../HerbSearch/#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="#HerbConstraints.@csgrammar_annotated-Tuple{Any}"><code>HerbConstraints.@csgrammar_annotated</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@cfgrammar-Tuple{Any}"><code>HerbGrammar.@cfgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@csgrammar-Tuple{Any}"><code>HerbGrammar.@csgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@pcfgrammar-Tuple{Any}"><code>HerbGrammar.@pcfgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@pcsgrammar-Tuple{Any}"><code>HerbGrammar.@pcsgrammar</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../HerbSearch/">« HerbSearch.jl</a><a class="docs-footer-nextpage" href="../HerbData/">HerbCore.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 19 January 2024 13:31">Friday 19 January 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
