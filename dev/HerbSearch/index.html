<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HerbSearch.jl · Herb.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Herb.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Herb.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../">Herb.jl</a></li><li><a class="tocitem" href="../install/">Installation Guide</a></li><li><a class="tocitem" href="../get_started/">Getting Started</a></li><li><a class="tocitem" href="../concepts/">Architecture and core concepts</a></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../HerbGrammar/">HerbGrammar.jl</a></li><li class="is-active"><a class="tocitem" href>HerbSearch.jl</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../HerbConstraints/">HerbConstraints.jl</a></li><li><a class="tocitem" href="../HerbData/">HerbCore.jl</a></li><li><a class="tocitem" href="../HerbEvaluation/">HerbEvaluation.jl</a></li><li><a class="tocitem" href="../HerbData/">HerbData.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Sub-Modules</a></li><li class="is-active"><a href>HerbSearch.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>HerbSearch.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Herb-AI/Herb.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="HerbSearch_docs"><a class="docs-heading-anchor" href="#HerbSearch_docs">HerbSearch.jl Documentation</a><a id="HerbSearch_docs-1"></a><a class="docs-heading-anchor-permalink" href="#HerbSearch_docs" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.ContextSensitivePriorityEnumerator" href="#HerbSearch.ContextSensitivePriorityEnumerator"><code>HerbSearch.ContextSensitivePriorityEnumerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ContextSensitivePriorityEnumerator &lt;: ExpressionIterator</code></pre><p>Enumerates a context-free grammar starting at <a href="HerbSearch/@ref"><code>Symbol</code></a> <code>sym</code> with respect to the grammar up to a given depth and a given size. The exploration is done using the given priority function for derivations, and the expand function for discovered nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.ExpandFailureReason" href="#HerbSearch.ExpandFailureReason"><code>HerbSearch.ExpandFailureReason</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum ExpandFailureReason limit_reached=1 already_complete=2</code></pre><p>Representation of the different reasons why expanding a partial tree failed.  Currently, there are two possible causes of the expansion failing:</p><ul><li><code>limit_reached</code>: The depth limit or the size limit of the partial tree would   be violated by the expansion</li><li><code>already_complete</code>: There is no hole left in the tree, so nothing can be   expanded.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.ExpressionIterator" href="#HerbSearch.ExpressionIterator"><code>HerbSearch.ExpressionIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ExpressionIterator</code></pre><p>Abstract super-type for all possible enumerators.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.GeneticSearchIterator" href="#HerbSearch.GeneticSearchIterator"><code>HerbSearch.GeneticSearchIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneticSearchIterator{FitnessFunction,CrossOverFunction,MutationFunction,SelectParentsFunction,EvaluationFunction} &lt;: ExpressionIterator</code></pre><p>Defines an <a href="#HerbSearch.ExpressionIterator"><code>ExpressionIterator</code></a> using genetic search. </p><p>Consists of:</p><ul><li><p><code>grammar::ContextSensitiveGrammar</code>: the grammar to search over</p></li><li><p><code>examples::Vector{&lt;:Example}</code>: a collection of examples defining the specification </p></li><li><p><code>fitness::FitnessFunction</code>: assigns a numerical value (fitness score) to each individual based on how closely it meets the desired objective</p></li><li><p><code>cross_over::CrossOverFunction</code>: combines the program from two parent individuals to create one or more offspring individuals</p></li><li><p><code>mutation!::MutationFunction</code>: mutates the program of an invididual</p></li><li><p><code>select_parents::SelectParentsFunction</code>: selects two parents for the crossover</p></li><li><p><code>evaluation_function::EvaluationFunction</code>: interpreter to evaluate the individual programs</p></li><li><p><code>start_symbol::Symbol</code>: defines the start symbol from which the search should be started</p></li><li><p><code>population_size::Int64</code>: number of inviduals in the population</p></li><li><p><code>mutation_probability::Float64</code>: probability of mutation for each individual</p></li><li><p><code>maximum_initial_population_depth::Int64</code>: maximum depth of trees when population is initialized </p></li></ul><p>end</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.PriorityQueueItem" href="#HerbSearch.PriorityQueueItem"><code>HerbSearch.PriorityQueueItem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PriorityQueueItem</code></pre><p>Represents an item in the priority enumerator priority queue. An item contains of:</p><ul><li><code>tree</code>: A partial AST</li><li><code>size</code>: The size of the tree. This is a cached value which prevents  having to traverse the entire tree each time the size is needed.</li><li><code>constraints</code>: The local constraints that apply to this tree.   These constraints are enforced each time the tree is modified.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.PriorityQueueItem-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.PriorityQueueItem-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.PriorityQueueItem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PriorityQueueItem(tree::AbstractRuleNode, size::Int)</code></pre><p>Constructs <a href="#HerbSearch.PriorityQueueItem"><code>PriorityQueueItem</code></a> given only a tree and the size, but no constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.PropagateResult" href="#HerbSearch.PropagateResult"><code>HerbSearch.PropagateResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum PropagateResult tree_complete=1 tree_incomplete=2 tree_infeasible=3</code></pre><p>Representation of the possible results of a constraint propagation.  At the moment there are three possible outcomes:</p><ul><li><code>tree_complete</code>: The propagation was applied successfully and the tree does not contain any holes anymore. Thus no constraints can be applied anymore.</li><li><code>tree_incomplete</code>: The propagation was applied successfully and the tree does contain more holes. Thus more constraints may be applied to further prune the respective domains.</li><li><code>tree_infeasible</code>: The propagation was succesful, but there are holes with empty domains. Hence, the tree is now infeasible.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.StochasticSearchEnumerator" href="#HerbSearch.StochasticSearchEnumerator"><code>HerbSearch.StochasticSearchEnumerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Base.@kwdef struct StochasticSearchEnumerator &lt;: ExpressionIterator</code></pre><p>A unified struct for the algorithms Metropolis Hastings, Very Large Scale Neighbourhood and Simulated Annealing. Each algorithm implements <code>neighbourhood</code> <code>propose</code> <code>accept</code> and <code>temperature</code> functions. Below the signiture of all this function is shown</p><p><strong>Signatures</strong></p><hr/><p>Returns a node location from the program that is the neighbourhood. It can also return other information using  <code>dict</code></p><pre><code class="nohighlight hljs">neighbourhood(program::RuleNode, grammar::Grammar) -&gt; (loc::NodeLocation, dict::Dict)</code></pre><hr/><p>Proposes a list of programs using the location provided by <code>neighbourhood</code> and the <code>dict</code>.</p><pre><code class="nohighlight hljs">propose(current_program, loc::NodeLocation, grammar::Grammar, max_depth::Int64, dict::Dict) -&gt; Iter[RuleNode]</code></pre><hr/><p>Based on the current program and possible cost and temperature it accepts the program or not. Usually we would always want to accept better programs but we might get stuck if we do so. That is why some implementations of the <code>accept</code> function accept with a probability  costs that are worse.  <code>cost</code> means how different are the outcomes of the program compared to the correct outcomes. The lower the <code>cost</code> the better the program performs on the examples. The <code>cost</code> is provided by the <code>cost_function</code></p><pre><code class="nohighlight hljs">accept(current_cost::Real, possible_cost::Real, temperature::Real) -&gt; Bool</code></pre><hr/><p>Returns the new temperature based on the previous temperature. Higher the <code>temperature</code> means that the algorithm will explore more.</p><pre><code class="nohighlight hljs">temperature(previous_temperature::Real) -&gt; Real</code></pre><hr/><p>Returns the cost of the current program. It receives a list of tuples <code>(expected, found)</code> and gives back a cost.</p><pre><code class="nohighlight hljs">cost_function(outcomes::Tuple{&lt;:Number,&lt;:Number}[]) -&gt; Real</code></pre><hr/><p><strong>Fields</strong></p><ul><li><code>grammar::ContextSensitiveGrammar</code> grammar that the algorithm uses</li><li><code>max_depth::Int64 = 5</code>  maximum depth of the program to generate</li><li><code>examples::Vector{Example}</code> example used to check the program</li><li><code>neighbourhood::Function</code> </li><li><code>propose::Function</code></li><li><code>accept::Function</code></li><li><code>temperature::Function</code></li><li><code>cost_function::Function</code></li><li><code>start_symbol::Symbol</code> the start symbol of the algorithm <code>:Real</code> or <code>:Int</code></li><li><code>initial_temperature::Real</code> = 1 </li><li><code>evaluation_function</code>::Function that evaluates the julia expressions</li></ul><p>An iterator over all possible expressions of a grammar up to max_depth with start symbol sym.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{ContextSensitivePriorityEnumerator, DataStructures.PriorityQueue}" href="#Base.iterate-Tuple{ContextSensitivePriorityEnumerator, DataStructures.PriorityQueue}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::ContextSensitivePriorityEnumerator, pq::DataStructures.PriorityQueue)</code></pre><p>Describes the iteration for a given <a href="#HerbSearch.ContextSensitivePriorityEnumerator"><code>ContextSensitivePriorityEnumerator</code></a> and a <a href="HerbSearch/@ref"><code>PriorityQueue</code></a> over the grammar without enqueueing new items to the priority queue. Recursively returns the result for the priority queue.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{ContextSensitivePriorityEnumerator}" href="#Base.iterate-Tuple{ContextSensitivePriorityEnumerator}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::ContextSensitivePriorityEnumerator)</code></pre><p>Describes the iteration for a given <a href="#HerbSearch.ContextSensitivePriorityEnumerator"><code>ContextSensitivePriorityEnumerator</code></a> over the grammar. The iteration constructs a <a href="HerbSearch/@ref"><code>PriorityQueue</code></a> first and then prunes it propagating the active constraints. Recursively returns the result for the priority queue.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{HerbSearch.GeneticSearchIterator, HerbSearch.GeneticIteratorState}" href="#Base.iterate-Tuple{HerbSearch.GeneticSearchIterator, HerbSearch.GeneticIteratorState}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::GeneticSearchIterator, current_state::GeneticIteratorState)</code></pre><p>Iterates the search space using a genetic algorithm. Takes the iterator and the current state to mutate and crossover random inviduals. Returns the best program-so-far and the state of the iterator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{HerbSearch.GeneticSearchIterator}" href="#Base.iterate-Tuple{HerbSearch.GeneticSearchIterator}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::GeneticSearchIterator)</code></pre><p>Iterates the search space using a genetic algorithm. First generates a population sampling random programs. Returns the best program-so-far, and the state of the iterator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{HerbSearch.StochasticSearchEnumerator, HerbSearch.IteratorState}" href="#Base.iterate-Tuple{HerbSearch.StochasticSearchEnumerator, HerbSearch.IteratorState}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.iterate(iter::StochasticSearchEnumerator, current_state::IteratorState)</code></pre><p>The algorithm that constructs the iterator of StochasticSearchEnumerator. It has the following structure:</p><ol><li>get a random node location -&gt; location,dict = neighbourhood(current_program)</li><li>call propose on the current program getting a list of possbile replacements in the node location </li><li>iterate through all the possible replacements and perform the replacement in the current program <ol><li>accept the new program by modifying the next_program or reject the new program</li></ol></li><li>return the new next_program</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand(::Type{RuleNode}, grammar::Grammar, typ::Symbol, max_depth::Int=10)</code></pre><p>Generates a random <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> of return type typ and maximum depth max_depth.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand(::Type{RuleNode}, grammar::Grammar, max_depth::Int=10)</code></pre><p>Generates a random <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a> of arbitrary type and maximum depth max_depth.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand(::Type{RuleNode}, grammar::Grammar, typ::Symbol, dmap::AbstractVector{Int}, max_depth::Int=10)</code></pre><p>Generates a random <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a>, i.e. an expression tree, of root type typ and maximum depth max_depth guided by a depth map dmap if possible.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}" href="#HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}"><code>HerbSearch._expand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_expand(node::Hole, grammar::ContextSensitiveGrammar, ::Int, max_holes::Int, context::GrammarContext, hole_heuristic::Function, derivation_heuristic::Function)::Union{ExpandFailureReason, Vector{TreeConstraints}}</code></pre><p>Expands a given hole that was found in <a href="#HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}"><code>_expand</code></a> using the given derivation heuristic. Returns the list of discovered nodes in that order and with their respective constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch._expand-Tuple{RuleNode, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}" href="#HerbSearch._expand-Tuple{RuleNode, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}"><code>HerbSearch._expand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_expand(root::RuleNode, grammar::ContextSensitiveGrammar, max_depth::Int, max_holes::Int, context::GrammarContext, hole_heuristic::Function, derivation_heuristic::Function)::Union{ExpandFailureReason, Vector{TreeConstraints}}</code></pre><p>Recursive expand function used in multiple enumeration techniques. Expands one hole/undefined leaf of the given RuleNode tree found using the given hole heuristic. If the expansion was successful, returns a list of new trees and a list of lists of hole locations, corresponding to the holes of each newly expanded tree.  Returns <code>nothing</code> if tree is already complete (i.e. contains no holes). Returns an empty list if the tree is partial (i.e. contains holes), but they could not be expanded because of the depth limit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch._find_next_complete_tree-Tuple{ContextSensitiveGrammar, Int64, Int64, Function, Function, DataStructures.PriorityQueue}" href="#HerbSearch._find_next_complete_tree-Tuple{ContextSensitiveGrammar, Int64, Int64, Function, Function, DataStructures.PriorityQueue}"><code>HerbSearch._find_next_complete_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_find_next_complete_tree(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, priority_function::Function, expand_function::Function, pq::PriorityQueue)::Union{Tuple{RuleNode, PriorityQueue}, Nothing}</code></pre><p>Takes a priority queue and returns the smallest AST from the grammar it can obtain from the queue or by (repeatedly) expanding trees that are in the queue. Returns <code>nothing</code> if there are no trees left within the depth limit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.best_accept-Tuple{Real, Real, Any}" href="#HerbSearch.best_accept-Tuple{Real, Real, Any}"><code>HerbSearch.best_accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">best_accept(current_cost::Real, next_cost::Real, temperature)</code></pre><p>Returns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns false.</p><p><strong>Arguments</strong></p><ul><li><code>current_cost::Real</code>: the cost of the current program.</li><li><code>next_cost::Real</code>: the cost of the proposed program.</li><li><code>temperature::Real</code>: the temperature; not used.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.calculate_cost-Tuple{RuleNode, Function, AbstractVector{Example}, Grammar, Function}" href="#HerbSearch.calculate_cost-Tuple{RuleNode, Function, AbstractVector{Example}, Grammar, Function}"><code>HerbSearch.calculate_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_cost(program::RuleNode, cost_function::Function, examples::AbstractVector{Example}, grammar::Grammar, evaluation_function::Function)</code></pre><p>Returns the cost of the <code>program</code> using the examples and the <code>cost_function</code>. It first convert the program to an expression and evaluates it on all the examples using <a href="HerbSearch/@ref"><code>HerbEvaluationevaluate_program</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.const_temperature-Tuple{Any}" href="#HerbSearch.const_temperature-Tuple{Any}"><code>HerbSearch.const_temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">const_temperature(current_temperature)</code></pre><p>Returns the temperature unchanged. This function is used by Metropolis Hastings and Very Large Neighbourhood Search algorithms.</p><p><strong>Arguments</strong></p><ul><li><code>current_temperature::Real</code>: the current temperature of the search.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.constructNeighbourhood-Tuple{RuleNode, Grammar}" href="#HerbSearch.constructNeighbourhood-Tuple{RuleNode, Grammar}"><code>HerbSearch.constructNeighbourhood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructNeighbourhood(current_program::RuleNode, grammar::Grammar)</code></pre><p>The neighbourhood node location is chosen at random. The dictionary is nothing.</p><p><strong>Arguments</strong></p><ul><li><code>current_program::RuleNode</code>: the current program.</li><li><code>grammar::Grammar</code>: the grammar.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, Grammar}" href="#HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, Grammar}"><code>HerbSearch.constructNeighbourhoodRuleSubset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constructNeighbourhoodRuleSubset(current_program::RuleNode, grammar::Grammar)</code></pre><p>The neighbourhood node location is chosen at random. The dictionary is contains one entry with key &quot;rule_subset&quot; and value of type Vector{Any} being a random subset of grammar rules.</p><p><strong>Arguments</strong></p><ul><li><code>current_program::RuleNode</code>: the current program.</li><li><code>grammar::Grammar</code>: the grammar.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.count_expressions-Tuple{ExpressionIterator}" href="#HerbSearch.count_expressions-Tuple{ExpressionIterator}"><code>HerbSearch.count_expressions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_expressions(iter::ExpressionIterator)</code></pre><p>Counts and returns the number of possible expressions in the expression iterator. The Iterator is not modified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.count_expressions-Tuple{Grammar, Int64, Int64, Symbol}" href="#HerbSearch.count_expressions-Tuple{Grammar, Int64, Int64, Symbol}"><code>HerbSearch.count_expressions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_expressions(grammar::Grammar, max_depth::Int, max_size::Int, sym::Symbol)</code></pre><p>Counts and returns the number of possible expressions of a grammar up to max_depth with start symbol sym.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}" href="#HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crossover_swap_children_1(parent1::RuleNode, parent2::RuleNode)</code></pre><p>Performs a random crossover of two parents of type <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a>. The subprograms are swapped and only one altered parent program is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}" href="#HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crossover_swap_children_2(parent1::RuleNode, parent2::RuleNode)</code></pre><p>Performs a random crossover of two parents of type <a href="../HerbCore/#HerbCore.RuleNode"><code>RuleNode</code></a>. The subprograms are swapped and both altered parent programs are returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.decreasing_temperature-Tuple{Real}" href="#HerbSearch.decreasing_temperature-Tuple{Real}"><code>HerbSearch.decreasing_temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decreasing_temperature(percentage::Real)</code></pre><p>Returns a function that produces a temperature decreased by <code>percentage</code>%. This function is used by the Simmulated Annealing algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>percentage::Real</code>: the percentage to decrease the temperature by.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.default_error_function-Tuple{Any, Any, Any}" href="#HerbSearch.default_error_function-Tuple{Any, Any, Any}"><code>HerbSearch.default_error_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_error_function(old_error, output, expected_output)</code></pre><p>Default error function for <code>search_best</code>.</p><pre><code class="nohighlight hljs">- old_error         - The existing total error
- output            - The actual output of the evaluator
- expected_output   - The expected output for the example</code></pre><p>The default function returns <code>0</code> if the outputs match and <code>1</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.default_fitness-Tuple{Any, Any}" href="#HerbSearch.default_fitness-Tuple{Any, Any}"><code>HerbSearch.default_fitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_fitness(program, results)</code></pre><p>Defines the default fitness function taking the program and its results. Results are a vector of tuples, where each tuple is in the form <code>Tuple{expected_output, actual_output}</code>. As we are looking for individuals with the highest fitness function, the error is inverted. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.enumerate_neighbours_propose-Tuple{Int64}" href="#HerbSearch.enumerate_neighbours_propose-Tuple{Int64}"><code>HerbSearch.enumerate_neighbours_propose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enumerate_neighbours_propose(enumeration_depth::Int64)</code></pre><p>The return function is a function that produces a list with all the subprograms with depth at most <code>enumeration_depth</code>.</p><p><strong>Arguments</strong></p><ul><li><code>enumeration_depth::Int64</code>: the maximum enumeration depth.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_best_program-Tuple{Array{RuleNode}, HerbSearch.GeneticSearchIterator}" href="#HerbSearch.get_best_program-Tuple{Array{RuleNode}, HerbSearch.GeneticSearchIterator}"><code>HerbSearch.get_best_program</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_best_program(population::Array{RuleNode}, iter:: GeneticSearchIterator)::RuleNode</code></pre><p>Returns the best program within the population with respect to the fitness function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_bfs_enumerator" href="#HerbSearch.get_bfs_enumerator"><code>HerbSearch.get_bfs_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_bfs_enumerator(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -&gt; a)::ContextSensitivePriorityEnumerator</code></pre><p>Returns a breadth-first search enumerator given a ContextSensitiveGrammar. Returns trees in the grammar in increasing order of size. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_bfs_enumerator" href="#HerbSearch.get_bfs_enumerator"><code>HerbSearch.get_bfs_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_bfs_enumerator(grammar::ContextFreeGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -&gt; a)::ContextSensitivePriorityEnumerator</code></pre><p>Returns a breadth-first search enumerator given a ContextFreeGrammar. Returns trees in the grammar in increasing order of size. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_dfs_enumerator" href="#HerbSearch.get_dfs_enumerator"><code>HerbSearch.get_dfs_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_dfs_enumerator(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -&gt; a)::ContextSensitivePriorityEnumerator</code></pre><p>Returns a depth-first search enumerator given a ContextSensitiveGrammar. Returns trees in the grammar in decreasing order of size.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_dfs_enumerator" href="#HerbSearch.get_dfs_enumerator"><code>HerbSearch.get_dfs_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_dfs_enumerator(grammar::ContextFreeGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -&gt; a)::ContextSensitivePriorityEnumerator</code></pre><p>Returns a depth-first search enumerator given a ContextFreeGrammar. Returns trees in the grammar in decreasing order of size.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_genetic_enumerator-Tuple{Any}" href="#HerbSearch.get_genetic_enumerator-Tuple{Any}"><code>HerbSearch.get_genetic_enumerator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_genetic_enumerator(examples; fitness_function = HerbSearch.default_fitness, initial_population_size = 10, maximum_initial_population_depth = 3, mutation_probability = 0.1, cross_over = HerbSearch.crossover_swap_children_2, select_parents = HerbSearch.select_fitness_proportional_parents, evaluation_function::Function=HerbEvaluation.test_with_input)</code></pre><p>Returns a <a href="#HerbSearch.GeneticSearchIterator"><code>GeneticSearchIterator</code></a> given a grammar. The iterator is fitted against the examples provided evaluated using the fitness function. All other arguments are hyperparameters for the genetic search procedure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_mh_enumerator" href="#HerbSearch.get_mh_enumerator"><code>HerbSearch.get_mh_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_mh_enumerator(examples::AbstractArray{&lt;:Example}, cost_function::Function, evaluation_function::Function=HerbEvaluation.test_with_input)</code></pre><p>Returns an enumerator that runs according to the Metropolis Hastings algorithm.</p><ul><li><code>examples</code> : array of examples</li><li><code>cost_function</code> : cost function to evaluate the programs proposed</li><li><code>evaluation_function</code> : evaluation function that evaluates the program generated and produces an output </li></ul><p>The propose function is random<em>fill</em>propose and the accept function is probabilistic. The temperature value of the algorithm remains constant over time. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_most_likely_first_enumerator" href="#HerbSearch.get_most_likely_first_enumerator"><code>HerbSearch.get_most_likely_first_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_most_likely_first_enumerator(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -&gt; a)::ContextSensitivePriorityEnumerator</code></pre><p>Returns an enumerator that enumerates expressions in the grammar in decreasing order of probability. Only use this function with probabilistic grammars.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_most_likely_first_enumerator" href="#HerbSearch.get_most_likely_first_enumerator"><code>HerbSearch.get_most_likely_first_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_most_likely_first_enumerator(grammar::ContextFreeGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -&gt; a)::ContextSensitivePriorityEnumerator</code></pre><p>Returns an enumerator that enumerates expressions in the grammar in decreasing order of probability. Only use this function with probabilistic grammars.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_sa_enumerator" href="#HerbSearch.get_sa_enumerator"><code>HerbSearch.get_sa_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_sa_enumerator(examples, cost_function, initial_temperature=1, temperature_decreasing_factor = 0.99, evaluation_function::Function=HerbEvaluation.test_with_input)</code></pre><p>Returns an enumerator that runs according to the Very Large Scale Neighbourhood Search algorithm.</p><ul><li><code>examples</code> : array of examples</li><li><code>cost_function</code> : cost function to evaluate the programs proposed</li><li><code>initial_temperature</code> : the starting temperature of the algorithm</li><li><code>temperature_decreasing_factor</code> : the decreasing factor of the temperature of the time</li><li><code>evaluation_function</code> : evaluation function that evaluates the program generated and produces an output </li></ul><p>The propose function is <code>random_fill_propose</code> (the same as for Metropolis Hastings). The accept function is probabilistic but takes into account the tempeerature too.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.get_vlsn_enumerator" href="#HerbSearch.get_vlsn_enumerator"><code>HerbSearch.get_vlsn_enumerator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_vlsn_enumerator(examples, cost_function, enumeration_depth = 2, evaluation_function::Function=HerbEvaluation.test_with_input)</code></pre><p>Returns an enumerator that runs according to the Very Large Scale Neighbourhood Search algorithm.</p><ul><li><code>examples</code> : array of examples</li><li><code>cost_function</code> : cost function to evaluate the programs proposed</li><li><code>enumeration_depth</code> : the enumeration depth to search for a best program at a time</li><li><code>evaluation_function</code> : evaluation function that evaluates the program generated and produces an output </li></ul><p>The propose function consists of all possible programs of the given <code>enumeration_depth</code>. The accept function accepts the program with the lowest cost according to the <code>cost_function</code>. The temperature value of the algorithm remains constant over time. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_leftmost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heuristic_leftmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over holes, where the left-most hole always gets considered first. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found. This is the default option for enumerators.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_random</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heuristic_random(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over holes, where random holes get chosen randomly using random exploration. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_rightmost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heuristic_rightmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over holes, where the right-most hole always gets considered first. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}" href="#HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_smallest_domain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heuristic_smallest_domain(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}</code></pre><p>Defines a heuristic over all available holes in the unfinished AST, by considering the size of their respective domains. A domain here describes the number of possible derivations with respect to the constraints. Returns a <a href="../HerbCore/#HerbCore.HoleReference"><code>HoleReference</code></a> once a hole is found. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.mean_squared_error-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})" href="#HerbSearch.mean_squared_error-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})"><code>HerbSearch.mean_squared_error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean_squared_error(results::AbstractVector{Tuple{&lt;:Number,&lt;:Number}})</code></pre><p>Returns the mean squared error of <code>results</code>.</p><p><strong>Arguments</strong></p><ul><li><code>results&lt;:AbstractVector{&lt;:Tuple{Number,Number}}</code>: the vector of tuples, where each tuple is in the form <code>Tuple{expected_output, actual_output}</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.misclassification-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})" href="#HerbSearch.misclassification-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})"><code>HerbSearch.misclassification</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">misclassification(results::AbstractVector{Tuple{&lt;:Number,&lt;:Number}})</code></pre><p>Returns the amount of misclassified examples, i.e. how many tuples with non-matching entries are there in <code>results</code>.</p><p><strong>Arguments</strong></p><ul><li><code>results&lt;:AbstractVector{&lt;:Tuple{Number,Number}}</code>: the vector of tuples, where each tuple is in the form <code>Tuple{expected_output, actual_output}</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.most_likely_priority_function-Tuple{ContextSensitiveGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}" href="#HerbSearch.most_likely_priority_function-Tuple{ContextSensitiveGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.most_likely_priority_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">most_likely_priority_function(g::ContextSensitiveGrammar, tree::AbstractRuleNode, ::Union{Real, Tuple{Vararg{Real}}})</code></pre><p>Calculates logit for all possible derivations for a node in a tree and returns them.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.mse_error_function-Tuple{Any, Any, Any}" href="#HerbSearch.mse_error_function-Tuple{Any, Any, Any}"><code>HerbSearch.mse_error_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mse_error_function(old_error, output, expected_output)</code></pre><p>Mean squared error function for <code>search_best</code>.</p><pre><code class="nohighlight hljs">- old_error         - The existing total error
- output            - The actual output of the evaluator
- expected_output   - The expected output for the example</code></pre><p>The function build the mean squared error from <code>output</code> and <code>expected_output</code>`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.mutate_random!" href="#HerbSearch.mutate_random!"><code>HerbSearch.mutate_random!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mutate_random!(program::RuleNode, grammar::Grammar, max_depth::Int64 = 2)</code></pre><p>Mutates the given program by inserting a randomly generated sub-program at a random location.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}" href="#HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probabilistic_accept(current_cost::Real, next_cost::Real, temperature::Real)</code></pre><p>Probabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program. Returns <code>True</code> if the new program is accepted, <code>False</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>current_cost::Real</code>: the cost of the current program.</li><li><code>next_cost::Real</code>: the cost of the proposed program.</li><li><code>temperature::Real</code>: the temperature; not used.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}" href="#HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probabilistic_accept_with_temperature(current_cost::Real, next_cost::Real, temperature::Real)</code></pre><p>Returns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns true with the probability equal to: </p><p class="math-container">\[1 / (1 + exp(delta / temperature))\]</p><p>In any other case, returns false.</p><p><strong>Arguments</strong></p><ul><li><code>current_cost::Real</code>: the cost of the current program.</li><li><code>next_cost::Real</code>: the cost of the proposed program.</li><li><code>temperature::Real</code>: the temperature of the search.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}" href="#HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature_fraction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">probabilistic_accept_with_temperature_fraction(current_cost::Real, program_to_consider_cost::Real, temperature::Real)</code></pre><p>Probabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program multiplied by the temperature. Returns <code>True</code> if the new program is accepted, <code>False</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>current_cost::Real</code>: the cost of the current program.</li><li><code>next_cost::Real</code>: the cost of the proposed program.</li><li><code>temperature::Real</code>: the current temperature </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.propagate_constraints" href="#HerbSearch.propagate_constraints"><code>HerbSearch.propagate_constraints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function propagate_constraints(root::AbstractRuleNode, grammar::ContextSensitiveGrammar, local_constraints::Set{LocalConstraint}, max_holes::Int, filled_hole::Union{HoleReference, Nothing}=nothing)::Tuple{PropagateResult, Set{LocalConstraint}}</code></pre><p>Propagates a set of local constraints recursively to all children of a given root node. As <code>propagate_constraints</code> gets often called when a hole was just filled, <code>filled_hole</code> helps keeping track to propagate the constraints to relevant nodes, e.g. children of <code>filled_hole</code>. <code>max_holes</code> makes sure that <code>max_size</code> of <a href="#Base.iterate-Tuple{ContextSensitivePriorityEnumerator, DataStructures.PriorityQueue}"><code>Base.iterate</code></a> is not violated.  The function returns the <a href="#HerbSearch.PropagateResult"><code>PropagateResult</code></a> and the set of relevant <a href="../HerbConstraints/#HerbConstraints.LocalConstraint"><code>LocalConstraint</code></a>s.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.random_fill_propose-Tuple{RuleNode, NodeLoc, Grammar, Int64, AbstractVector{Int64}, Union{Nothing, Dict{String, Any}}}" href="#HerbSearch.random_fill_propose-Tuple{RuleNode, NodeLoc, Grammar, Int64, AbstractVector{Int64}, Union{Nothing, Dict{String, Any}}}"><code>HerbSearch.random_fill_propose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_fill_propose(current_program, neighbourhood_node_loc, grammar, max_depth, dict)</code></pre><p>Returns a list with only one proposed, completely random, subprogram.</p><p><strong>Arguments</strong></p><ul><li><code>current_program::RuleNode</code>: the current program.</li><li><code>neighbourhood_node_loc::NodeLoc</code>: the location of the program to replace.</li><li><code>grammar::Grammar</code>: the grammar used to create programs.</li><li><code>max_depth::Int</code>: the maximum depth of the resulting programs.</li><li><code>dmap::AbstractVector{Int} : the minimum possible depth to reach for each rule</code></li><li><code>dict::Dict{String, Any}</code>: the dictionary with additional arguments; not used.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.search-Tuple{Grammar, Problem, Symbol}" href="#HerbSearch.search-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">search(g::Grammar, problem::Problem, start::Symbol; evaluator::Function=test_with_input, enumerator::Function=get_bfs_enumerator, max_depth::Union{Int, Nothing}=nothing, max_size::Union{Int, Nothing}=nothing, max_time::Union{Int, Nothing}=nothing, max_enumerations::Union{Int, Nothing}=nothing, allow_evaluation_errors::Bool=false)::Union{Any, Nothing}</code></pre><p>Searches for a program by calling <a href="#HerbSearch.search_rulenode-Tuple{Grammar, Problem, Symbol}"><code>search_rulenode</code></a> starting from <a href="HerbSearch/@ref"><code>Symbol</code></a> <code>start</code> guided by <code>enumerator</code> and <a href="../HerbCore/#HerbCore.Grammar"><code>Grammar</code></a> trying to satisfy  the higher-order constraints in form of input/output examples defined in the <a href="../HerbData/#HerbData.Problem"><code>Problem</code></a>.  This is the heart of the Herb&#39;s search for satisfying programs. Returns the found program when the evaluation calculated using <code>evaluator</code> is successful.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.search_best-Tuple{Grammar, Problem, Symbol}" href="#HerbSearch.search_best-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search_best</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">search_best(g::Grammar, problem::Problem, start::Symbol; evaluator::Function=test_with_input, enumerator::Function=get_bfs_enumerator, error_function::Function=default_error_function, max_depth::Union{Int, Nothing}=nothing, max_size::Union{Int, Nothing}=nothing, max_time::Union{Int, Nothing}=nothing, max_enumerations::Union{Int, Nothing}=nothing, allow_evaluation_errors::Bool=false)::Tuple{Any, Real}</code></pre><p>Searches the grammar for the program that satisfies the maximum number of examples in the problem. The evaluator should be a function that takes a SymbolTable, expression and a dictionary with      input variable assignments and returns the output of the expression.</p><pre><code class="nohighlight hljs">- g                 - The grammar that defines the search space
- problem           - The problem definition with IO examples
- start             - The start symbol in the grammar
- evaluator         - The evaluation function. Takes a SymbolTable, expression and a dictionary with 
                      input variable assignments and returns the output of the expression.
- enumerator        - A constructor for the enumerator that should be used in the search
- error_function    - The error function. Takes the existing total error, the actual output of the evaluator 
                      and the expected value for the example.
- max_depth         - The maximum depth of the search
- max_time          - The maximum time allowed for the search in seconds
- max_enumerations  - The maximum number of programs to enumerate and test
- allow_evaluation_errors - Whether the search should crash if an exception is thrown in the evaluation</code></pre><p>Returns a tuple with the best found program so far and the error.  Can be considerably slower than <code>search</code> due to having to evaluate each expression on each example.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.search_rulenode-Tuple{Grammar, Problem, Symbol}" href="#HerbSearch.search_rulenode-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search_rulenode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">search_rulenode(g::Grammar, problem::Problem, start::Symbol; evaluator::Function=test_with_input, enumerator::Function=get_bfs_enumerator, max_depth::Union{Int, Nothing}=nothing, max_size::Union{Int, Nothing}=nothing, max_time::Union{Int, Nothing}=nothing, max_enumerations::Union{Int, Nothing}=nothing, allow_evaluation_errors::Bool=false)::Union{Tuple{RuleNode, Any}, Nothing}</code></pre><p>Searches the grammar for the program that satisfies the maximum number of examples in the problem.</p><pre><code class="nohighlight hljs">    - g                 - The grammar that defines the search space
    - problem           - The problem definition with IO examples
    - start             - The start symbol in the grammar
    - evaluator         - The evaluation function. Takes a SymbolTable, expression and a dictionary with 
                          input variable assignments and returns the output of the expression.
    - enumerator        - A constructor for the enumerator that should be used in the search
    - max_depth         - The maximum depth of the search
    - max_size          - The maximum number of nodes for ASTs in the search
    - max_time          - The maximum time allowed for the search in seconds
    - max_enumerations  - The maximum number of programs to enumerate and test&#39;
    - allow_evaluation_errors - Whether the search should crash if an exception is thrown in the evaluation
Returns a tuple of the rulenode and the expression of the solution program once it has been found, 
or nothing otherwise.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{&lt;:Real}}" href="#HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_chromosome</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_chromosome(population::Array{RuleNode}, fitness_array::Array{&lt;:Real})::RuleNode</code></pre><p>Selects a chromosome (individual) from the population based on a fitness array. The function uses a fitness-proportionate selection strategy, often referred to as &quot;roulette wheel&quot; selection. Assumes <code>fitness_array</code> to be normalized already.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{&lt;:Real}}" href="#HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_fitness_proportional_parents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_fitness_proportional_parents(population::Array{RuleNode}, fitness_array::Array{&lt;:Real})::Tuple{RuleNode,RuleNode}</code></pre><p>Selects two parent chromosomes (individuals) from a population based on fitness-proportionate selection. The selected parents can be used for genetic crossover in the next steps of the algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HerbSearch.validate_iterator-Tuple{Any}" href="#HerbSearch.validate_iterator-Tuple{Any}"><code>HerbSearch.validate_iterator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_iterator(iter)</code></pre><p>Validates the parameters of the iterator</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(root::RuleNode, typ::Symbol, grammar::Grammar, maxdepth::Int=typemax(Int))</code></pre><p>Uniformly samples a random node from the tree limited to maxdepth.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(root::RuleNode, typ::Symbol, grammar::Grammar,
                      maxdepth::Int=typemax(Int))</code></pre><p>Uniformly selects a random node of the given return type typ limited by maxdepth.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(::Type{NodeLoc}, root::RuleNode, maxdepth::Int=typemax(Int))</code></pre><p>Uniformly selects a random node in the tree no deeper than maxdepth using reservoir sampling. Returns a <a href="../HerbGrammar/#HerbGrammar.NodeLoc"><code>NodeLoc</code></a> that specifies the location using its parent so that the subtree can be replaced.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.sample" href="#StatsBase.sample"><code>StatsBase.sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample(::Type{NodeLoc}, root::RuleNode, typ::Symbol, grammar::Grammar)</code></pre><p>Uniformly selects a random node in the tree of a given type, specified using its parent such that the subtree can be replaced. Returns a <a href="../HerbGrammar/#HerbGrammar.NodeLoc"><code>NodeLoc</code></a>.</p></div></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="../HerbConstraints/#HerbConstraints.AbstractMatchNode"><code>HerbConstraints.AbstractMatchNode</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.ComesAfter-Tuple{Int64, Int64}"><code>HerbConstraints.ComesAfter</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.ComesAfter"><code>HerbConstraints.ComesAfter</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.Forbidden"><code>HerbConstraints.Forbidden</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.ForbiddenPath"><code>HerbConstraints.ForbiddenPath</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.GrammarContext"><code>HerbConstraints.GrammarContext</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalConstraint"><code>HerbConstraints.LocalConstraint</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalForbidden"><code>HerbConstraints.LocalForbidden</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalOneOf"><code>HerbConstraints.LocalOneOf</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.LocalOrdered"><code>HerbConstraints.LocalOrdered</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.MatchFail"><code>HerbConstraints.MatchFail</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.MatchNode"><code>HerbConstraints.MatchNode</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.MatchVar"><code>HerbConstraints.MatchVar</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.OneOf"><code>HerbConstraints.OneOf</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.Ordered"><code>HerbConstraints.Ordered</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.PropagatorConstraint"><code>HerbConstraints.PropagatorConstraint</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.RequireOnLeft"><code>HerbConstraints.RequireOnLeft</code></a></li><li><a href="../HerbCore/#HerbCore.AbstractRuleNode"><code>HerbCore.AbstractRuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.Constraint"><code>HerbCore.Constraint</code></a></li><li><a href="../HerbCore/#HerbCore.Grammar"><code>HerbCore.Grammar</code></a></li><li><a href="../HerbCore/#HerbCore.Hole"><code>HerbCore.Hole</code></a></li><li><a href="../HerbCore/#HerbCore.HoleReference"><code>HerbCore.HoleReference</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode-Tuple{Int64, Vector{AbstractRuleNode}}"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode-Tuple{Int64, Any}"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbCore/#HerbCore.RuleNode"><code>HerbCore.RuleNode</code></a></li><li><a href="../HerbData/#HerbData.IOExample"><code>HerbData.IOExample</code></a></li><li><a href="../HerbData/#HerbData.IOPExample"><code>HerbData.IOPExample</code></a></li><li><a href="../HerbData/#HerbData.Problem"><code>HerbData.Problem</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.ContextFreeGrammar"><code>HerbGrammar.ContextFreeGrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.ContextSensitiveGrammar"><code>HerbGrammar.ContextSensitiveGrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.NodeLoc"><code>HerbGrammar.NodeLoc</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.SymbolTable"><code>HerbGrammar.SymbolTable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.SymbolTable"><code>HerbGrammar.SymbolTable</code></a></li><li><a href="#HerbSearch.ContextSensitivePriorityEnumerator"><code>HerbSearch.ContextSensitivePriorityEnumerator</code></a></li><li><a href="#HerbSearch.ExpandFailureReason"><code>HerbSearch.ExpandFailureReason</code></a></li><li><a href="#HerbSearch.ExpressionIterator"><code>HerbSearch.ExpressionIterator</code></a></li><li><a href="#HerbSearch.GeneticSearchIterator"><code>HerbSearch.GeneticSearchIterator</code></a></li><li><a href="#HerbSearch.PriorityQueueItem-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.PriorityQueueItem</code></a></li><li><a href="#HerbSearch.PriorityQueueItem"><code>HerbSearch.PriorityQueueItem</code></a></li><li><a href="#HerbSearch.PropagateResult"><code>HerbSearch.PropagateResult</code></a></li><li><a href="#HerbSearch.StochasticSearchEnumerator"><code>HerbSearch.StochasticSearchEnumerator</code></a></li><li><a href="../HerbGrammar/#Base.get-Tuple{RuleNode, NodeLoc}"><code>Base.get</code></a></li><li><a href="../HerbGrammar/#Base.insert!-Tuple{RuleNode, NodeLoc, RuleNode}"><code>Base.insert!</code></a></li><li><a href="../HerbCore/#Base.isless-Tuple{AbstractRuleNode, AbstractRuleNode}"><code>Base.isless</code></a></li><li><a href="#Base.iterate-Tuple{HerbSearch.StochasticSearchEnumerator, HerbSearch.IteratorState}"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Tuple{HerbSearch.GeneticSearchIterator, HerbSearch.GeneticIteratorState}"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Tuple{ContextSensitivePriorityEnumerator}"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Tuple{HerbSearch.GeneticSearchIterator}"><code>Base.iterate</code></a></li><li><a href="#Base.iterate-Tuple{ContextSensitivePriorityEnumerator, DataStructures.PriorityQueue}"><code>Base.iterate</code></a></li><li><a href="../HerbCore/#Base.length-Tuple{Hole}"><code>Base.length</code></a></li><li><a href="../HerbCore/#Base.length-Tuple{RuleNode}"><code>Base.length</code></a></li><li><a href="#Base.rand"><code>Base.rand</code></a></li><li><a href="#Base.rand"><code>Base.rand</code></a></li><li><a href="#Base.rand"><code>Base.rand</code></a></li><li><a href="../HerbConstraints/#Base.show-Tuple{IO, MatchNode}"><code>Base.show</code></a></li><li><a href="../HerbConstraints/#Base.show-Tuple{IO, MatchVar}"><code>Base.show</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._matchnode2expr"><code>HerbConstraints._matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match-Tuple{RuleNode, MatchNode, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match-Tuple{RuleNode, MatchVar, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}"><code>HerbConstraints._pattern_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._rulenode_compare-Tuple{RuleNode, RuleNode}"><code>HerbConstraints._rulenode_compare</code></a></li><li><a href="../HerbConstraints/#HerbConstraints._rulenode_match_with_hole-Tuple{RuleNode, RuleNode, Vector{Int64}}"><code>HerbConstraints._rulenode_match_with_hole</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.addparent!-Tuple{GrammarContext, Int64}"><code>HerbConstraints.addparent!</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.annotation2constraint-Tuple{Any, Int64, Vector{String}}"><code>HerbConstraints.annotation2constraint</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{Forbidden, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{Ordered, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{HerbConstraints.Condition, Grammar, RuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{ComesAfter, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{ForbiddenPath, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{RequireOnLeft, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.check_tree-Tuple{OneOf, Grammar, AbstractRuleNode}"><code>HerbConstraints.check_tree</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.copy_and_insert-Tuple{GrammarContext, Int64}"><code>HerbConstraints.copy_and_insert</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.make_smaller_or_equal-Tuple{RuleNode, RuleNode, Vector{Int64}, Vector{Int64}}"><code>HerbConstraints.make_smaller_or_equal</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}"><code>HerbConstraints.matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.matchnode2expr-Tuple{MatchVar, Grammar}"><code>HerbConstraints.matchnode2expr</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{ForbiddenPath, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{LocalOrdered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{RequireOnLeft, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{LocalForbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{HerbConstraints.LocalOneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{OneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.propagate-Tuple{Ordered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}"><code>HerbConstraints.propagate</code></a></li><li><a href="../HerbCore/#HerbCore.contains_hole-Tuple{RuleNode}"><code>HerbCore.contains_hole</code></a></li><li><a href="../HerbCore/#HerbCore.depth-Tuple{RuleNode}"><code>HerbCore.depth</code></a></li><li><a href="../HerbCore/#HerbCore.get_node_at_location-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.get_node_at_location</code></a></li><li><a href="../HerbCore/#HerbCore.get_rulesequence-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.get_rulesequence</code></a></li><li><a href="../HerbCore/#HerbCore.node_depth-Tuple{AbstractRuleNode, AbstractRuleNode}"><code>HerbCore.node_depth</code></a></li><li><a href="../HerbCore/#HerbCore.rulesoftype-Tuple{RuleNode, Set{Int64}}"><code>HerbCore.rulesoftype</code></a></li><li><a href="../HerbCore/#HerbCore.rulesonleft-Tuple{RuleNode, Vector{Int64}}"><code>HerbCore.rulesonleft</code></a></li><li><a href="../HerbCore/#HerbCore.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}"><code>HerbCore.swap_node</code></a></li><li><a href="../HerbCore/#HerbCore.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}"><code>HerbCore.swap_node</code></a></li><li><a href="../HerbData/#HerbData.read_IOPexamples-Tuple{AbstractString}"><code>HerbData.read_IOPexamples</code></a></li><li><a href="../HerbData/#HerbData.read_IOexamples-Tuple{AbstractString}"><code>HerbData.read_IOexamples</code></a></li><li><a href="../HerbData/#HerbData.readdata-Tuple{AbstractString, Function}"><code>HerbData.readdata</code></a></li><li><a href="../HerbData/#HerbData.readfile-Tuple{AbstractString, Function}"><code>HerbData.readfile</code></a></li><li><a href="../HerbData/#HerbData.write_IOPexamples-Tuple{AbstractString, Vector{IOPExample}}"><code>HerbData.write_IOPexamples</code></a></li><li><a href="../HerbData/#HerbData.write_IOexamples-Tuple{AbstractString, Vector{IOExample}}"><code>HerbData.write_IOexamples</code></a></li><li><a href="../HerbEvaluation/#HerbEvaluation.evaluate_program-Tuple{RuleNode, Vector{&lt;:Example}, Grammar, Function}"><code>HerbEvaluation.evaluate_program</code></a></li><li><a href="../HerbEvaluation/#HerbEvaluation.execute_on_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Dict{Symbol, Any}}}"><code>HerbEvaluation.execute_on_examples</code></a></li><li><a href="../HerbEvaluation/#HerbEvaluation.interpret-Tuple{Dict{Symbol, Any}, Any}"><code>HerbEvaluation.interpret</code></a></li><li><a href="../HerbEvaluation/#HerbEvaluation.test_all_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Example}}"><code>HerbEvaluation.test_all_examples</code></a></li><li><a href="../HerbEvaluation/#HerbEvaluation.test_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Example}}"><code>HerbEvaluation.test_examples</code></a></li><li><a href="../HerbEvaluation/#HerbEvaluation.test_with_input-Tuple{Dict{Symbol, Any}, Any, Dict}"><code>HerbEvaluation.test_with_input</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.add_rule!-Tuple{Grammar, Expr}"><code>HerbGrammar.add_rule!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.addconstraint!-Tuple{ContextSensitiveGrammar, Constraint}"><code>HerbGrammar.addconstraint!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.cfg2csg-Tuple{ContextFreeGrammar}"><code>HerbGrammar.cfg2csg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.child_types-Tuple{Grammar, Int64}"><code>HerbGrammar.child_types</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.child_types-Tuple{Grammar, RuleNode}"><code>HerbGrammar.child_types</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.cleanup_removed_rules!-Tuple{Grammar}"><code>HerbGrammar.cleanup_removed_rules!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.clearconstraints!-Tuple{ContextSensitiveGrammar}"><code>HerbGrammar.clearconstraints!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.containedin-Tuple{Vector, Vector}"><code>HerbGrammar.containedin</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.contains_returntype"><code>HerbGrammar.contains_returntype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2cfgrammar-Tuple{Expr}"><code>HerbGrammar.expr2cfgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2csgrammar-Tuple{Expr}"><code>HerbGrammar.expr2csgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2pcfgrammar-Tuple{Expr}"><code>HerbGrammar.expr2pcfgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.expr2pcsgrammar-Tuple{Expr}"><code>HerbGrammar.expr2pcsgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_childtypes-Tuple{Any, AbstractVector{Symbol}}"><code>HerbGrammar.get_childtypes</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_domain-Tuple{Grammar, Symbol}"><code>HerbGrammar.get_domain</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_domain-Tuple{Grammar, Vector{Int64}}"><code>HerbGrammar.get_domain</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_node_at_location-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.get_node_at_location</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.get_rulesequence-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.get_rulesequence</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.has_children-Tuple{RuleNode}"><code>HerbGrammar.has_children</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iscomplete-Tuple{Grammar, RuleNode}"><code>HerbGrammar.iscomplete</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{Any}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{Grammar}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.iseval-Tuple{Grammar, Int64}"><code>HerbGrammar.iseval</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isprobabilistic-Tuple{Grammar}"><code>HerbGrammar.isprobabilistic</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{Grammar, Int64}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{Grammar, RuleNode}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isterminal-Tuple{Any, AbstractVector{Symbol}}"><code>HerbGrammar.isterminal</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.isvariable-Tuple{Grammar, RuleNode}"><code>HerbGrammar.isvariable</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.log_probability-Tuple{Grammar, Int64}"><code>HerbGrammar.log_probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.max_arity-Tuple{Grammar}"><code>HerbGrammar.max_arity</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.mindepth-Tuple{Grammar, Symbol, AbstractVector{Int64}}"><code>HerbGrammar.mindepth</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.mindepth_map-Tuple{Grammar}"><code>HerbGrammar.mindepth_map</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nchildren-Tuple{Grammar, RuleNode}"><code>HerbGrammar.nchildren</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nchildren-Tuple{Grammar, Int64}"><code>HerbGrammar.nchildren</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.nonterminals-Tuple{Grammar}"><code>HerbGrammar.nonterminals</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.probability-Tuple{Grammar, Int64}"><code>HerbGrammar.probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_cfg-Tuple{AbstractString}"><code>HerbGrammar.read_cfg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_csg-Tuple{AbstractString, AbstractString}"><code>HerbGrammar.read_csg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_pcfg-Tuple{AbstractString}"><code>HerbGrammar.read_pcfg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.read_pcsg-Tuple{AbstractString, AbstractString}"><code>HerbGrammar.read_pcsg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.remove_rule!-Tuple{Grammar, Int64}"><code>HerbGrammar.remove_rule!</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.return_type-Tuple{Grammar, RuleNode}"><code>HerbGrammar.return_type</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.return_type-Tuple{Grammar, Int64}"><code>HerbGrammar.return_type</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.root_node_loc-Tuple{RuleNode}"><code>HerbGrammar.root_node_loc</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulenode2expr-Tuple{RuleNode, Grammar}"><code>HerbGrammar.rulenode2expr</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulenode_log_probability-Tuple{RuleNode, Grammar}"><code>HerbGrammar.rulenode_log_probability</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Grammar, Symbol}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Grammar, Symbol, RuleNode}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Set{Int64}, RuleNode}"><code>HerbGrammar.rulesoftype</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.rulesonleft-Tuple{RuleNode, Vector{Int64}}"><code>HerbGrammar.rulesonleft</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.store_cfg-Tuple{AbstractString, ContextFreeGrammar}"><code>HerbGrammar.store_cfg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.store_csg-Tuple{AbstractString, AbstractString, ContextSensitiveGrammar}"><code>HerbGrammar.store_csg</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.subsequenceof-Tuple{Vector{Int64}, Vector{Int64}}"><code>HerbGrammar.subsequenceof</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}"><code>HerbGrammar.swap_node</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}"><code>HerbGrammar.swap_node</code></a></li><li><a href="#HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}"><code>HerbSearch._expand</code></a></li><li><a href="#HerbSearch._expand-Tuple{RuleNode, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}"><code>HerbSearch._expand</code></a></li><li><a href="#HerbSearch._find_next_complete_tree-Tuple{ContextSensitiveGrammar, Int64, Int64, Function, Function, DataStructures.PriorityQueue}"><code>HerbSearch._find_next_complete_tree</code></a></li><li><a href="#HerbSearch.best_accept-Tuple{Real, Real, Any}"><code>HerbSearch.best_accept</code></a></li><li><a href="#HerbSearch.calculate_cost-Tuple{RuleNode, Function, AbstractVector{Example}, Grammar, Function}"><code>HerbSearch.calculate_cost</code></a></li><li><a href="#HerbSearch.const_temperature-Tuple{Any}"><code>HerbSearch.const_temperature</code></a></li><li><a href="#HerbSearch.constructNeighbourhood-Tuple{RuleNode, Grammar}"><code>HerbSearch.constructNeighbourhood</code></a></li><li><a href="#HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, Grammar}"><code>HerbSearch.constructNeighbourhoodRuleSubset</code></a></li><li><a href="#HerbSearch.count_expressions-Tuple{Grammar, Int64, Int64, Symbol}"><code>HerbSearch.count_expressions</code></a></li><li><a href="#HerbSearch.count_expressions-Tuple{ExpressionIterator}"><code>HerbSearch.count_expressions</code></a></li><li><a href="#HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_1</code></a></li><li><a href="#HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}"><code>HerbSearch.crossover_swap_children_2</code></a></li><li><a href="#HerbSearch.decreasing_temperature-Tuple{Real}"><code>HerbSearch.decreasing_temperature</code></a></li><li><a href="#HerbSearch.default_error_function-Tuple{Any, Any, Any}"><code>HerbSearch.default_error_function</code></a></li><li><a href="#HerbSearch.default_fitness-Tuple{Any, Any}"><code>HerbSearch.default_fitness</code></a></li><li><a href="#HerbSearch.enumerate_neighbours_propose-Tuple{Int64}"><code>HerbSearch.enumerate_neighbours_propose</code></a></li><li><a href="#HerbSearch.get_best_program-Tuple{Array{RuleNode}, HerbSearch.GeneticSearchIterator}"><code>HerbSearch.get_best_program</code></a></li><li><a href="#HerbSearch.get_bfs_enumerator"><code>HerbSearch.get_bfs_enumerator</code></a></li><li><a href="#HerbSearch.get_bfs_enumerator"><code>HerbSearch.get_bfs_enumerator</code></a></li><li><a href="#HerbSearch.get_dfs_enumerator"><code>HerbSearch.get_dfs_enumerator</code></a></li><li><a href="#HerbSearch.get_dfs_enumerator"><code>HerbSearch.get_dfs_enumerator</code></a></li><li><a href="#HerbSearch.get_genetic_enumerator-Tuple{Any}"><code>HerbSearch.get_genetic_enumerator</code></a></li><li><a href="#HerbSearch.get_mh_enumerator"><code>HerbSearch.get_mh_enumerator</code></a></li><li><a href="#HerbSearch.get_most_likely_first_enumerator"><code>HerbSearch.get_most_likely_first_enumerator</code></a></li><li><a href="#HerbSearch.get_most_likely_first_enumerator"><code>HerbSearch.get_most_likely_first_enumerator</code></a></li><li><a href="#HerbSearch.get_sa_enumerator"><code>HerbSearch.get_sa_enumerator</code></a></li><li><a href="#HerbSearch.get_vlsn_enumerator"><code>HerbSearch.get_vlsn_enumerator</code></a></li><li><a href="#HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_leftmost</code></a></li><li><a href="#HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_random</code></a></li><li><a href="#HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_rightmost</code></a></li><li><a href="#HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}"><code>HerbSearch.heuristic_smallest_domain</code></a></li><li><a href="#HerbSearch.mean_squared_error-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})"><code>HerbSearch.mean_squared_error</code></a></li><li><a href="#HerbSearch.misclassification-Tuple{T} where T&lt;:(AbstractVector{&lt;:Tuple{Number, Number}})"><code>HerbSearch.misclassification</code></a></li><li><a href="#HerbSearch.most_likely_priority_function-Tuple{ContextSensitiveGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}"><code>HerbSearch.most_likely_priority_function</code></a></li><li><a href="#HerbSearch.mse_error_function-Tuple{Any, Any, Any}"><code>HerbSearch.mse_error_function</code></a></li><li><a href="#HerbSearch.mutate_random!"><code>HerbSearch.mutate_random!</code></a></li><li><a href="#HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept</code></a></li><li><a href="#HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature</code></a></li><li><a href="#HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}"><code>HerbSearch.probabilistic_accept_with_temperature_fraction</code></a></li><li><a href="#HerbSearch.propagate_constraints"><code>HerbSearch.propagate_constraints</code></a></li><li><a href="#HerbSearch.random_fill_propose-Tuple{RuleNode, NodeLoc, Grammar, Int64, AbstractVector{Int64}, Union{Nothing, Dict{String, Any}}}"><code>HerbSearch.random_fill_propose</code></a></li><li><a href="#HerbSearch.search-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search</code></a></li><li><a href="#HerbSearch.search_best-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search_best</code></a></li><li><a href="#HerbSearch.search_rulenode-Tuple{Grammar, Problem, Symbol}"><code>HerbSearch.search_rulenode</code></a></li><li><a href="#HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_chromosome</code></a></li><li><a href="#HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{&lt;:Real}}"><code>HerbSearch.select_fitness_proportional_parents</code></a></li><li><a href="#HerbSearch.validate_iterator-Tuple{Any}"><code>HerbSearch.validate_iterator</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="#StatsBase.sample"><code>StatsBase.sample</code></a></li><li><a href="../HerbConstraints/#HerbConstraints.@csgrammar_annotated-Tuple{Any}"><code>HerbConstraints.@csgrammar_annotated</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@cfgrammar-Tuple{Any}"><code>HerbGrammar.@cfgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@csgrammar-Tuple{Any}"><code>HerbGrammar.@csgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@pcfgrammar-Tuple{Any}"><code>HerbGrammar.@pcfgrammar</code></a></li><li><a href="../HerbGrammar/#HerbGrammar.@pcsgrammar-Tuple{Any}"><code>HerbGrammar.@pcsgrammar</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../HerbGrammar/">« HerbGrammar.jl</a><a class="docs-footer-nextpage" href="../HerbConstraints/">HerbConstraints.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 21 September 2023 11:57">Thursday 21 September 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
