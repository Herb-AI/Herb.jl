<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Herb Architecture and Core Concepts · Herb.jl</title><meta name="title" content="Herb Architecture and Core Concepts · Herb.jl"/><meta property="og:title" content="Herb Architecture and Core Concepts · Herb.jl"/><meta property="twitter:title" content="Herb Architecture and Core Concepts · Herb.jl"/><meta name="description" content="Documentation for Herb.jl."/><meta property="og:description" content="Documentation for Herb.jl."/><meta property="twitter:description" content="Documentation for Herb.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Herb.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../">Herb.jl</a></li><li><a class="tocitem" href="../install/">Installation Guide</a></li><li><a class="tocitem" href="../tutorials/basic_getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Herb Architecture and Core Concepts</a><ul class="internal"><li><a class="tocitem" href="#Architecture-Introduction"><span>Architecture Introduction</span></a></li></ul></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/getting_started_with_herb/">A more verbose getting started with Herb.jl</a></li><li><a class="tocitem" href="../tutorials/defining_grammars/">Defining Grammars in Herb.jl</a></li><li><a class="tocitem" href="../tutorials/advanced_search/">Advanced Search Procedures</a></li><li><a class="tocitem" href="../tutorials/TopDown/">Top Down Iterator</a></li><li><a class="tocitem" href="../tutorials/getting_started_with_constraints/">Getting started with Constraints</a></li><li><a class="tocitem" href="../tutorials/working_with_interpreters/">Working with custom interpreters</a></li><li><a class="tocitem" href="../tutorials/abstract_syntax_trees/">Abstract Syntax Trees</a></li></ul></li><li><span class="tocitem">Sub-Modules</span><ul><li><a class="tocitem" href="../HerbCore/">HerbCore.jl</a></li><li><a class="tocitem" href="../HerbGrammar/">HerbGrammar.jl</a></li><li><a class="tocitem" href="../HerbSpecification/">HerbSpecification.jl</a></li><li><a class="tocitem" href="../HerbInterpret/">HerbInterpret.jl</a></li><li><a class="tocitem" href="../HerbConstraints/">HerbConstraints.jl</a></li><li><a class="tocitem" href="../HerbSearch/">HerbSearch.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Herb Architecture and Core Concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Herb Architecture and Core Concepts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Herb-AI/Herb.jl/blob/master/docs/src/concepts.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Herb-Architecture-and-Core-Concepts"><a class="docs-heading-anchor" href="#Herb-Architecture-and-Core-Concepts">Herb Architecture and Core Concepts</a><a id="Herb-Architecture-and-Core-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Herb-Architecture-and-Core-Concepts" title="Permalink"></a></h1><h2 id="Architecture-Introduction"><a class="docs-heading-anchor" href="#Architecture-Introduction">Architecture Introduction</a><a id="Architecture-Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Architecture-Introduction" title="Permalink"></a></h2><p>Herb is a <em>program synthesis</em> framework that gives users a great amount of flexibility. </p><p>At its core, program synthesis is trying to search over a <em>space</em> of programs in the attempt to find a program that satisfies a given specification. The specification is most often done as pairs of input/output examples. </p><p>Here is a nice picture showing the synthesis process. <img src="../assets/herb_architecture.png" alt="image"/></p><p>As you can see from the picture above, there are a few parts that needed in the synthesis process. Namely:</p><ol><li>Grammar</li><li>Interpreter</li><li>Iterator</li><li>Examples</li></ol><p>Each part will be discussed in detail how it is implemented in Herb, and small code examples will be provided. After reading through this tutorial you should have a basic general understanding of how <em>Herb</em> works and have an overview of important Herb modules (e.g., <code>HerbSearch</code>, <code>HerbCore</code>, <code>HerbSpecification</code>, <code>HerbBenchmarks</code>, <code>HerbCore</code>, etc.)</p><h3 id="1.-HerbGrammar"><a class="docs-heading-anchor" href="#1.-HerbGrammar">1. HerbGrammar</a><a id="1.-HerbGrammar-1"></a><a class="docs-heading-anchor-permalink" href="#1.-HerbGrammar" title="Permalink"></a></h3><p>First of, let&#39;s start with how do we define grammars in Herb. Grammars provide a set of rules that are used when creating programs. One could have an arithmetic expression grammar that allows addition, subtraction, multiplication, etc. Another example could be a grammar that allows bit manipulation operations (e.g., <em>shift left</em>, <em>shift right</em>, etc.), string operations (e.g., <code>concat</code>, <code>replace</code>, <code>findindex</code>, etc.).</p><p>Ideally, it should be possible to define <em>any</em> grammar in Herb.</p><p>One possible approach could be to let users write the grammar definition in a file <code>mygrammar</code> in a grammar format (e.g., BNF). For instance, for arithmetic expressions, a user would create a grammar as shown below. </p><pre><code class="nohighlight hljs">&lt;expr&gt; ::= &lt;term&gt; &quot;+&quot; &lt;expr&gt;
        |  &lt;term&gt;

&lt;term&gt; ::= &lt;factor&gt; &quot;*&quot; &lt;term&gt;
        |  &lt;factor&gt;

&lt;factor&gt; ::= &quot;(&quot; &lt;expr&gt; &quot;)&quot;
          |  &lt;const&gt;

&lt;const&gt; ::= integer</code></pre><p>Of course, just having a static grammar in a file is not too interesting. The user would like to create expressions from that grammar and evaluate them. But wait a minute…, how can we know how the users want the program to be evaluated from the grammar? Well, in this case, we can <em>infer</em> that he probably means to evaluate arithmetic expressions in the mathematical sense. </p><p>Unfortunately, we cannot do this for any user defined grammar.  In general, grammars only provide the rules to create valid programs, but they <em>do not</em> say <em>how</em> to evaluate those programs. What to do then :shrug: ?</p><p>Well, one option is to let the users define <em>both</em> the grammar and the specification on how to <em>evaluate</em> programs. The users will have a great amount of flexibility with this solution. However, they would have to do that for every new grammar that they define. That will definitely be a tedious task. If you think a bit about it, this is just defining your own <em>programming language</em>. You would have both <em>the syntax</em> of the language and the how to evaluate/interpret the syntax. Can&#39;t we do better :question:  </p><p>Well, it turns out that we are already programming in Julia. Can&#39;t we use the <code>Julia</code>&#39;s parser and interpreter to <em>parse</em> the grammar and <em>evaluate</em> programs? If this were possible, we would definitely cut down the work of users since the parser and interpreter will be already be implemented by someone else (Julia&#39;s developers).  This is essentially <em>piggybacking</em> on the work of other people :) Programmers are known to be lazy, thus this solution seems to be a good fit.</p><h4 id="Defining-grammars-in-Herb-intro"><a class="docs-heading-anchor" href="#Defining-grammars-in-Herb-intro">Defining grammars in Herb - intro</a><a id="Defining-grammars-in-Herb-intro-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-grammars-in-Herb-intro" title="Permalink"></a></h4><p>Julia supports <em>meta-programming,</em> which allows us to invoke the Julia parser and Julia interpreter for our own needs. In our case, we want to use the <code>Julia</code>&#39;s parser to <em>parse</em> the grammar definition and use <code>Julia</code>&#39;s interpreter to interpret the programs. The advantage of using this approach is that users can write the grammar definition inside the code. </p><p>Let&#39;s look at a simple example.</p><pre><code class="language-julia hljs">using HerbGrammar # import @csgrammar

grammar_arithmetic = @csgrammar begin
    Number = Constant
    Constant = 1 | 2 | 3 # constant can be 1 or 2 or 3
    Number = x
    Number = Number + Number
    Number = Number - Number
    Number = Number * Number
end</code></pre><p>Here, we define a grammar with 6 rules. </p><p>However, if you type this the code above in the <code>Julia</code>&#39;s REPL, you will notice something interesting. The given output has more rules :)</p><pre><code class="language-jl hljs">1: Number = Constant
2: Constant = 1
3: Constant = 2
4: Constant = 3
5: Number = x
6: Number = Number + Number
7: Number = Number - Number
8: Number = Number * Number</code></pre><p>This is because the syntax <code>1 | 2 | 3</code> is a syntactic sugar for creating 3 independent rules. Thus, in fact, there are <code>8</code> rules created. Each item on the left hand of the grammar side is <code>Symbol</code> and the items on the right-hand side are Julia expressions.</p><p>The grammar data structure uses rule indices to access rules. In Julia, array indices start from <code>1</code>!</p><p>Run the following examples and check that you can follow what the indices do.</p><pre><code class="language-sh hljs">julia&gt; grammar_arithmetic.rules[1] # gives the RHS(expression) of the 1st rule
:Constant
julia&gt; grammar_arithmetic.rules[6] # gives the RHS(expression) of the 6th rule
:(Number + Number)
julia&gt; grammar_arithmetic.types[6] # gives the LHS (symbol) of the 6th rule 
:Number </code></pre><p>Of course, I am just scratching the surface here... To see all the fields that the Grammar provides from the REPL you can type <code>?</code> to enter <em>docs mode</em> and type <a href="../HerbGrammar/#HerbGrammar.ContextSensitiveGrammar"><code>ContextSensitiveGrammar</code></a> (there is no context free grammar because a context-sensitive grammar can also be context free)</p><pre><code class="language-sh hljs">help?&gt; ContextSensitiveGrammar
... useful docs taken from the comments</code></pre><p>Dealing with rule indices is sometimes a <em>low-level</em> task and that is why there are a lot of helper functions made to make it easier to interact with the grammar. For a more comprehensive overview, check this tutorial on <a href="../tutorials/defining_grammars/">Defining Grammars in Herb.jl</a>.</p><p>As you might have guessed, all the things related to grammars are in the <a href="https://github.com/Herb-AI/HerbGrammar.jl">HerbGrammar</a> package.</p><h3 id="2.-HerbCore"><a class="docs-heading-anchor" href="#2.-HerbCore">2. HerbCore</a><a id="2.-HerbCore-1"></a><a class="docs-heading-anchor-permalink" href="#2.-HerbCore" title="Permalink"></a></h3><p>Looking at the following code, where we sample random grammar rules, you might wonder what is the <code>RuleNode</code> thing doing?</p><pre><code class="language-julia hljs">for _ in 1:10
    rulenode_program = rand(RuleNode, complex_grammar, :StartExpression)
    # print program tree
    println(&quot;Rulenode program: &quot;, rulenode_program)
    # convert prorgam tree to an expression
    expression_program = rulenode2expr(rulenode_program, complex_grammar)
    println(&quot;Program: &quot;,  expression_program)
    # WARNING: some programs will loop forever and you may need to stop julia
    # println(&quot;Eval program: &quot;, eval(expression)) 
end</code></pre><blockquote><p>The short answer to what a RuleNode is that is provides the derivation tree (AST tree) of a program in the grammar. The value at each node of the tree is given by the rule index that corresponds to the grammar.</p></blockquote><p>This definition might be difficult to visualize, that is why we are going to look at some simple examples of how this work.</p><h4 id="Arithmetic-grammar-example"><a class="docs-heading-anchor" href="#Arithmetic-grammar-example">Arithmetic grammar example</a><a id="Arithmetic-grammar-example-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-grammar-example" title="Permalink"></a></h4><p>We are going to return to our simple <code>grammar_arithmetic</code> that we have already seen before.</p><pre><code class="language-jl hljs">grammar_arithmetic = @csgrammar begin
    Number =  1 | 2 | 3 # constant can be 1 or 2 or 3
    Number = x
    Number = Number + Number
    Number = Number - Number
    Number = Number * Number
end</code></pre><p>How would we represent the expression <code>1 + 2 * 3</code> that is taken from this grammar?  We can visualize this expression as an AST Tree like so:</p><div class="mermaid">flowchart TD
    id1((+)) --- id2((1))
    id1 --- id3((*))
    id3 --- id4((2))
    id3 --- id5((3))</div><p>We can relate this tree to the derivation rules that the grammar has as shown below: <img src="../assets/rulenode.png" alt="image"/></p><p>On the left-hand side, you can see that grammar rules and their corresponding indices. On the right-hand side, you can see the corresponding expression tree where next to each node the rule index is shown.</p><p>Thus, a <code>RuleNode</code> is just the derivation tree of a program from the grammar. We can now check the definition of the <code>RuleNode</code> in Herb. Again, using typing <code>?</code> in the REPL and then <code>RuleNode</code> will show us useful information.</p><pre><code class="language-sh hljs">help?&gt; RuleNode
  RuleNode &lt;: AbstractRuleNode

  A RuleNode represents a node in an expression tree. Each node corresponds to a certain rule in the AbstractGrammar. A RuleNode consists of:

    •  ind: The index of the rule in the AbstractGrammar which this node is representing.

    •  _val: Field for storing immediately evaluated values  &lt;- you can diregard this field, it is not used that often

    •  children: The children of this node in the expression tree
// other text</code></pre><p>The <a href="../HerbCore/#HerbCore.RuleNode"><code>HerbCore.RuleNode</code></a> is defined in <code>HerbCore</code>. The definition is as follows:</p><pre><code class="language-jl hljs">mutable struct RuleNode &lt;: AbstractRuleNode
    ind::Int # index in grammar
    _val::Any  #value of _() evals
    children::Vector{AbstractRuleNode}
end</code></pre><p>Ignoring the <code>_val</code> field, this definition should make sense and be inline with what we have seen above.</p><h4 id="Manipulating-RuleNodes-directly"><a class="docs-heading-anchor" href="#Manipulating-RuleNodes-directly">Manipulating RuleNodes directly</a><a id="Manipulating-RuleNodes-directly-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-RuleNodes-directly" title="Permalink"></a></h4><p>One can convert a RuleNode to a nice expression using the <a href="../HerbGrammar/#HerbGrammar.rulenode2expr-Tuple{AbstractRuleNode, AbstractGrammar}"><code>HerbGrammar.rulenode2expr</code></a> function. Let&#39;s create the RuleNode for the expression <code>1 + 2 * 3</code> and print it.</p><pre><code class="language-julia hljs">julia&gt; grammar_arithmetic = @csgrammar begin
           Number =  1 | 2 | 3 # constant can be 1 or 2 or 3
           Number = x
           Number = Number + Number
           Number = Number - Number
           Number = Number * Number
       end
1: Number = 1
2: Number = 2
3: Number = 3
4: Number = x
5: Number = Number + Number
6: Number = Number - Number
7: Number = Number * Number
julia&gt; rulenode = RuleNode(5,
           [   RuleNode(1),
               RuleNode(7, [RuleNode(2), RuleNode(3)])
           ])  # create the rulenode with indices as shown in the image above
5{1,7{2,3}}
julia&gt; rulenode2expr(rulenode,  grammar_arithmetic) # show the expression corresponding to the rulenode
:(1 + 2 * 3)  # nice it works</code></pre><p>Since RuleNodes are just trees, one can manipulate them as any other tree-like data structure. One can modify the children or grammar index directly since the struct definition is <em>mutable</em>. However, it is important to keep in mind that RuleNodes are very tightly defined to a grammar. A <code>RuleNode</code> without a grammar does not do much on its own.</p><p>Let&#39;s try to directly change a RuleNode</p><pre><code class="language-julia hljs">julia&gt; rulenode.ind = 9 # set the root value to use the rule index 9 (But there is no rule index 9 in the grammar)
9
julia&gt; rulenode2expr(rulenode,  grammar_arithmetic) # let&#39;s try to print the new rulenode 
ERROR: BoundsError: attempt to access 7-element Vector{Any} at index [9] # &lt;- Ups error..
Stacktrace:
 [1] getindex
   @ ./essentials.jl:13 [inlined]
 [2] rulenode2expr(rulenode::RuleNode, grammar::ContextSensitiveGrammar)
   @ HerbGrammar ~/.julia/dev/HerbGrammar/src/rulenode_operators.jl:181</code></pre><p>As you can see, there is a <em>hidden dependency</em> between RuleNodes and grammars. The indices of the RuleNode should correspond to valid grammar indices and the number of children for a rule should correspond to the number of children that rule has in the grammar.</p><h4 id="Useful-RuleNode-functions"><a class="docs-heading-anchor" href="#Useful-RuleNode-functions">Useful RuleNode functions</a><a id="Useful-RuleNode-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-RuleNode-functions" title="Permalink"></a></h4><p>Some very useful functions to know:</p><ul><li><a href="@ref"><code>HerbCoredepth</code></a>: gets the depth of the tree of the RuleNode</li><li><a href="../HerbConstraints/#Base.length-Tuple{HerbConstraints.StateSparseSet}"><code>Base.length</code></a> or just `length(rulenode) gets the number of nodes in the RuleNode</li><li><a href="../HerbGrammar/#HerbGrammar.rulenode2expr-Tuple{AbstractRuleNode, AbstractGrammar}"><code>HerbGrammar.rulenode2expr</code></a> converts a RuleNode to a grammar</li></ul><h3 id="3.-Iterators"><a class="docs-heading-anchor" href="#3.-Iterators">3. Iterators</a><a id="3.-Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Iterators" title="Permalink"></a></h3><p>Almost any programming language supports iterators. Julia supports the iterator pattern but in a bit of a different way because it <code>Julia</code> does have OOP. In <code>Java</code> there is an <em>interface</em> <code>Iterator</code> that each class (e.g., Vector, List, Map, etc.) implements.</p><p>In Julia an iterator is a type that implements two methods:</p><ul><li><a href="@ref"><code>Base.iterator(iterator::MyIterator)</code></a></li><li><a href="@ref"><code>Base.iterator(iterator::MyIterator,state::MyIteratorState)</code></a></li></ul><p>Each of these functions might return <code>nothing</code> if the iterator is done iterating, or it might return a tuple of the actual value that is being iterated (e.g., a number) and the state of the iterator. </p><p>Consider a simple Julia for loop:</p><pre><code class="language-jl hljs">for value in iterator
   println(value)
end</code></pre><p>This is translated to:</p><pre><code class="language-jl hljs"># iterator is any type that can be iterated (list,dict,etc)
it = iterate(iterator) # same as Base.iterate(itearator)
while it !== nothing   # as long as the iterator is not done
    value, state = it      # get the value and the state
    # do something with the value of the iterator
    println(value) 
    it = iterate(iterator, state)  # runs the iterator with the new state
end </code></pre><p>What Julia is doing here is that it passes the iterator <em>state</em> to subsequent <code>Base.iterate</code> calls after each for loop iteration. This pattern turns out to be very powerful because the search algorithms can be implemented using iterators. This is also memory efficient because we do not generate all programs at one but generate them one by one. </p><p>Thus, the search algorithms (e.g., BFS, DFS, etc.) just provide an order in which they <em>enumerate</em> the search space. </p><h4 id="Build-own-search-algorithm"><a class="docs-heading-anchor" href="#Build-own-search-algorithm">Build own search algorithm</a><a id="Build-own-search-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Build-own-search-algorithm" title="Permalink"></a></h4><p>Let&#39;s try to create a new search algorithm in Herb from scratch. We will need three ingredients:</p><ol><li>A new iterator type. Let&#39;s call it <code>NiceCustomIterator</code> for now.</li><li>A state that the iterator has for each iteration</li><li>Implement <code>Base.iterate(iter::NiceCustomIterator)</code> and implement <code>Base.iterate(iter::NiceCustomIterator, state)</code></li></ol><p>We are going to implement an iterator that is quite funny. It will generate random programs for a given amount of time (e.g., 2 seconds) and then just enumerates programs using the BFS iterator for some other given time (e.g., 3 seconds). After that, it will start generating random programs and the process will repeat. When using BFS the enumeration will <em>resume</em> from the previous saved state of the BFS iterator. </p><p>We will tackle each point one by one.</p><p>But before we start coding, let&#39;s create a new folder in <code>HerbSearch</code> and call it <code>ouriterator</code>. Inside that folder, let&#39;s create a Julia file <code>nicecustom_iterator.jl</code> where we are going to put our code. </p><ol><li>First, we need to think about what to store in the iterator. We need to store a grammar in order to sample random programs, and we also need the two configurable timeouts: one for running the random search and one for running the BFS iterator.</li></ol><p>Our definition looks like this, for now.</p><pre><code class="language-jl hljs">struct NiceCustomIterator
    grammar::AbstractGrammar
    timer_run_random::Float64
    timer_run_bfs::Float64
end</code></pre><ol><li>Secondly, we need to know the state of the iterator. We need to keep track of the both running timers to ensure that we switch from random to BFS and vice versa at the right time. A simple way to do this would be to store the <code>start_time_random</code> of the random iterator and then in the <code>iterate</code> function check if the current<em>time is bigger than the `starting time + timer</em>run<em>random<code>. We can do the same for BFS using a field</code>start</em>time<em>bfs<code>. It would also be helpful to know which timer should we check (random or BFS). For that a boolean</code>is</em>running_random` can be used.</li></ol><p>The definition we have so far looks like this:</p><pre><code class="language-jl hljs">struct NiceCustomIteratorState
    start_time_random::Float64
    start_time_bfs::Float64
    is_running_random::Bool # true if we are currently running random search. false if we run BFS
end</code></pre><ol><li>Now we need to implement <code>Base.iterate(iterator)</code>. This function does not take the state as a parameter because is only run once. We need to return the new program and also new state.</li></ol><p>To simplify things, we will make our algorithm always start randomly.</p><pre><code class="language-jl hljs">function Base.iterate(iterator::NiceCustomIterator) 
    random_program = rand(RuleNode, iterator.grammar)
    return random_program, nothing
end</code></pre><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/basic_getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../tutorials/getting_started_with_herb/">A more verbose getting started with Herb.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 5 January 2026 15:53">Monday 5 January 2026</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
