var documenterSearchIndex = {"docs":
[{"location":"get_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"You can either paste this code into the Julia REPL or into a seperate file, e.g. get_started.jl followed by julia get_started.jl.","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"To begin, we need to import all needed packages using","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"using HerbGrammar, HerbData, HerbSearch, HerbInterpret","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"To define a program synthesis problem, we need a grammar and specification. ","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"First, the grammar can be constructed using the @cfgrammar macro included in HerbGrammar. Here we describe a simple integer arithmetic example, that can add and multiply an input variable x or the integers 1,2, using","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"g = @cfgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"Second, the problem specification can be provided using e.g. input/output examples using HerbData. Inputs are provided as a Dict assigning values to variables, and outputs as arbitrary values. The problem itself is then a list of IOExamples using","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"problem = Problem([IOExample(Dict(:x => x), 2x+1) for x ∈ 1:5])","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"The problem is given now, let us search for a solution with HerbSearch. For now we will just use the default parameters searching for a satisfying program over the grammar, given the problem and a starting symbol using","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"solution = search(g, problem, :Number, max_depth=3)\nprintln(solution)","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"There are various ways to adapt the search technique to your needs. Please have a look at the search documentation.","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"Eventually, we want to test our solution on some other inputs using HerbInterpret. We transform our grammar g to a Julia expression with Symboltable(g), add our solution and the input, assigning the value 6 to the variable x.","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"output = test_with_input(SymbolTable(g), solution, Dict(:x => 6))\nprintln(output)","category":"page"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"Just like that we tackled (almost) all modules of Herb.jl.","category":"page"},{"location":"get_started/#Where-to-go-from-here?","page":"Getting Started","title":"Where to go from here?","text":"","category":"section"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"See our other tutorials!","category":"page"},{"location":"get_started/#The-full-code-example","page":"Getting Started","title":"The full code example","text":"","category":"section"},{"location":"get_started/","page":"Getting Started","title":"Getting Started","text":"using HerbSearch, HerbData, HerbInterpret\n\n# define our very simple context-free grammar\n# Can add and multiply an input variable x or the integers 1,2.\ng = @cfgrammar begin\n    Number = |(1:2)\n    Number = x\n    Number = Number + Number\n    Number = Number * Number\nend\n\nproblem = Problem([IOExample(Dict(:x => x), 2x+1) for x ∈ 1:5])\nsolution = search(g, problem, :Number, max_depth=3)\n\ntest_with_input(SymbolTable(g), solution, Dict(:x => 6))","category":"page"},{"location":"concepts/#Architecture-and-core-concepts","page":"Architecture and core concepts","title":"Architecture and core concepts","text":"","category":"section"},{"location":"HerbData/#HerbData_docs","page":"HerbCore.jl","title":"HerbData.jl Documentation","text":"","category":"section"},{"location":"HerbData/","page":"HerbCore.jl","title":"HerbCore.jl","text":"CurrentModule=HerbData","category":"page"},{"location":"HerbData/","page":"HerbCore.jl","title":"HerbCore.jl","text":"Modules = [HerbData]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbData/#HerbData.IOExample","page":"HerbCore.jl","title":"HerbData.IOExample","text":"struct IOExample <: Example\n\nAn input-output example. input is a Dict of {Symbol,Any} where the symbol represents a variable in a program. output can be anything.\n\n\n\n\n\n","category":"type"},{"location":"HerbData/#HerbData.IOPExample","page":"HerbCore.jl","title":"HerbData.IOPExample","text":"struct IOPExample <: Example\n\nAn input-output example with an associated program. ex is an IOExample. program is a program of arbitrary form. Please note that this is a pure container, and thus does not guarantee any checks on the validity of the program.\n\n\n\n\n\n","category":"type"},{"location":"HerbData/#HerbData.Problem","page":"HerbCore.jl","title":"HerbData.Problem","text":"struct Problem\n\nProgram synthesis problem defined with a vector of Examples\n\n\n\n\n\n","category":"type"},{"location":"HerbData/#HerbData.read_IOPexamples-Tuple{AbstractString}","page":"HerbCore.jl","title":"HerbData.read_IOPexamples","text":"read_IOPexamples(filepath::AbstractString)::Vector{Tuple{IOPExample}\n\nReads serialized IO + program examples from disk after type checking.\n\n\n\n\n\n","category":"method"},{"location":"HerbData/#HerbData.read_IOexamples-Tuple{AbstractString}","page":"HerbCore.jl","title":"HerbData.read_IOexamples","text":"read_IOexamples(filepath::AbstractString)::Vector{IOExample}\n\nReads serialized IO examples from disk after type checking.\n\n\n\n\n\n","category":"method"},{"location":"HerbData/#HerbData.readdata-Tuple{AbstractString, Function}","page":"HerbCore.jl","title":"HerbData.readdata","text":"readdata(directory::AbstractString, lineparser::Function)::Vector{Problem}\n\nReads all files in the given directory and parses them line by line into an  ExampleProblem using the given lineparser.\n\nTODO: Turn this into an iterator that doesn't load all data into memory at initialization.\n\n\n\n\n\n","category":"method"},{"location":"HerbData/#HerbData.readfile-Tuple{AbstractString, Function}","page":"HerbCore.jl","title":"HerbData.readfile","text":"readfile(filepath::AbstractString, lineparser::Function)::Problem\n\nReads a file and parses every non-empty line using the line parser.\n\n\n\n\n\n","category":"method"},{"location":"HerbData/#HerbData.write_IOPexamples-Tuple{AbstractString, Vector{IOPExample}}","page":"HerbCore.jl","title":"HerbData.write_IOPexamples","text":"write_IOPexamples(filepath::AbstractString, examples::Vector{Tuple{IOExample, Any}})\n\nWrites IO examples and the corresponding programs to disk by serializing them into a file using HDF5 checking for and appending the .xiop.\n\n\n\n\n\n","category":"method"},{"location":"HerbData/#HerbData.write_IOexamples-Tuple{AbstractString, Vector{IOExample}}","page":"HerbCore.jl","title":"HerbData.write_IOexamples","text":"write_IOexamples(filepath::AbstractString, examples::Vector{IOExample})\n\nWrites IO examples to disk by serializing them into a file using HDF5 checking for and appending the .xio file ending.\n\n\n\n\n\n","category":"method"},{"location":"HerbData/#Index","page":"HerbCore.jl","title":"Index","text":"","category":"section"},{"location":"HerbData/","page":"HerbCore.jl","title":"HerbCore.jl","text":"","category":"page"},{"location":"HerbConstraints/#HerbConstraints_docs","page":"HerbConstraints.jl","title":"HerbConstraints.jl Documentation","text":"","category":"section"},{"location":"HerbConstraints/","page":"HerbConstraints.jl","title":"HerbConstraints.jl","text":"CurrentModule=HerbConstraints","category":"page"},{"location":"HerbConstraints/","page":"HerbConstraints.jl","title":"HerbConstraints.jl","text":"Modules = [HerbConstraints]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbConstraints/#HerbConstraints.AbstractMatchNode","page":"HerbConstraints.jl","title":"HerbConstraints.AbstractMatchNode","text":"abstract type AbstractMatchNode\n\nTree structure to which rulenode trees can be matched. Consists of MatchNodes, which can match a specific RuleNode, and MatchVars, which is a variable that can be filled in with any RuleNode.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.ComesAfter","page":"HerbConstraints.jl","title":"HerbConstraints.ComesAfter","text":"ComesAfter <: PropagatorConstraint\n\nA ComesAfter constraint is a PropagatorConstraint containing the following:\n\nrule::Int: A reference to a rule in the grammar\npredecessors: A list of rules in the grammar\n\nThis Constraint enforces that the rule can only be applied if every rule in  predecessors is used in the path from the root of the tree  to the current hole in the order  that they are given. Even though the rules must be in order, there might be other rules inbetween.\n\nFor example, consider the tree 1(a, 2(b, 3(c, d)))):\n\nComesAfter(4, [2, 3]) would enforce that rule 4 can only be used if 2 and 3  are used in the path from the root in that order. Therefore, only hole c and d can be filled with 4.\nComesAfter(4, [1, 3]) also allows c and d to be filled, since 1 and 3 are still used in the  correct order. It does not matter that 2 is also used in the path to the root.\nComesAfter(4, [3, 2]) does not allow any hole to be filled with 4, since either the predecessors are  either not in the path or in the wrong order for each of the holes. \n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.ComesAfter-Tuple{Int64, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.ComesAfter","text":"ComesAfter(rule::Int, predecessor::Int)\n\nCreates a ComesAfter constraint with only a single predecessor. \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.Forbidden","page":"HerbConstraints.jl","title":"HerbConstraints.Forbidden","text":"Forbidden <: PropagatorConstraint\n\nThis [PropagatorConstraint] forbids any subtree that matches the pattern given by tree to be generated. A pattern is a tree of AbstractMatchNodes.  Such a node can either be a MatchNode, which contains a rule index corresponding to the  rule index in the Grammar and the appropriate number of children, similar to RuleNodes. It can also contain a MatchVar, which contains a single identifier symbol. A MatchVar can match any subtree, but if there are multiple instances of the same variable in the pattern, the matched subtrees must be identical. Any rule in the domain that makes the match attempt successful is removed.\n\nFor example, consider the tree 1(a, 2(b, 3(c, 4)))):\n\nForbidden(MatchNode(3, [MatchNode(5), MatchNode(4)])) forbids c to be filled with 5.\nForbidden(MatchNode(3, [MatchVar(:v), MatchNode(4)])) forbids c to be filled, since a [MatchVar] can  match any rule, thus making the match attempt successful for the entire domain of c.  Therefore, this tree invalid.\nForbidden(MatchNode(3, [MatchVar(:v), MatchVar(:v)])) forbids c to be filled with 4, since that would  make both assignments to v equal, which causes a successful match.\n\nwarning: Warning\nThe Forbidden constraint makes use of LocalConstraints to make sure that constraints  are also enforced in the future when the context of a Hole changes.  Therefore, Forbidden can only be used in implementations that keep track of the  LocalConstraints and propagate them at the right moments.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.ForbiddenPath","page":"HerbConstraints.jl","title":"HerbConstraints.ForbiddenPath","text":"ForbiddenPath <: PropagatorConstraint\n\nA [PropagatorConstraint] that forbids a certain derivation sequence. sequence defines the forbidden sequence.  Each rule that would complete the sequence when expanding a Hole in an  AbstractRuleNode tree is removed from the domain. The derivation sequence is the path from the root to the hole.\n\nFor example, consider the tree 1(a, 2(b, 3(c, d)))):\n\nForbiddenPath([1, 2, 4]) enforces that rule 4 cannot be applied at b,  since it completes the sequence. However, it can be applied at a, c and d.\nForbiddenPath([3, 1]) enforces that rule 1 cannot be applied at c or d.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.GrammarContext","page":"HerbConstraints.jl","title":"HerbConstraints.GrammarContext","text":"mutable struct GrammarContext\n\nStructure used to track the context. Contains: \t- the expression being modified  \t- the path to the hole that is being expanded, represented as a sequence of child indices. \t  e.g., [2, 1] would point to the first child of the second child of the root. \t- a vector with local constraints that should be propagated upon expansion.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalConstraint","page":"HerbConstraints.jl","title":"HerbConstraints.LocalConstraint","text":"abstract type LocalConstraint <: Constraint\n\nAbstract type representing all local constraints. Local constraints correspond to a specific (partial) AbstractRuleNode tree. Each local constraint contains a path to a specific location in the tree.   Each local constraint has an implementation of a propagate-function that takes\n\nthe LocalConstraint\na Grammar\na GrammarContext, which most importantly contains the tree and the location  in the tree where propagation should take place.\nThe domain which the propagate-function prunes. \n\nThe propagate-function returns a tuple containing\n\nThe pruned domain\nA list of new LocalConstraints\n\nwarning: Warning\nBy default, LocalConstraints are only propagated once. Constraints that have to be propagated more frequently should return  themselves in the list of new local constraints.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalForbidden","page":"HerbConstraints.jl","title":"HerbConstraints.LocalForbidden","text":"LocalForbidden\n\nForbids the a subtree that matches the MatchNode tree to be generated at the location  provided by the path.  Use a Forbidden constraint for enforcing this throughout the entire search space.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalOneOf","page":"HerbConstraints.jl","title":"HerbConstraints.LocalOneOf","text":"Meta-constraint that enforces the disjunction of its given constraints.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.LocalOrdered","page":"HerbConstraints.jl","title":"HerbConstraints.LocalOrdered","text":"Enforces an order over two or more subtrees that fill the variables  specified in order when the pattern is applied at the location given by path. Use an Ordered constraint for enforcing this throughout the entire search space.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MatchFail","page":"HerbConstraints.jl","title":"HerbConstraints.MatchFail","text":"@enum MatchFail hardfail softfail\n\nThis enum is used for distinguishing between two types of failures when trying to  match a RuleNode either with another RuleNode or with an AbstractMatchNode\n\nHardfail means that there is no match, and there is no way to fill in the holes to get a match.\nSoftfail means that there is no match, but there might be a way to fill the holes that results in a match.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MatchNode","page":"HerbConstraints.jl","title":"HerbConstraints.MatchNode","text":"struct MatchNode <: AbstractMatchNode\n\nMatch a specific rulenode, where the grammar rule index is rule_ind  and children matches the children of the RuleNode. Example usage:\n\nMatchNode(3, [MatchNode(1), MatchNode(2)])\n\nThis matches RuleNode(3, [RuleNode(1), RuleNode(2)])\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.MatchVar","page":"HerbConstraints.jl","title":"HerbConstraints.MatchVar","text":"struct MatchVar <: AbstractMatchNode\n\nMatches anything and assigns it to a variable.  The ForbiddenTree constraint will not match if identical variable symbols match to different trees. Example usage:\n\nMatchNode(3, [MatchVar(:x), MatchVar(:x)])\n\nThis matches RuleNode(3, [RuleNode(1), RuleNode(1)]), RuleNode(3, [RuleNode(2), RuleNode(2)]), etc.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.OneOf","page":"HerbConstraints.jl","title":"HerbConstraints.OneOf","text":"Meta-constraint that enforces the disjunction of its given constraints.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.Ordered","page":"HerbConstraints.jl","title":"HerbConstraints.Ordered","text":"Ordered <: PropagatorConstraint\n\nA PropagatorConstraint that enforces a specific order in MatchVar  assignments in the pattern defined by tree. A pattern is a tree of AbstractMatchNodes.  Such a node can either be a MatchNode, which contains a rule index corresponding to the  rule index in the Grammar and the appropriate number of children, similar to RuleNodes. It can also contain a MatchVar, which contains a single identifier symbol. A MatchVar can match any subtree, but if there are multiple instances of the same variable in the pattern, the matched subtrees must be identical.\n\nThe order defines an order between the variable assignments.  For example, if the order is [x, y], the constraint will require  the assignment to x to be less than or equal to the assignment to y. The order is recursively defined by RuleNode indices.  For more information, see Base.isless(rn₁::AbstractRuleNode, rn₂::AbstractRuleNode).\n\nFor example, consider the tree 1(a, 2(b, 3(c, 4)))):\n\nOrdered(MatchNode(3, [MatchVar(:v), MatchVar(:w)]), [:v, :w]) removes every rule  with an index of 5 or greater from the domain of c, since that would make the index of the  assignment to v greater than the index of the assignment to w, violating the order.\nOrdered(MatchNode(3, [MatchVar(:v), MatchVar(:w)]), [:w, :v]) removes every rule  with an index of 4 or less from the domain of c, since that would make the index of the  assignment to v less than the index of the assignment to w, violating the order.\n\nwarning: Warning\nThe Ordered constraint makes use of LocalConstraints to make sure that constraints  are also enforced in the future when the context of a Hole changes.  Therefore, Ordered can only be used in implementations that keep track of the  LocalConstraints and propagate them at the right moments.\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.PropagatorConstraint","page":"HerbConstraints.jl","title":"HerbConstraints.PropagatorConstraint","text":"PropagatorConstraint <: Constraint\n\nAbstract type representing all propagator constraints. Each propagator constraint has an implementation of a propagate-function that takes\n\nthe PropagatorConstraint\na Grammar\na GrammarContext, which most importantly contains the tree and the location  in the tree where propagation should take place.\nThe domain which the propagate-function prunes. \n\nThe propagate-function returns a tuple containing\n\nThe pruned domain\nA list of new LocalConstraints\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.RequireOnLeft","page":"HerbConstraints.jl","title":"HerbConstraints.RequireOnLeft","text":"Rules have to be used in the specified order. That is, rule at index K can only be used if rules at indices [1...K-1] are used in the left subtree of the current expression\n\n\n\n\n\n","category":"type"},{"location":"HerbConstraints/#HerbConstraints.@csgrammar_annotated-Tuple{Any}","page":"HerbConstraints.jl","title":"HerbConstraints.@csgrammar_annotated","text":"@csgrammar_annotated Define an annotated grammar and return it as a ContextSensitiveGrammar. Allows for adding optional annotations per rule. As well as that, allows for adding optional labels per rule, which can be referenced in annotations.  Syntax is backwards-compatible with @csgrammar. Examples:\n\ng₁ = @csgrammar_annotated begin\n    Element = 1\n    Element = x\n    Element = Element + Element := commutative\n    Element = Element * Element := (commutative, transitive)\nend\n\ng₁ = @csgrammar_annotated begin\n    Element = 1\n    Element = x\n    Element = Element + Element := forbidden_path([3, 1])\n    Element = Element * Element := (commutative, transitive)\nend\n\ng₁ = @csgrammar_annotated begin\n    one::            Element = 1\n    variable::       Element = x\n    addition::       Element = Element + Element := (\n                                                       commutative,\n                                                       transitive,\n                                                       forbidden_path([:addition, :one]) || forbidden_path([:one, :variable])\n                                                    )\n    multiplication:: Element = Element * Element := (commutative, transitive)\nend\n\n\n\n\n\n","category":"macro"},{"location":"HerbConstraints/#Base.show-Tuple{IO, MatchNode}","page":"HerbConstraints.jl","title":"Base.show","text":"Base.show(io::IO, node::MatchNode; separator=\",\", last_child::Bool=true)\n\nPrints a found MatchNode given an and the respective children to IO. \n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Base.show-Tuple{IO, MatchVar}","page":"HerbConstraints.jl","title":"Base.show","text":"Base.show(io::IO, node::MatchVar; separator=\",\", last_child::Bool=true)\n\nPrints a matching variable assignment described by MatchVar to IO.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._matchnode2expr","page":"HerbConstraints.jl","title":"HerbConstraints._matchnode2expr","text":"_matchnode2expr(expr::Expr, pattern::MatchVar, grammar::Grammar, j=0)\n\nInternal function for matchnode2expr, recursively iterating over a matched variable and converting it to an expression. This is primarily useful for pretty-printing a pattern. Returns the corresponding expression and the current child index.\n\n\n\n\n\n","category":"function"},{"location":"HerbConstraints/#HerbConstraints._matchnode2expr-2","page":"HerbConstraints.jl","title":"HerbConstraints._matchnode2expr","text":"_matchnode2expr(expr::Expr, pattern::MatchNode, grammar::Grammar, j=0)\n\nInternal function for matchnode2expr, recursively iterating over a matched pattern and converting it to an expression. This is primarily useful for pretty-printing a pattern. Returns the corresponding expression and the current child index.\n\n\n\n\n\n","category":"function"},{"location":"HerbConstraints/#HerbConstraints._matchnode2expr-3","page":"HerbConstraints.jl","title":"HerbConstraints._matchnode2expr","text":"_matchnode2expr(typ::Symbol, pattern::MatchVar, grammar::Grammar, j=0)\n\nInternal function for matchnode2expr. This is primarily useful for pretty-printing a pattern. Returns the corresponding expression, i.e. the variable name and the current child index.\n\n\n\n\n\n","category":"function"},{"location":"HerbConstraints/#HerbConstraints._matchnode2expr-4","page":"HerbConstraints.jl","title":"HerbConstraints._matchnode2expr","text":"_matchnode2expr(typ::Symbol, pattern::MatchNode, grammar::Grammar, j=0)\n\nInternal function for matchnode2expr, returning the matched translated symbol. This is primarily useful for pretty-printing a pattern. Returns the corresponding expression, i.e. the variable name and the current child index.\n\n\n\n\n\n","category":"function"},{"location":"HerbConstraints/#HerbConstraints._pattern_match-Tuple{RuleNode, MatchNode, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints._pattern_match","text":"_pattern_match(rn::RuleNode, mn::MatchNode, vars::Dict{Symbol, AbstractRuleNode})::Union{Nothing, MatchFail}\n\nTries to match RuleNode rn with MatchNode mn. Modifies the variable assignment dictionary vars. Returns nothing if the match is successful. If the match is unsuccessful, it returns whether it is a softfail or hardfail (see MatchFail docstring)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._pattern_match-Tuple{RuleNode, MatchVar, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints._pattern_match","text":"_pattern_match(rn::RuleNode, mv::MatchVar, vars::Dict{Symbol, AbstractRuleNode})::Union{Nothing, MatchFail}\n\nMatching RuleNode rn with MatchVar mv. If the variable is already assigned, the rulenode is matched with the specific variable value. Returns nothing if the match is succesful.  If the match is unsuccessful, it returns whether it is a softfail or hardfail (see MatchFail docstring)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints._pattern_match_with_hole","text":"_pattern_match_with_hole(::Hole, mn::MatchNode, hole_location::Vector{Int}, ::Dict{Symbol, AbstractRuleNode})::Union{Int, Symbol, MatchFail, Tuple{Symbol, Vector{Int}}}\n\nMatches the Hole with the given MatchNode. \n\nTODO check this behaviour?\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{Hole, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints._pattern_match_with_hole","text":"_pattern_match_with_hole(::Hole, mn::MatchNode, hole_location::Vector{Int}, ::Dict{Symbol, AbstractRuleNode})::Union{Int, Symbol, MatchFail, Tuple{Symbol, Vector{Int}}}\n\nMatches the Hole with the given MatchVar, similar to _pattern_match_with_hole.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchNode, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints._pattern_match_with_hole","text":"_pattern_match_with_hole(rn::RuleNode, mn::MatchNode, hole_location::Vector{Int}, vars::Dict{Symbol, AbstractRuleNode})::Union{Int, Symbol, MatchFail, Tuple{Symbol, Vector{Int}}}\n\nTries to match RuleNode rn with MatchNode mn and fill in the domain of the hole at hole_location.  Returns if match is successful either:\n\nThe id for the node which fills the hole\nA symbol for the variable that fills the hole\nA tuple containing:\nThe variable that matched (the subtree containing) the hole\nThe location of the hole in this subtree\n\nIf the match is unsuccessful, it returns:\n\nhardfail if there are no holes that can be filled in such a way that the match will become succesful\nsoftfail if the match could become successful if the holes are filled in a certain way\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._pattern_match_with_hole-Tuple{RuleNode, MatchVar, Vector{Int64}, Dict{Symbol, AbstractRuleNode}}","page":"HerbConstraints.jl","title":"HerbConstraints._pattern_match_with_hole","text":"_pattern_match_with_hole(rn::RuleNode, mv::MatchVar, hole_location::Vector{Int}, vars::Dict{Symbol, AbstractRuleNode})::Union{Int, Symbol, MatchFail, Tuple{Symbol, Vector{Int}}}\n\nTries to match RuleNode rn with MatchVar mv and fill in the domain of the hole at hole_location. If the variable name is already assigned in vars, the rulenode is matched with the hole. Otherwise the variable and the hole location are returned.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._rulenode_compare-Tuple{RuleNode, RuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints._rulenode_compare","text":"Returns -1 if rn₁ < rn₂\nReturns  0 if rn₁ == rn₂  \nReturns  1 if rn₁ > rn₂\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints._rulenode_match_with_hole-Tuple{RuleNode, RuleNode, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints._rulenode_match_with_hole","text":"_rulenode_match_with_hole(rn₁::RuleNode, rn₂::RuleNode, hole_location::Vector{Int})::Union{Int, MatchFail}\n\nMatches two rulenodes.  Returns how to fill in the hole in rn₁ to make it match rn₂ if:\n\nrn₁ has a single hole at the provided location\nrn₂ doesn't have any holes\nrn₁ matches rn₂ apart from the single hole location.\n\nIf the match fails, it returns whether it is a softfail or a hardfail (see MatchFail docstring)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.addparent!-Tuple{GrammarContext, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.addparent!","text":"addparent!(context::GrammarContext, parent::Int)\n\nAdds a parent to the context. The parent is defined by the grammar rule id.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.annotation2constraint-Tuple{Any, Int64, Vector{String}}","page":"HerbConstraints.jl","title":"HerbConstraints.annotation2constraint","text":"Converts an annotation to a constraint. commutative: creates an Ordered constraint transitive: creates an (incorrect) Forbidden constraint forbidden_path(path::Vector{Union{Symbol, Int}}): creates a ForbiddenPath constraint with the original rule included ... || ...: creates a OneOf constraint (also works with ... || ... || ... et cetera, though not very performant)\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{ComesAfter, Grammar, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"Checks if the given tree abides the constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Forbidden, Grammar, RuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::Forbidden, g::Grammar, tree::RuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Forbidden constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{ForbiddenPath, Grammar, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"Checks if the given tree abides the constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{HerbConstraints.Condition, Grammar, RuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"Checks if the given tree abides the constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{OneOf, Grammar, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"Checks if the given tree abides the constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{Ordered, Grammar, RuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"check_tree(c::Ordered, g::Grammar, tree::RuleNode)::Bool\n\nChecks if the given AbstractRuleNode tree abides the Ordered constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.check_tree-Tuple{RequireOnLeft, Grammar, AbstractRuleNode}","page":"HerbConstraints.jl","title":"HerbConstraints.check_tree","text":"Checks if the given tree abides the constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.copy_and_insert-Tuple{GrammarContext, Int64}","page":"HerbConstraints.jl","title":"HerbConstraints.copy_and_insert","text":"copy_and_insert(old_context::GrammarContext, parent::Int)\n\nCopies the given context and insert the parent in the node location.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.make_smaller_or_equal-Tuple{RuleNode, RuleNode, Vector{Int64}, Vector{Int64}}","page":"HerbConstraints.jl","title":"HerbConstraints.make_smaller_or_equal","text":"Filters the domain of the hole at hole_location in rn₁ to make rn₁ be ordered before rn₂.   Returns the filtered domain, and a boolean indicating if this constraint can be deleted.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.matchnode2expr-Tuple{MatchNode, Grammar}","page":"HerbConstraints.jl","title":"HerbConstraints.matchnode2expr","text":"matchnode2expr(pattern::MatchNode, grammar::Grammar)\n\nConverts a MatchNode tree into a Julia expression.  This is primarily useful for pretty-printing a pattern. Returns the corresponding expression.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.matchnode2expr-Tuple{MatchVar, Grammar}","page":"HerbConstraints.jl","title":"HerbConstraints.matchnode2expr","text":"matchnode2expr(pattern::MatchVar, grammar::Grammar)\n\nConverts a MatchVar into an expression by returning the variable directly. This is primarily useful for pretty-printing a pattern.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate-Tuple{Forbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate","text":"propagate(c::Forbidden, g::Grammar, context::GrammarContext, domain::Vector{Int})::Tuple{Vector{Int}, Vector{LocalConstraint}}\n\nPropagates the Forbidden constraint. It removes the rules from the domain that would complete the forbidden tree.\n\nwarning: Warning\nThe Forbidden constraint makes use of LocalConstraints to make sure that constraints  are also enforced in the future when the context of a Hole changes.  Therefore, Forbidden can only be used in implementations that keep track of the  LocalConstraints and propagate them at the right moments.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate-Tuple{ForbiddenPath, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate","text":"Propagates the ForbiddenPath constraint. It removes the elements from the domain that would complete the forbidden sequence.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate-Tuple{HerbConstraints.LocalOneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate","text":"Propagates the LocalOneOf constraint. It enforces that at least one of its given constraints hold.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate-Tuple{LocalForbidden, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate","text":"Propagates the LocalForbidden constraint. It removes rules from the domain that would make the RuleNode at the given path match the pattern defined by the MatchNode.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate-Tuple{LocalOrdered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate","text":"Propagates the LocalOrdered constraint. It removes rules from the domain that would violate the order of variables as defined in the  constraint.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate-Tuple{OneOf, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate","text":"Propagates the OneOf constraint. It enforces that at least one of its given constraints hold.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate-Tuple{Ordered, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate","text":"propagate(c::Ordered, g::Grammar, context::GrammarContext, domain::Vector{Int})::Tuple{Vector{Int}, Vector{LocalConstraint}}\n\nPropagates the Ordered constraint. Any rule that violates the order as defined by the contraint is removed from the domain.\n\nwarning: Warning\nThe Ordered constraint makes use of LocalConstraints to make sure that constraints  are also enforced in the future when the context of a Hole changes.  Therefore, Ordered can only be used in implementations that keep track of the  LocalConstraints and propagate them at the right moments.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#HerbConstraints.propagate-Tuple{RequireOnLeft, Grammar, GrammarContext, Vector{Int64}, Union{Nothing, HoleReference}}","page":"HerbConstraints.jl","title":"HerbConstraints.propagate","text":"Propagates the RequireOnLeft constraint. It removes every element from the domain that does not have a necessary  predecessor in the left subtree.\n\n\n\n\n\n","category":"method"},{"location":"HerbConstraints/#Index","page":"HerbConstraints.jl","title":"Index","text":"","category":"section"},{"location":"HerbConstraints/","page":"HerbConstraints.jl","title":"HerbConstraints.jl","text":"","category":"page"},{"location":"HerbSearch/#HerbSearch_docs","page":"HerbSearch.jl","title":"HerbSearch.jl Documentation","text":"","category":"section"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"CurrentModule=HerbSearch","category":"page"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"Modules = [HerbSearch]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbSearch/#HerbSearch.ContextSensitivePriorityEnumerator","page":"HerbSearch.jl","title":"HerbSearch.ContextSensitivePriorityEnumerator","text":"mutable struct ContextSensitivePriorityEnumerator <: ExpressionIterator\n\nEnumerates a context-free grammar starting at Symbol sym with respect to the grammar up to a given depth and a given size. The exploration is done using the given priority function for derivations, and the expand function for discovered nodes.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.ExpandFailureReason","page":"HerbSearch.jl","title":"HerbSearch.ExpandFailureReason","text":"@enum ExpandFailureReason limit_reached=1 already_complete=2\n\nRepresentation of the different reasons why expanding a partial tree failed.  Currently, there are two possible causes of the expansion failing:\n\nlimit_reached: The depth limit or the size limit of the partial tree would   be violated by the expansion\nalready_complete: There is no hole left in the tree, so nothing can be   expanded.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.ExpressionIterator","page":"HerbSearch.jl","title":"HerbSearch.ExpressionIterator","text":"abstract type ExpressionIterator\n\nAbstract super-type for all possible enumerators.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.GeneticSearchIterator","page":"HerbSearch.jl","title":"HerbSearch.GeneticSearchIterator","text":"GeneticSearchIterator{FitnessFunction,CrossOverFunction,MutationFunction,SelectParentsFunction,EvaluationFunction} <: ExpressionIterator\n\nDefines an ExpressionIterator using genetic search. \n\nConsists of:\n\ngrammar::ContextSensitiveGrammar: the grammar to search over\nexamples::Vector{<:Example}: a collection of examples defining the specification \nfitness::FitnessFunction: assigns a numerical value (fitness score) to each individual based on how closely it meets the desired objective\ncross_over::CrossOverFunction: combines the program from two parent individuals to create one or more offspring individuals\nmutation!::MutationFunction: mutates the program of an invididual\nselect_parents::SelectParentsFunction: selects two parents for the crossover\nevaluation_function::EvaluationFunction: interpreter to evaluate the individual programs\nstart_symbol::Symbol: defines the start symbol from which the search should be started\npopulation_size::Int64: number of inviduals in the population\nmutation_probability::Float64: probability of mutation for each individual\nmaximum_initial_population_depth::Int64: maximum depth of trees when population is initialized \n\nend\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.PriorityQueueItem","page":"HerbSearch.jl","title":"HerbSearch.PriorityQueueItem","text":"struct PriorityQueueItem\n\nRepresents an item in the priority enumerator priority queue. An item contains of:\n\ntree: A partial AST\nsize: The size of the tree. This is a cached value which prevents  having to traverse the entire tree each time the size is needed.\nconstraints: The local constraints that apply to this tree.   These constraints are enforced each time the tree is modified.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.PriorityQueueItem-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.PriorityQueueItem","text":"PriorityQueueItem(tree::AbstractRuleNode, size::Int)\n\nConstructs PriorityQueueItem given only a tree and the size, but no constraints.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.PropagateResult","page":"HerbSearch.jl","title":"HerbSearch.PropagateResult","text":"@enum PropagateResult tree_complete=1 tree_incomplete=2 tree_infeasible=3\n\nRepresentation of the possible results of a constraint propagation.  At the moment there are three possible outcomes:\n\ntree_complete: The propagation was applied successfully and the tree does not contain any holes anymore. Thus no constraints can be applied anymore.\ntree_incomplete: The propagation was applied successfully and the tree does contain more holes. Thus more constraints may be applied to further prune the respective domains.\ntree_infeasible: The propagation was succesful, but there are holes with empty domains. Hence, the tree is now infeasible.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#HerbSearch.StochasticSearchEnumerator","page":"HerbSearch.jl","title":"HerbSearch.StochasticSearchEnumerator","text":"Base.@kwdef struct StochasticSearchEnumerator <: ExpressionIterator\n\nA unified struct for the algorithms Metropolis Hastings, Very Large Scale Neighbourhood and Simulated Annealing. Each algorithm implements neighbourhood propose accept and temperature functions. Below the signiture of all this function is shown\n\nSignatures\n\n\n\nReturns a node location from the program that is the neighbourhood. It can also return other information using  dict\n\nneighbourhood(program::RuleNode, grammar::Grammar) -> (loc::NodeLocation, dict::Dict)\n\n\n\nProposes a list of programs using the location provided by neighbourhood and the dict.\n\npropose(current_program, loc::NodeLocation, grammar::Grammar, max_depth::Int64, dict::Dict) -> Iter[RuleNode]\n\n\n\nBased on the current program and possible cost and temperature it accepts the program or not. Usually we would always want to accept better programs but we might get stuck if we do so. That is why some implementations of the accept function accept with a probability  costs that are worse.  cost means how different are the outcomes of the program compared to the correct outcomes. The lower the cost the better the program performs on the examples. The cost is provided by the cost_function\n\naccept(current_cost::Real, possible_cost::Real, temperature::Real) -> Bool\n\n\n\nReturns the new temperature based on the previous temperature. Higher the temperature means that the algorithm will explore more.\n\ntemperature(previous_temperature::Real) -> Real\n\n\n\nReturns the cost of the current program. It receives a list of tuples (expected, found) and gives back a cost.\n\ncost_function(outcomes::Tuple{<:Number,<:Number}[]) -> Real\n\n\n\nFields\n\ngrammar::ContextSensitiveGrammar grammar that the algorithm uses\nmax_depth::Int64 = 5  maximum depth of the program to generate\nexamples::Vector{Example} example used to check the program\nneighbourhood::Function \npropose::Function\naccept::Function\ntemperature::Function\ncost_function::Function\nstart_symbol::Symbol the start symbol of the algorithm :Real or :Int\ninitial_temperature::Real = 1 \nevaluation_function::Function that evaluates the julia expressions\n\nAn iterator over all possible expressions of a grammar up to max_depth with start symbol sym.\n\n\n\n\n\n","category":"type"},{"location":"HerbSearch/#Base.iterate-Tuple{ContextSensitivePriorityEnumerator, DataStructures.PriorityQueue}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::ContextSensitivePriorityEnumerator, pq::DataStructures.PriorityQueue)\n\nDescribes the iteration for a given ContextSensitivePriorityEnumerator and a PriorityQueue over the grammar without enqueueing new items to the priority queue. Recursively returns the result for the priority queue.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{ContextSensitivePriorityEnumerator}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::ContextSensitivePriorityEnumerator)\n\nDescribes the iteration for a given ContextSensitivePriorityEnumerator over the grammar. The iteration constructs a PriorityQueue first and then prunes it propagating the active constraints. Recursively returns the result for the priority queue.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{HerbSearch.GeneticSearchIterator, HerbSearch.GeneticIteratorState}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::GeneticSearchIterator, current_state::GeneticIteratorState)\n\nIterates the search space using a genetic algorithm. Takes the iterator and the current state to mutate and crossover random inviduals. Returns the best program-so-far and the state of the iterator.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{HerbSearch.GeneticSearchIterator}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::GeneticSearchIterator)\n\nIterates the search space using a genetic algorithm. First generates a population sampling random programs. Returns the best program-so-far, and the state of the iterator.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.iterate-Tuple{HerbSearch.StochasticSearchEnumerator, HerbSearch.IteratorState}","page":"HerbSearch.jl","title":"Base.iterate","text":"Base.iterate(iter::StochasticSearchEnumerator, current_state::IteratorState)\n\nThe algorithm that constructs the iterator of StochasticSearchEnumerator. It has the following structure:\n\nget a random node location -> location,dict = neighbourhood(current_program)\ncall propose on the current program getting a list of possbile replacements in the node location \niterate through all the possible replacements and perform the replacement in the current program \naccept the new program by modifying the next_program or reject the new program\nreturn the new next_program\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#Base.rand","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::Grammar, typ::Symbol, dmap::AbstractVector{Int}, max_depth::Int=10)\n\nGenerates a random RuleNode, i.e. an expression tree, of root type typ and maximum depth max_depth guided by a depth map dmap if possible.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#Base.rand-2","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::Grammar, typ::Symbol, max_depth::Int=10)\n\nGenerates a random RuleNode of return type typ and maximum depth max_depth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#Base.rand-3","page":"HerbSearch.jl","title":"Base.rand","text":"rand(::Type{RuleNode}, grammar::Grammar, max_depth::Int=10)\n\nGenerates a random RuleNode of arbitrary type and maximum depth max_depth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch._expand-Tuple{Hole, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}","page":"HerbSearch.jl","title":"HerbSearch._expand","text":"_expand(node::Hole, grammar::ContextSensitiveGrammar, ::Int, max_holes::Int, context::GrammarContext, hole_heuristic::Function, derivation_heuristic::Function)::Union{ExpandFailureReason, Vector{TreeConstraints}}\n\nExpands a given hole that was found in _expand using the given derivation heuristic. Returns the list of discovered nodes in that order and with their respective constraints.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch._expand-Tuple{RuleNode, ContextSensitiveGrammar, Int64, Int64, GrammarContext, Function, Function}","page":"HerbSearch.jl","title":"HerbSearch._expand","text":"_expand(root::RuleNode, grammar::ContextSensitiveGrammar, max_depth::Int, max_holes::Int, context::GrammarContext, hole_heuristic::Function, derivation_heuristic::Function)::Union{ExpandFailureReason, Vector{TreeConstraints}}\n\nRecursive expand function used in multiple enumeration techniques. Expands one hole/undefined leaf of the given RuleNode tree found using the given hole heuristic. If the expansion was successful, returns a list of new trees and a list of lists of hole locations, corresponding to the holes of each newly expanded tree.  Returns nothing if tree is already complete (i.e. contains no holes). Returns an empty list if the tree is partial (i.e. contains holes), but they could not be expanded because of the depth limit.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch._find_next_complete_tree-Tuple{ContextSensitiveGrammar, Int64, Int64, Function, Function, DataStructures.PriorityQueue}","page":"HerbSearch.jl","title":"HerbSearch._find_next_complete_tree","text":"_find_next_complete_tree(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, priority_function::Function, expand_function::Function, pq::PriorityQueue)::Union{Tuple{RuleNode, PriorityQueue}, Nothing}\n\nTakes a priority queue and returns the smallest AST from the grammar it can obtain from the queue or by (repeatedly) expanding trees that are in the queue. Returns nothing if there are no trees left within the depth limit.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.best_accept-Tuple{Real, Real, Any}","page":"HerbSearch.jl","title":"HerbSearch.best_accept","text":"best_accept(current_cost::Real, next_cost::Real, temperature)\n\nReturns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns false.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature; not used.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.calculate_cost-Tuple{RuleNode, Function, AbstractVector{Example}, Grammar, Function}","page":"HerbSearch.jl","title":"HerbSearch.calculate_cost","text":"calculate_cost(program::RuleNode, cost_function::Function, examples::AbstractVector{Example}, grammar::Grammar, evaluation_function::Function)\n\nReturns the cost of the program using the examples and the cost_function. It first convert the program to an expression and evaluates it on all the examples using HerbInterpret.evaluate_program.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.const_temperature-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.const_temperature","text":"const_temperature(current_temperature)\n\nReturns the temperature unchanged. This function is used by Metropolis Hastings and Very Large Neighbourhood Search algorithms.\n\nArguments\n\ncurrent_temperature::Real: the current temperature of the search.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.constructNeighbourhood-Tuple{RuleNode, Grammar}","page":"HerbSearch.jl","title":"HerbSearch.constructNeighbourhood","text":"constructNeighbourhood(current_program::RuleNode, grammar::Grammar)\n\nThe neighbourhood node location is chosen at random. The dictionary is nothing.\n\nArguments\n\ncurrent_program::RuleNode: the current program.\ngrammar::Grammar: the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.constructNeighbourhoodRuleSubset-Tuple{RuleNode, Grammar}","page":"HerbSearch.jl","title":"HerbSearch.constructNeighbourhoodRuleSubset","text":"constructNeighbourhoodRuleSubset(current_program::RuleNode, grammar::Grammar)\n\nThe neighbourhood node location is chosen at random. The dictionary is contains one entry with key \"rule_subset\" and value of type Vector{Any} being a random subset of grammar rules.\n\nArguments\n\ncurrent_program::RuleNode: the current program.\ngrammar::Grammar: the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.count_expressions-Tuple{ExpressionIterator}","page":"HerbSearch.jl","title":"HerbSearch.count_expressions","text":"count_expressions(iter::ExpressionIterator)\n\nCounts and returns the number of possible expressions in the expression iterator. The Iterator is not modified.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.count_expressions-Tuple{Grammar, Int64, Int64, Symbol}","page":"HerbSearch.jl","title":"HerbSearch.count_expressions","text":"count_expressions(grammar::Grammar, max_depth::Int, max_size::Int, sym::Symbol)\n\nCounts and returns the number of possible expressions of a grammar up to max_depth with start symbol sym.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.crossover_swap_children_1-Tuple{RuleNode, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.crossover_swap_children_1","text":"crossover_swap_children_1(parent1::RuleNode, parent2::RuleNode)\n\nPerforms a random crossover of two parents of type RuleNode. The subprograms are swapped and only one altered parent program is returned.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.crossover_swap_children_2-Tuple{RuleNode, RuleNode}","page":"HerbSearch.jl","title":"HerbSearch.crossover_swap_children_2","text":"crossover_swap_children_2(parent1::RuleNode, parent2::RuleNode)\n\nPerforms a random crossover of two parents of type RuleNode. The subprograms are swapped and both altered parent programs are returned.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.decreasing_temperature-Tuple{Real}","page":"HerbSearch.jl","title":"HerbSearch.decreasing_temperature","text":"decreasing_temperature(percentage::Real)\n\nReturns a function that produces a temperature decreased by percentage%. This function is used by the Simmulated Annealing algorithm.\n\nArguments\n\npercentage::Real: the percentage to decrease the temperature by.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.default_error_function-Tuple{Any, Any, Any}","page":"HerbSearch.jl","title":"HerbSearch.default_error_function","text":"default_error_function(old_error, output, expected_output)\n\nDefault error function for search_best.\n\n- old_error         - The existing total error\n- output            - The actual output of the evaluator\n- expected_output   - The expected output for the example\n\nThe default function returns 0 if the outputs match and 1 otherwise.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.default_fitness-Tuple{Any, Any}","page":"HerbSearch.jl","title":"HerbSearch.default_fitness","text":"default_fitness(program, results)\n\nDefines the default fitness function taking the program and its results. Results are a vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}. As we are looking for individuals with the highest fitness function, the error is inverted. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.enumerate_neighbours_propose-Tuple{Int64}","page":"HerbSearch.jl","title":"HerbSearch.enumerate_neighbours_propose","text":"enumerate_neighbours_propose(enumeration_depth::Int64)\n\nThe return function is a function that produces a list with all the subprograms with depth at most enumeration_depth.\n\nArguments\n\nenumeration_depth::Int64: the maximum enumeration depth.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.get_best_program-Tuple{Array{RuleNode}, HerbSearch.GeneticSearchIterator}","page":"HerbSearch.jl","title":"HerbSearch.get_best_program","text":"get_best_program(population::Array{RuleNode}, iter:: GeneticSearchIterator)::RuleNode\n\nReturns the best program within the population with respect to the fitness function.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.get_bfs_enumerator","page":"HerbSearch.jl","title":"HerbSearch.get_bfs_enumerator","text":"get_bfs_enumerator(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -> a)::ContextSensitivePriorityEnumerator\n\nReturns a breadth-first search enumerator given a ContextSensitiveGrammar. Returns trees in the grammar in increasing order of size. \n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.get_bfs_enumerator-2","page":"HerbSearch.jl","title":"HerbSearch.get_bfs_enumerator","text":"get_bfs_enumerator(grammar::ContextFreeGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -> a)::ContextSensitivePriorityEnumerator\n\nReturns a breadth-first search enumerator given a ContextFreeGrammar. Returns trees in the grammar in increasing order of size. \n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.get_dfs_enumerator","page":"HerbSearch.jl","title":"HerbSearch.get_dfs_enumerator","text":"get_dfs_enumerator(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -> a)::ContextSensitivePriorityEnumerator\n\nReturns a depth-first search enumerator given a ContextSensitiveGrammar. Returns trees in the grammar in decreasing order of size.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.get_dfs_enumerator-2","page":"HerbSearch.jl","title":"HerbSearch.get_dfs_enumerator","text":"get_dfs_enumerator(grammar::ContextFreeGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -> a)::ContextSensitivePriorityEnumerator\n\nReturns a depth-first search enumerator given a ContextFreeGrammar. Returns trees in the grammar in decreasing order of size.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.get_genetic_enumerator-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.get_genetic_enumerator","text":"get_genetic_enumerator(examples; fitness_function = HerbSearch.default_fitness, initial_population_size = 10, maximum_initial_population_depth = 3, mutation_probability = 0.1, cross_over = HerbSearch.crossover_swap_children_2, select_parents = HerbSearch.select_fitness_proportional_parents, evaluation_function::Function=HerbInterpret.test_with_input)\n\nReturns a GeneticSearchIterator given a grammar. The iterator is fitted against the examples provided evaluated using the fitness function. All other arguments are hyperparameters for the genetic search procedure.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.get_mh_enumerator","page":"HerbSearch.jl","title":"HerbSearch.get_mh_enumerator","text":"get_mh_enumerator(examples::AbstractArray{<:Example}, cost_function::Function, evaluation_function::Function=HerbInterpret.test_with_input)\n\nReturns an enumerator that runs according to the Metropolis Hastings algorithm.\n\nexamples : array of examples\ncost_function : cost function to evaluate the programs proposed\nevaluation_function : evaluation function that evaluates the program generated and produces an output \n\nThe propose function is randomfillpropose and the accept function is probabilistic. The temperature value of the algorithm remains constant over time. \n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.get_most_likely_first_enumerator","page":"HerbSearch.jl","title":"HerbSearch.get_most_likely_first_enumerator","text":"get_most_likely_first_enumerator(grammar::ContextSensitiveGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -> a)::ContextSensitivePriorityEnumerator\n\nReturns an enumerator that enumerates expressions in the grammar in decreasing order of probability. Only use this function with probabilistic grammars.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.get_most_likely_first_enumerator-2","page":"HerbSearch.jl","title":"HerbSearch.get_most_likely_first_enumerator","text":"get_most_likely_first_enumerator(grammar::ContextFreeGrammar, max_depth::Int, max_size::Int, sym::Symbol, hole_heuristic::Function=heuristic_leftmost, derivation_heuristic::Function=(a,_) -> a)::ContextSensitivePriorityEnumerator\n\nReturns an enumerator that enumerates expressions in the grammar in decreasing order of probability. Only use this function with probabilistic grammars.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.get_sa_enumerator","page":"HerbSearch.jl","title":"HerbSearch.get_sa_enumerator","text":"get_sa_enumerator(examples, cost_function, initial_temperature=1, temperature_decreasing_factor = 0.99, evaluation_function::Function=HerbInterpret.test_with_input)\n\nReturns an enumerator that runs according to the Very Large Scale Neighbourhood Search algorithm.\n\nexamples : array of examples\ncost_function : cost function to evaluate the programs proposed\ninitial_temperature : the starting temperature of the algorithm\ntemperature_decreasing_factor : the decreasing factor of the temperature of the time\nevaluation_function : evaluation function that evaluates the program generated and produces an output \n\nThe propose function is random_fill_propose (the same as for Metropolis Hastings). The accept function is probabilistic but takes into account the tempeerature too.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.get_vlsn_enumerator","page":"HerbSearch.jl","title":"HerbSearch.get_vlsn_enumerator","text":"get_vlsn_enumerator(examples, cost_function, enumeration_depth = 2, evaluation_function::Function=HerbInterpret.test_with_input)\n\nReturns an enumerator that runs according to the Very Large Scale Neighbourhood Search algorithm.\n\nexamples : array of examples\ncost_function : cost function to evaluate the programs proposed\nenumeration_depth : the enumeration depth to search for a best program at a time\nevaluation_function : evaluation function that evaluates the program generated and produces an output \n\nThe propose function consists of all possible programs of the given enumeration_depth. The accept function accepts the program with the lowest cost according to the cost_function. The temperature value of the algorithm remains constant over time. \n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.heuristic_leftmost-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_leftmost","text":"heuristic_leftmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where the left-most hole always gets considered first. Returns a HoleReference once a hole is found. This is the default option for enumerators.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_random-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_random","text":"heuristic_random(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where random holes get chosen randomly using random exploration. Returns a HoleReference once a hole is found.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_rightmost-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_rightmost","text":"heuristic_rightmost(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over holes, where the right-most hole always gets considered first. Returns a HoleReference once a hole is found. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.heuristic_smallest_domain-Tuple{AbstractRuleNode, Int64}","page":"HerbSearch.jl","title":"HerbSearch.heuristic_smallest_domain","text":"heuristic_smallest_domain(node::AbstractRuleNode, max_depth::Int)::Union{ExpandFailureReason, HoleReference}\n\nDefines a heuristic over all available holes in the unfinished AST, by considering the size of their respective domains. A domain here describes the number of possible derivations with respect to the constraints. Returns a HoleReference once a hole is found. \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.mean_squared_error-Tuple{T} where T<:(AbstractVector{<:Tuple{Number, Number}})","page":"HerbSearch.jl","title":"HerbSearch.mean_squared_error","text":"mean_squared_error(results::AbstractVector{Tuple{<:Number,<:Number}})\n\nReturns the mean squared error of results.\n\nArguments\n\nresults<:AbstractVector{<:Tuple{Number,Number}}: the vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.misclassification-Tuple{T} where T<:(AbstractVector{<:Tuple{Number, Number}})","page":"HerbSearch.jl","title":"HerbSearch.misclassification","text":"misclassification(results::AbstractVector{Tuple{<:Number,<:Number}})\n\nReturns the amount of misclassified examples, i.e. how many tuples with non-matching entries are there in results.\n\nArguments\n\nresults<:AbstractVector{<:Tuple{Number,Number}}: the vector of tuples, where each tuple is in the form Tuple{expected_output, actual_output}.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.most_likely_priority_function-Tuple{ContextSensitiveGrammar, AbstractRuleNode, Union{Real, Tuple{Vararg{Real}}}}","page":"HerbSearch.jl","title":"HerbSearch.most_likely_priority_function","text":"most_likely_priority_function(g::ContextSensitiveGrammar, tree::AbstractRuleNode, ::Union{Real, Tuple{Vararg{Real}}})\n\nCalculates logit for all possible derivations for a node in a tree and returns them.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.mse_error_function-Tuple{Any, Any, Any}","page":"HerbSearch.jl","title":"HerbSearch.mse_error_function","text":"mse_error_function(old_error, output, expected_output)\n\nMean squared error function for search_best.\n\n- old_error         - The existing total error\n- output            - The actual output of the evaluator\n- expected_output   - The expected output for the example\n\nThe function build the mean squared error from output and expected_output`.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.mutate_random!","page":"HerbSearch.jl","title":"HerbSearch.mutate_random!","text":"mutate_random!(program::RuleNode, grammar::Grammar, max_depth::Int64 = 2)\n\nMutates the given program by inserting a randomly generated sub-program at a random location.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept","text":"probabilistic_accept(current_cost::Real, next_cost::Real, temperature::Real)\n\nProbabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program. Returns True if the new program is accepted, False otherwise.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature; not used.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept_with_temperature-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept_with_temperature","text":"probabilistic_accept_with_temperature(current_cost::Real, next_cost::Real, temperature::Real)\n\nReturns true if the cost of the proposed program is smaller than the cost of the current program. Otherwise, returns true with the probability equal to: \n\n1  (1 + exp(delta  temperature))\n\nIn any other case, returns false.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the temperature of the search.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.probabilistic_accept_with_temperature_fraction-Tuple{Real, Real, Real}","page":"HerbSearch.jl","title":"HerbSearch.probabilistic_accept_with_temperature_fraction","text":"probabilistic_accept_with_temperature_fraction(current_cost::Real, program_to_consider_cost::Real, temperature::Real)\n\nProbabilistically decides whether to accept the new program (next) based on the ratio of costs (smaller is better) between the previous and new program multiplied by the temperature. Returns True if the new program is accepted, False otherwise.\n\nArguments\n\ncurrent_cost::Real: the cost of the current program.\nnext_cost::Real: the cost of the proposed program.\ntemperature::Real: the current temperature \n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.propagate_constraints","page":"HerbSearch.jl","title":"HerbSearch.propagate_constraints","text":"function propagate_constraints(root::AbstractRuleNode, grammar::ContextSensitiveGrammar, local_constraints::Set{LocalConstraint}, max_holes::Int, filled_hole::Union{HoleReference, Nothing}=nothing)::Tuple{PropagateResult, Set{LocalConstraint}}\n\nPropagates a set of local constraints recursively to all children of a given root node. As propagate_constraints gets often called when a hole was just filled, filled_hole helps keeping track to propagate the constraints to relevant nodes, e.g. children of filled_hole. max_holes makes sure that max_size of Base.iterate is not violated.  The function returns the PropagateResult and the set of relevant LocalConstraints.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#HerbSearch.random_fill_propose-Tuple{RuleNode, NodeLoc, Grammar, Int64, AbstractVector{Int64}, Union{Nothing, Dict{String, Any}}}","page":"HerbSearch.jl","title":"HerbSearch.random_fill_propose","text":"random_fill_propose(current_program, neighbourhood_node_loc, grammar, max_depth, dict)\n\nReturns a list with only one proposed, completely random, subprogram.\n\nArguments\n\ncurrent_program::RuleNode: the current program.\nneighbourhood_node_loc::NodeLoc: the location of the program to replace.\ngrammar::Grammar: the grammar used to create programs.\nmax_depth::Int: the maximum depth of the resulting programs.\ndmap::AbstractVector{Int} : the minimum possible depth to reach for each rule\ndict::Dict{String, Any}: the dictionary with additional arguments; not used.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.search-Tuple{Grammar, Problem, Symbol}","page":"HerbSearch.jl","title":"HerbSearch.search","text":"search(g::Grammar, problem::Problem, start::Symbol; evaluator::Function=test_with_input, enumerator::Function=get_bfs_enumerator, max_depth::Union{Int, Nothing}=nothing, max_size::Union{Int, Nothing}=nothing, max_time::Union{Int, Nothing}=nothing, max_enumerations::Union{Int, Nothing}=nothing, allow_evaluation_errors::Bool=false)::Union{Any, Nothing}\n\nSearches for a program by calling search_rulenode starting from Symbol start guided by enumerator and Grammar trying to satisfy  the higher-order constraints in form of input/output examples defined in the Problem.  This is the heart of the Herb's search for satisfying programs. Returns the found program when the evaluation calculated using evaluator is successful.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.search_best-Tuple{Grammar, Problem, Symbol}","page":"HerbSearch.jl","title":"HerbSearch.search_best","text":"search_best(g::Grammar, problem::Problem, start::Symbol; evaluator::Function=test_with_input, enumerator::Function=get_bfs_enumerator, error_function::Function=default_error_function, max_depth::Union{Int, Nothing}=nothing, max_size::Union{Int, Nothing}=nothing, max_time::Union{Int, Nothing}=nothing, max_enumerations::Union{Int, Nothing}=nothing, allow_evaluation_errors::Bool=false)::Tuple{Any, Real}\n\nSearches the grammar for the program that satisfies the maximum number of examples in the problem. The evaluator should be a function that takes a SymbolTable, expression and a dictionary with      input variable assignments and returns the output of the expression.\n\n- g                 - The grammar that defines the search space\n- problem           - The problem definition with IO examples\n- start             - The start symbol in the grammar\n- evaluator         - The evaluation function. Takes a SymbolTable, expression and a dictionary with \n                      input variable assignments and returns the output of the expression.\n- enumerator        - A constructor for the enumerator that should be used in the search\n- error_function    - The error function. Takes the existing total error, the actual output of the evaluator \n                      and the expected value for the example.\n- max_depth         - The maximum depth of the search\n- max_time          - The maximum time allowed for the search in seconds\n- max_enumerations  - The maximum number of programs to enumerate and test\n- allow_evaluation_errors - Whether the search should crash if an exception is thrown in the evaluation\n\nReturns a tuple with the best found program so far and the error.  Can be considerably slower than search due to having to evaluate each expression on each example.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.search_rulenode-Tuple{Grammar, Problem, Symbol}","page":"HerbSearch.jl","title":"HerbSearch.search_rulenode","text":"search_rulenode(g::Grammar, problem::Problem, start::Symbol; evaluator::Function=test_with_input, enumerator::Function=get_bfs_enumerator, max_depth::Union{Int, Nothing}=nothing, max_size::Union{Int, Nothing}=nothing, max_time::Union{Int, Nothing}=nothing, max_enumerations::Union{Int, Nothing}=nothing, allow_evaluation_errors::Bool=false)::Union{Tuple{RuleNode, Any}, Nothing}\n\nSearches the grammar for the program that satisfies the maximum number of examples in the problem.\n\n    - g                 - The grammar that defines the search space\n    - problem           - The problem definition with IO examples\n    - start             - The start symbol in the grammar\n    - evaluator         - The evaluation function. Takes a SymbolTable, expression and a dictionary with \n                          input variable assignments and returns the output of the expression.\n    - enumerator        - A constructor for the enumerator that should be used in the search\n    - max_depth         - The maximum depth of the search\n    - max_size          - The maximum number of nodes for ASTs in the search\n    - max_time          - The maximum time allowed for the search in seconds\n    - max_enumerations  - The maximum number of programs to enumerate and test'\n    - allow_evaluation_errors - Whether the search should crash if an exception is thrown in the evaluation\nReturns a tuple of the rulenode and the expression of the solution program once it has been found, \nor nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.select_chromosome-Tuple{Array{RuleNode}, Array{<:Real}}","page":"HerbSearch.jl","title":"HerbSearch.select_chromosome","text":"select_chromosome(population::Array{RuleNode}, fitness_array::Array{<:Real})::RuleNode\n\nSelects a chromosome (individual) from the population based on a fitness array. The function uses a fitness-proportionate selection strategy, often referred to as \"roulette wheel\" selection. Assumes fitness_array to be normalized already.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.select_fitness_proportional_parents-Tuple{Array{RuleNode}, Array{<:Real}}","page":"HerbSearch.jl","title":"HerbSearch.select_fitness_proportional_parents","text":"select_fitness_proportional_parents(population::Array{RuleNode}, fitness_array::Array{<:Real})::Tuple{RuleNode,RuleNode}\n\nSelects two parent chromosomes (individuals) from a population based on fitness-proportionate selection. The selected parents can be used for genetic crossover in the next steps of the algorithm.\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#HerbSearch.validate_iterator-Tuple{Any}","page":"HerbSearch.jl","title":"HerbSearch.validate_iterator","text":"validate_iterator(iter)\n\nValidates the parameters of the iterator\n\n\n\n\n\n","category":"method"},{"location":"HerbSearch/#StatsBase.sample","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(::Type{NodeLoc}, root::RuleNode, maxdepth::Int=typemax(Int))\n\nUniformly selects a random node in the tree no deeper than maxdepth using reservoir sampling. Returns a NodeLoc that specifies the location using its parent so that the subtree can be replaced.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-2","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(root::RuleNode, typ::Symbol, grammar::Grammar,\n                      maxdepth::Int=typemax(Int))\n\nUniformly selects a random node of the given return type typ limited by maxdepth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-3","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(::Type{NodeLoc}, root::RuleNode, typ::Symbol, grammar::Grammar)\n\nUniformly selects a random node in the tree of a given type, specified using its parent such that the subtree can be replaced. Returns a NodeLoc.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#StatsBase.sample-4","page":"HerbSearch.jl","title":"StatsBase.sample","text":"sample(root::RuleNode, typ::Symbol, grammar::Grammar, maxdepth::Int=typemax(Int))\n\nUniformly samples a random node from the tree limited to maxdepth.\n\n\n\n\n\n","category":"function"},{"location":"HerbSearch/#Index","page":"HerbSearch.jl","title":"Index","text":"","category":"section"},{"location":"HerbSearch/","page":"HerbSearch.jl","title":"HerbSearch.jl","text":"","category":"page"},{"location":"install/#Installation-Guide","page":"Installation Guide","title":"Installation Guide","text":"","category":"section"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Before installing Herb.jl, ensure that you have a running Julia distribution installed (Julia version 1.7 and above were tested). ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"Thanks to Julia's package management, installing Herb.jl is very straighforward.  Activate the default Julia REPL using","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"julia","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"or from within one of your projects using","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"julia --project=.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"From the Julia REPL run ","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"]\nadd Herb","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"or instead running","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"import Pkg\nPkg.add(\"Herb\")","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"which will both install all dependencies automatically.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"For later convenience we can also add the respective dependencies to our project, so that we do not have to write Herb.HerbGrammar every time.","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"] add HerbConstraints HerbCore HerbData HerbInterpret HerbGrammar HerbSearch","category":"page"},{"location":"install/","page":"Installation Guide","title":"Installation Guide","text":"And just like this you are done! Welcome to Herb.jl!","category":"page"},{"location":"HerbInterpret/#HerbInterpret_docs","page":"HerbInterpret.jl","title":"HerbInterpret.jl Documentation","text":"","category":"section"},{"location":"HerbInterpret/","page":"HerbInterpret.jl","title":"HerbInterpret.jl","text":"CurrentModule=HerbInterpret","category":"page"},{"location":"HerbInterpret/","page":"HerbInterpret.jl","title":"HerbInterpret.jl","text":"Modules = [HerbInterpret]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbInterpret/#HerbInterpret.evaluate_program-Tuple{RuleNode, Vector{<:Example}, Grammar, Function}","page":"HerbInterpret.jl","title":"HerbInterpret.evaluate_program","text":"evaluate_program(program::RuleNode, examples::Vector{<:Example}, grammar::Grammar, evaluation_function::Function)\n\nRuns a program on the examples and returns tuples of actual desired output and the program's output\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.execute_on_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Dict{Symbol, Any}}}","page":"HerbInterpret.jl","title":"HerbInterpret.execute_on_examples","text":"execute_on_examples(tab::SymbolTable, expr::Any, example_inputs::Vector{Dict{Symbol, Any}})::Vector{Any}\n\nExecutes a given expression on a set of inputs and returns the respective outputs. WARNING: This function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.interpret-Tuple{Dict{Symbol, Any}, Any}","page":"HerbInterpret.jl","title":"HerbInterpret.interpret","text":"interpret(tab::SymbolTable, ex::Expr)\n\nEvaluates an expression without compiling it. Uses AST and symbol lookups. Only supports :call and :(=) expressions at the moment.\n\nExample usage:\n\ntab = SymbolTable(:f => f, :x => x)\nex = :(f(x))\ninterpret(tab, ex)\n\nWARNING: This function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.test_all_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Example}}","page":"HerbInterpret.jl","title":"HerbInterpret.test_all_examples","text":"test_all_examples(tab::SymbolTable, expr::Any, examples::Vector{Example})::Vector{Bool}\n\nRuns the interpreter on all examples with the given input table and expression.  The symbol table defines everything (functions, symbols) that are not input variables to the program to be synthesised. Returns a list of true/false values indicating if the expression satisfies the corresponding example. WARNING: This function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.test_examples-Tuple{Dict{Symbol, Any}, Any, Vector{Example}}","page":"HerbInterpret.jl","title":"HerbInterpret.test_examples","text":"test_examples(tab::SymbolTable, expr::Any, examples::Vector{Example})::Bool\n\nEvaluates all examples and returns true iff all examples pass. Shortcircuits as soon as an example is found for which the program doesn't work.  Returns false if one of the examples produces an error.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#HerbInterpret.test_with_input-Tuple{Dict{Symbol, Any}, Any, Dict}","page":"HerbInterpret.jl","title":"HerbInterpret.test_with_input","text":"test_with_input(tab::SymbolTable, expr::Any, input::Dict)\n\nInterprets an expression or symbol with the given symboltable and the input. WARNING: This function throws exceptions that are caused in the given expression. These exceptions have to be handled by the caller of this function.\n\n\n\n\n\n","category":"method"},{"location":"HerbInterpret/#Index","page":"HerbInterpret.jl","title":"Index","text":"","category":"section"},{"location":"HerbInterpret/","page":"HerbInterpret.jl","title":"HerbInterpret.jl","text":"","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"CurrentModule=Herb","category":"page"},{"location":"#[Herb.jl](https://github.com/Herb-AI/Herb.jl)","page":"Herb.jl","title":"Herb.jl","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"A library for defining and efficiently solving program synthesis tasks in Julia.","category":"page"},{"location":"#Why-Herb.jl?","page":"Herb.jl","title":"Why Herb.jl?","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"When writing research software we almost always investigate highly specific properties or algorithms of our domain, leading to us building the tools from scratch over and over again. The very same holds for the field of program synthesis: Tools are hard to run, benchmarks are hard to get and prepare, and its hard to adapt our existing code to a novel idea.","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl will take care of this for you and helps you defining, solving and extending your program synthesis problems.","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl provides...","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"a unified and universal framework for program synthesis\nHerb.jl allows you to describe all sorts of program synthesis problems using context-free grammars\na number of state-of-the-art benchmarks and solvers already implemented and usable out-of-the-box","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb.jl's sub-packages provide fast and easily extendable implementations of ","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"various static and dynamic search strategies,\nlearning search strategies, sampling techniques and more,\nconstraint formulation and propagation, \neasy grammar formulation and usage,\nwide-range of usable program interpreters and languages + the possibility to use your own, and \nefficient data formulation.","category":"page"},{"location":"#Why-Julia?","page":"Herb.jl","title":"Why Julia?","text":"","category":"section"},{"location":"#Sub-Modules","page":"Herb.jl","title":"Sub-Modules","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Herb's functionality is distributed among several sub-packages:","category":"page"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"HerbCore.jl: The core of Herb.jl defining core concepts to avoid circular dependencies.\nHerbGrammar.jl:\nHerbData.jl:\nHerbInterpret.jl:\nHerbSearch.jl:\nHerbConstraints.jl:","category":"page"},{"location":"#Basics","page":"Herb.jl","title":"Basics","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"Pages = [\"install.md\", \"get_started.md\", \"concepts.md\"]","category":"page"},{"location":"#Advanced-content","page":"Herb.jl","title":"Advanced content","text":"","category":"section"},{"location":"","page":"Herb.jl","title":"Herb.jl","text":"","category":"page"},{"location":"HerbCore/#HerbCore_docs","page":"HerbCore.jl Documentation","title":"HerbCore.jl Documentation","text":"","category":"section"},{"location":"HerbCore/","page":"HerbCore.jl Documentation","title":"HerbCore.jl Documentation","text":"CurrentModule=HerbCore","category":"page"},{"location":"HerbCore/","page":"HerbCore.jl Documentation","title":"HerbCore.jl Documentation","text":"Modules = [HerbCore]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbCore/#HerbCore.AbstractRuleNode","page":"HerbCore.jl Documentation","title":"HerbCore.AbstractRuleNode","text":"AbstractRuleNode\n\nAbstract type for representing expression trees. Expression trees consist of RuleNodes and Holes.\n\nA RuleNode represents a certain production rule in the Grammar.\nA Hole is a placeholder where certain rules in the grammar still can be applied. \n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.Constraint","page":"HerbCore.jl Documentation","title":"HerbCore.Constraint","text":"Represents a constraint for a ContextSensitiveGrammar. Concrete implementations can be found in HerbConstraints.jl.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.Grammar","page":"HerbCore.jl Documentation","title":"HerbCore.Grammar","text":"Grammar\n\nAbstract type representing all grammars. It is assumed that all grammar structs have at least the following attributes:\n\nrules::Vector{Any}: A list of RHS of rules (subexpressions).\ntypes::Vector{Symbol}: A list of LHS of rules (types, all symbols).\nisterminal::BitVector: A bitvector where bit i represents whether rule i is terminal.\niseval::BitVector: A bitvector where bit i represents whether rule i is an eval rule.\nbytype::Dict{Symbol,Vector{Int}}: A dictionary that maps a type to all rules of said type.\ndomains::Dict{Symbol, BitVector}: A dictionary that maps a type to a domain bitvector.  The domain bitvector has bit i set to true iff the ith rule is of this type.\nchildtypes::Vector{Vector{Symbol}}: A list of types of the children for each rule. \n\nIf a rule is terminal, the corresponding list is empty.\n\nlog_probabilities::Union{Vector{Real}, Nothing}: A list of probabilities for each rule. \n\nIf the grammar is non-probabilistic, the list can be nothing.\n\nFor concrete types, see ContextFreeGrammar and ContextSensitiveGrammar.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.Hole","page":"HerbCore.jl Documentation","title":"HerbCore.Hole","text":"Hole <: AbstractRuleNode\n\nA Hole is a placeholder where certain rules from the grammar can still be applied. The domain of a Hole defines which rules can be applied. The domain is a bitvector, where the ith bit is set to true if the ith rule in the grammar can be applied. \n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.HoleReference","page":"HerbCore.jl Documentation","title":"HerbCore.HoleReference","text":"HoleReference\n\nContains a hole and the path to the hole from the root of the tree.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.RuleNode","page":"HerbCore.jl Documentation","title":"HerbCore.RuleNode","text":"RuleNode <: AbstractRuleNode\n\nA RuleNode represents a node in an expression tree. Each node corresponds to a certain rule in the Grammar. A RuleNode consists of:\n\nind: The index of the rule in the Grammar which this node is representing.\n_val: Field for storing immediately evaluated values\nchildren: The children of this node in the expression tree\n\ncompat: Compat\nEvaluate immediately functionality is not yet supported by most of Herb.jl.\n\n\n\n\n\n","category":"type"},{"location":"HerbCore/#HerbCore.RuleNode-Tuple{Int64, Any}","page":"HerbCore.jl Documentation","title":"HerbCore.RuleNode","text":"RuleNode(ind::Int, _val::Any)\n\nCreate a RuleNode for the Grammar rule with index ind,  _val as immediately evaluated value and no children\n\nwarning: Warning\nOnly use this constructor if you are absolutely certain that a rule is terminal and cannot have children. Use [RuleNode(ind::Int, grammar::Grammar)] for rules that might have children. In general, Holes should be used as a placeholder when the children of a node are not yet known.   \n\ncompat: Compat\nEvaluate immediately functionality is not yet supported by most of Herb.jl.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.RuleNode-Tuple{Int64, Vector{AbstractRuleNode}}","page":"HerbCore.jl Documentation","title":"HerbCore.RuleNode","text":"RuleNode(ind::Int, children::Vector{AbstractRuleNode})\n\nCreate a RuleNode for the Grammar rule with index ind and children as subtrees.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#Base.isless-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbCore.jl Documentation","title":"Base.isless","text":"Base.isless(rn₁::AbstractRuleNode, rn₂::AbstractRuleNode)::Bool\n\nCompares two RuleNodes. Returns true if the left RuleNode is less than the right RuleNode. Order is determined from the index of the RuleNodes.  If both RuleNodes have the same index, a depth-first search is  performed in both RuleNodes until nodes with a different index are found.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#Base.length-Tuple{Hole}","page":"HerbCore.jl Documentation","title":"Base.length","text":"Base.length(root::RuleNode)\n\nReturn the number of nodes in the tree rooted at root. Holes don't count.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#Base.length-Tuple{RuleNode}","page":"HerbCore.jl Documentation","title":"Base.length","text":"Base.length(root::RuleNode)\n\nReturn the number of nodes in the tree rooted at root. Holes don't count.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.contains_hole-Tuple{RuleNode}","page":"HerbCore.jl Documentation","title":"HerbCore.contains_hole","text":"contains_hole(rn::RuleNode) = any(contains_hole(c) for c ∈ rn.children)\n\nChecks if an AbstractRuleNode tree contains a Hole.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.depth-Tuple{RuleNode}","page":"HerbCore.jl Documentation","title":"HerbCore.depth","text":"depth(root::RuleNode)::Int\n\nReturn the depth of the AbstractRuleNode tree rooted at root. Holes don't count towards the depth.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_node_at_location-Tuple{RuleNode, Vector{Int64}}","page":"HerbCore.jl Documentation","title":"HerbCore.get_node_at_location","text":"get_node_at_location(root::RuleNode, location::Vector{Int})\n\nRetrieves a RuleNode at the given location by reference. \n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.get_rulesequence-Tuple{RuleNode, Vector{Int64}}","page":"HerbCore.jl Documentation","title":"HerbCore.get_rulesequence","text":"get_rulesequence(node::RuleNode, path::Vector{Int})\n\nExtract the derivation sequence from a path (sequence of child indices) and an AbstractRuleNode. If the path is deeper than the deepest node, it returns what it has.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.node_depth-Tuple{AbstractRuleNode, AbstractRuleNode}","page":"HerbCore.jl Documentation","title":"HerbCore.node_depth","text":"node_depth(root::AbstractRuleNode, node::AbstractRuleNode)::Int\n\nReturn the depth of node for an AbstractRuleNode tree rooted at root. Depth is 1 when root == node.\n\nwarning: Warning\nnode must be a subtree of root in order for this function to work.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.rulesoftype-Tuple{RuleNode, Set{Int64}}","page":"HerbCore.jl Documentation","title":"HerbCore.rulesoftype","text":"rulesoftype(node::RuleNode, ruleset::Set{Int})\n\nReturns every rule in the ruleset that is also used in the AbstractRuleNode tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.rulesonleft-Tuple{RuleNode, Vector{Int64}}","page":"HerbCore.jl Documentation","title":"HerbCore.rulesonleft","text":"rulesonleft(expr::RuleNode, path::Vector{Int})::Set{Int}\n\nFinds all rules that are used in the left subtree defined by the path.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}","page":"HerbCore.jl Documentation","title":"HerbCore.swap_node","text":"swap_node(expr::AbstractRuleNode, new_expr::AbstractRuleNode, path::Vector{Int})\n\nReplace a node in expr, specified by path, with new_expr. Path is a sequence of child indices, starting from the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#HerbCore.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}","page":"HerbCore.jl Documentation","title":"HerbCore.swap_node","text":"swap_node(expr::RuleNode, node::RuleNode, child_index::Int, new_expr::RuleNode)\n\nReplace child i of a node, a part of larger expr, with new_expr.\n\n\n\n\n\n","category":"method"},{"location":"HerbCore/#Index","page":"HerbCore.jl Documentation","title":"Index","text":"","category":"section"},{"location":"HerbCore/","page":"HerbCore.jl Documentation","title":"HerbCore.jl Documentation","text":"","category":"page"},{"location":"HerbGrammar/#HerbGrammar_docs","page":"HerbGrammar.jl","title":"HerbGrammar.jl Documentation","text":"","category":"section"},{"location":"HerbGrammar/","page":"HerbGrammar.jl","title":"HerbGrammar.jl","text":"CurrentModule=HerbGrammar","category":"page"},{"location":"HerbGrammar/","page":"HerbGrammar.jl","title":"HerbGrammar.jl","text":"Modules = [HerbGrammar]\nOrder   = [:type, :const, :macro, :function]","category":"page"},{"location":"HerbGrammar/#HerbGrammar.ContextFreeGrammar","page":"HerbGrammar.jl","title":"HerbGrammar.ContextFreeGrammar","text":"ContextFreeGrammar <: Grammar\n\nRepresents a context-free grammar and its production rules. Consists of:\n\nrules::Vector{Any}: A list of RHS of rules (subexpressions).\ntypes::Vector{Symbol}: A list of LHS of rules (types, all symbols).\nisterminal::BitVector: A bitvector where bit i represents whether rule i is terminal.\niseval::BitVector: A bitvector where bit i represents whether rule i is an eval rule.\nbytype::Dict{Symbol,Vector{Int}}: A dictionary that maps a type to all rules of said type.\ndomains::Dict{Symbol, BitVector}: A dictionary that maps a type to a domain bitvector.  The domain bitvector has bit i set to true iff the ith rule is of this type.\nchildtypes::Vector{Vector{Symbol}}: A list of types of the children for each rule.  If a rule is terminal, the corresponding list is empty.\nlog_probabilities::Union{Vector{Real}, Nothing}: A list of probabilities for each rule.  If the grammar is non-probabilistic, the list can be nothing.\n\nUse the @cfgrammar macro to create a ContextFreeGrammar object. Use the @pcfgrammar macro to create a ContextFreeGrammar object with probabilities. For context-sensitive grammars, see ContextSensitiveGrammar.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.ContextSensitiveGrammar","page":"HerbGrammar.jl","title":"HerbGrammar.ContextSensitiveGrammar","text":"ContextSensitiveGrammar <: Grammar\n\nRepresents a context-sensitive grammar. Extends Grammar with constraints.\n\nConsists of:\n\nrules::Vector{Any}: A list of RHS of rules (subexpressions).\ntypes::Vector{Symbol}: A list of LHS of rules (types, all symbols).\nisterminal::BitVector: A bitvector where bit i represents whether rule i is terminal.\niseval::BitVector: A bitvector where bit i represents whether rule i is an eval rule.\nbytype::Dict{Symbol,Vector{Int}}: A dictionary that maps a type to all rules of said type.\ndomains::Dict{Symbol, BitVector}: A dictionary that maps a type to a domain bitvector.  The domain bitvector has bit i set to true iff the ith rule is of this type.\nchildtypes::Vector{Vector{Symbol}}: A list of types of the children for each rule.  If a rule is terminal, the corresponding list is empty.\nlog_probabilities::Union{Vector{Real}, Nothing}: A list of probabilities for each rule.  If the grammar is non-probabilistic, the list can be nothing.\nconstraints::Vector{Constraint}: A list of constraints that programs in this grammar have to abide.\n\nUse the @csgrammar macro to create a ContextSensitiveGrammar object. Use the @pcsgrammar macro to create a ContextSensitiveGrammar object with probabilities. For context-free grammars, see ContextFreeGrammar.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.NodeLoc","page":"HerbGrammar.jl","title":"HerbGrammar.NodeLoc","text":"NodeLoc A helper struct that points to a node in the tree via its parent such that the child can be easily swapped out. If i is 0 the node pointed to is the root node and parent is the node itself.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.SymbolTable","page":"HerbGrammar.jl","title":"HerbGrammar.SymbolTable","text":"SymbolTable(grammar::Grammar, mod::Module=Main)\n\nReturns a SymbolTable populated with a mapping from symbols in the  Grammar to symbols in module mod or Main, if defined.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.SymbolTable-2","page":"HerbGrammar.jl","title":"HerbGrammar.SymbolTable","text":"SymbolTable\n\nData structure for mapping terminal symbols in the Grammar to their Julia interpretation.\n\n\n\n\n\n","category":"type"},{"location":"HerbGrammar/#HerbGrammar.@cfgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@cfgrammar","text":"@cfgrammar\n\nA macro for defining a ContextFreeGrammar. \n\nExample usage:\n\ngrammar = @cfgrammar begin\n\tR = x\n\tR = 1 | 2\n\tR = R + R\nend\n\nSyntax:\n\nLiterals: Symbols that are already defined in Julia are considered literals, such as 1, 2, or π. For example: R = 1.\nVariables: A variable is a symbol that is not a nonterminal symbol and not already defined in Julia. For example: R = x.\nFunctions: Functions and infix operators that are defined in Julia or the Main module can be used  with the default evaluator. For example: R = R + R, R = f(a, b).\nCombinations: Multiple rules can be defined on a single line in the grammar definition using the | symbol. For example: R = 1 | 2 | 3.\nIterators: Another way to define multiple rules is by providing a Julia iterator after a | symbol. For example: R = |(1:9).\n\nRelated:\n\n@csgrammar uses the same syntax to create ContextSensitiveGrammars.\n@pcfgrammar uses a similar syntax to create probabilistic ContextFreeGrammars.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#HerbGrammar.@csgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@csgrammar","text":"@csgrammar\n\nA macro for defining a ContextSensitiveGrammar.  Constraints can be added afterwards using the addconstraint! function.\n\nExample usage:\n\ngrammar = @csgrammar begin\n\tR = x\n\tR = 1 | 2\n\tR = R + R\nend\n\nSyntax:\n\nLiterals: Symbols that are already defined in Julia are considered literals, such as 1, 2, or π. For example: R = 1.\nVariables: A variable is a symbol that is not a nonterminal symbol and not already defined in Julia. For example: R = x.\nFunctions: Functions and infix operators that are defined in Julia or the Main module can be used  with the default evaluator. For example: R = R + R, R = f(a, b).\nCombinations: Multiple rules can be defined on a single line in the grammar definition using the | symbol. For example: R = 1 | 2 | 3.\nIterators: Another way to define multiple rules is by providing a Julia iterator after a | symbol. For example: R = |(1:9).\n\nRelated:\n\n@cfgrammar uses the same syntax to create ContextFreeGrammars.\n@pcsgrammar uses a similar syntax to create probabilistic ContextSensitiveGrammars.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#HerbGrammar.@pcfgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@pcfgrammar","text":"@pcfgrammar\n\nA macro for defining a probabilistic ContextFreeGrammar. \n\nExample usage:\n\ngrammar = @pcfgrammar begin\n\t0.5 : R = x\n\t0.3 : R = 1 | 2\n\t0.2 : R = R + R\nend\n\nSyntax:\n\nThe syntax of rules is identical to the syntax used by @cfgrammar:\n\nLiterals: Symbols that are already defined in Julia are considered literals, such as 1, 2, or π. For example: R = 1.\nVariables: A variable is a symbol that is not a nonterminal symbol and not already defined in Julia. For example: R = x.\nFunctions: Functions and infix operators that are defined in Julia or the Main module can be used  with the default evaluator. For example: R = R + R, R = f(a, b).\nCombinations: Multiple rules can be defined on a single line in the grammar definition using the | symbol. For example: R = 1 | 2 | 3.\nIterators: Another way to define multiple rules is by providing a Julia iterator after a | symbol. For example: R = |(1:9).\n\nEvery rule is also prefixed with a probability. Rules and probabilities are separated using the : symbol. If multiple rules are defined on a single line, the probability is equally divided between the rules. The sum of probabilities for all rules of a certain non-terminal symbol should be equal to 1.  The probabilities are automatically scaled if this isn't the case.\n\nRelated:\n\n@pcsgrammar uses the same syntax to create probabilistic ContextSensitiveGrammars.\n@cfgrammar uses a similar syntax to create non-probabilistic ContextFreeGrammars.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#HerbGrammar.@pcsgrammar-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.@pcsgrammar","text":"@pcsgrammar\n\nA macro for defining a probabilistic ContextSensitiveGrammar. \n\nExample usage:\n\ngrammar = @pcsgrammar begin\n\t0.5 : R = x\n\t0.3 : R = 1 | 2\n\t0.2 : R = R + R\nend\n\nSyntax:\n\nThe syntax of rules is identical to the syntax used by @csgrammar:\n\nLiterals: Symbols that are already defined in Julia are considered literals, such as 1, 2, or π. For example: R = 1.\nVariables: A variable is a symbol that is not a nonterminal symbol and not already defined in Julia. For example: R = x.\nFunctions: Functions and infix operators that are defined in Julia or the Main module can be used  with the default evaluator. For example: R = R + R, R = f(a, b).\nCombinations: Multiple rules can be defined on a single line in the grammar definition using the | symbol. For example: R = 1 | 2 | 3.\nIterators: Another way to define multiple rules is by providing a Julia iterator after a | symbol. For example: R = |(1:9).\n\nEvery rule is also prefixed with a probability. Rules and probabilities are separated using the : symbol. If multiple rules are defined on a single line, the probability is equally divided between the rules. The sum of probabilities for all rules of a certain non-terminal symbol should be equal to 1.  The probabilities are automatically scaled if this isn't the case.\n\nRelated:\n\n@pcfgrammar uses the same syntax to create probabilistic ContextFreeGrammars.\n@csgrammar uses a similar syntax to create non-probabilistic ContextSensitiveGrammars.\n\n\n\n\n\n","category":"macro"},{"location":"HerbGrammar/#Base.get-Tuple{RuleNode, NodeLoc}","page":"HerbGrammar.jl","title":"Base.get","text":"get(root::RuleNode, loc::NodeLoc) Obtain the node pointed to by loc.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#Base.insert!-Tuple{RuleNode, NodeLoc, RuleNode}","page":"HerbGrammar.jl","title":"Base.insert!","text":"insert!(loc::NodeLoc, rulenode::RuleNode) Replaces the subtree pointed to by loc with the given rulenode.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.add_rule!-Tuple{Grammar, Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.add_rule!","text":"add_rule!(g::Grammar, e::Expr)\n\nAdds a rule to the grammar. \n\nUsage:\n\n\tadd_rule!(grammar, :(\"Real = Real + Real\"))\n\nThe syntax is identical to the syntax of @csgrammar and @cfgrammar, but only single rules are supported.\n\nwarning: Warning\nCalls to this function are ignored if a rule is already in the grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.addconstraint!-Tuple{ContextSensitiveGrammar, Constraint}","page":"HerbGrammar.jl","title":"HerbGrammar.addconstraint!","text":"addconstraint!(grammar::ContextSensitiveGrammar, c::Constraint)\n\nAdds a Constraint to a ContextSensitiveGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.cfg2csg-Tuple{ContextFreeGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.cfg2csg","text":"cfg2csg(g::ContextFreeGrammar)::ContextSensitiveGrammar\n\nConverts a ContextFreeGrammar to a ContextSensitiveGrammar without any Constraints.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.child_types-Tuple{Grammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.child_types","text":"child_types(grammar::Grammar, rule_index::Int)\n\nReturns the types of the children (nonterminals) of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.child_types-Tuple{Grammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.child_types","text":"child_types(grammar::Grammar, node::RuleNode)\n\nReturns the list of child types (nonterminal symbols) in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.cleanup_removed_rules!-Tuple{Grammar}","page":"HerbGrammar.jl","title":"HerbGrammar.cleanup_removed_rules!","text":"cleanup_removed_rules!(g::Grammar)\n\nRemoves any placeholders for previously deleted rules.  This means that indices get shifted.\n\nwarning: Warning\nWhen indices are shifted, this grammar can no longer be used to interpret  AbstractRuleNode trees created before the call to this function. These trees become meaningless. \n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.clearconstraints!-Tuple{ContextSensitiveGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.clearconstraints!","text":"Clear all constraints from the grammar\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.containedin-Tuple{Vector, Vector}","page":"HerbGrammar.jl","title":"HerbGrammar.containedin","text":"containedin(vec1::Vector, vec2::Vector)\n\nChecks if elements of vec1 are contained in vec2 in the same order (possibly with elements in between)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.contains_returntype","page":"HerbGrammar.jl","title":"HerbGrammar.contains_returntype","text":"contains_returntype(node::RuleNode, grammar::Grammar, sym::Symbol, maxdepth::Int=typemax(Int))\n\nReturns true if the tree rooted at node contains at least one node at depth less than maxdepth with the given return type or nonterminal symbol.\n\n\n\n\n\n","category":"function"},{"location":"HerbGrammar/#HerbGrammar.expr2cfgrammar-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2cfgrammar","text":"expr2cfgrammar(ex::Expr)::ContextFreeGrammar\n\nA function for converting an Expr to a ContextFreeGrammar. If the expression is hardcoded, you should use the @cfgrammar macro. Only expressions in the correct format (see @cfgrammar) can be converted.\n\nExample usage:\n\ngrammar = expr2cfgrammar(\n\tbegin\n\t\tR = x\n\t\tR = 1 | 2\n\t\tR = R + R\n\tend\n)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2csgrammar-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2csgrammar","text":"expr2csgrammar(ex::Expr)::ContextSensitiveGrammar\n\nA function for converting an Expr to a ContextSensitiveGrammar. If the expression is hardcoded, you should use the @csgrammar macro. Only expressions in the correct format (see @csgrammar) can be converted.\n\nExample usage:\n\ngrammar = expr2csgrammar(\n\tbegin\n\t\tR = x\n\t\tR = 1 | 2\n\t\tR = R + R\n\tend\n)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2pcfgrammar-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2pcfgrammar","text":"Function for converting an Expr to a ContextFreeGrammar with probabilities. If the expression is hardcoded, you should use the @pcfgrammar macro. Only expressions in the correct format (see @pcfgrammar) can be converted.\n\nExample usage:\n\ngrammar = expr2pcsgrammar(\n\tbegin\n\t\t0.5 : R = x\n\t\t0.3 : R = 1 | 2\n\t\t0.2 : R = R + R\n\tend\n)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.expr2pcsgrammar-Tuple{Expr}","page":"HerbGrammar.jl","title":"HerbGrammar.expr2pcsgrammar","text":"Function for converting an Expr to a ContextSensitiveGrammar with probabilities. If the expression is hardcoded, you should use the @pcsgrammar macro. Only expressions in the correct format (see @pcsgrammar) can be converted.\n\nExample usage:\n\ngrammar = expr2pcsgrammar(\n\tbegin\n\t\t0.5 : R = x\n\t\t0.3 : R = 1 | 2\n\t\t0.2 : R = R + R\n\tend\n)\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_childtypes-Tuple{Any, AbstractVector{Symbol}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_childtypes","text":"get_childtypes(rule::Any, types::AbstractVector{Symbol})\n\nReturns the child types/nonterminals of a production rule.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_domain-Tuple{Grammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.get_domain","text":"get_domain(g::Grammar, type::Symbol)::BitVector\n\nReturns the domain for the hole of a certain type as a BitVector of the same length as the number of  rules in the grammar. Bit i is set to true iff rule i is of type type.\n\ninfo: Info\nSince this function can be intensively used when exploring a program space defined by a grammar, the outcomes of this function are precomputed and stored in the domains field in a Grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_domain-Tuple{Grammar, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_domain","text":"get_domain(g::Grammar, rules::Vector{Int})::BitVector\n\nTakes a domain rules defined as a vector of ints and converts it to a domain defined as a BitVector.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_node_at_location-Tuple{RuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_node_at_location","text":"get_node_at_location(root::RuleNode, location::Vector{Int})\n\nRetrieves a RuleNode at the given location by reference. \n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.get_rulesequence-Tuple{RuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.get_rulesequence","text":"get_rulesequence(node::RuleNode, path::Vector{Int})\n\nExtract the derivation sequence from a path (sequence of child indices) and an AbstractRuleNode. If the path is deeper than the deepest node, it returns what it has.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.has_children-Tuple{RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.has_children","text":"has_children(node::RuleNode)\n\nReturns true if node has children\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iscomplete-Tuple{Grammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.iscomplete","text":"iscomplete(grammar::Grammar, node::RuleNode)\n\nReturns true if the expression represented by the RuleNode is a complete expression,  meaning that it is fully defined and doesn't have any Holes.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{Any}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(rule)\n\nReturns true if the rule is the special evaluate immediately function, i.e., _()\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{Grammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(grammar::Grammar, index::Int)::Bool\n\nReturns true if the production rule at rule_index contains the special _() eval function.\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.iseval-Tuple{Grammar}","page":"HerbGrammar.jl","title":"HerbGrammar.iseval","text":"iseval(grammar::Grammar)::Bool\n\nReturns true if any production rules in grammar contain the special _() eval function.\n\ncompat: Compat\nevaluate immediately functionality is not yet supported by most of Herb.jl\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isprobabilistic-Tuple{Grammar}","page":"HerbGrammar.jl","title":"HerbGrammar.isprobabilistic","text":"isprobabilistic(grammar::Grammar)::Bool\n\nFunction returns whether a Grammar is probabilistic.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{Any, AbstractVector{Symbol}}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(rule::Any, types::AbstractVector{Symbol})\n\nReturns true if the rule is terminal, i.e., it does not contain any of the types in the provided vector. For example, :(x) is terminal, and :(1+1) is terminal, but :(Real + Real) is typically not.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{Grammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(grammar::Grammar, rule_index::Int)::Bool\n\nReturns true if the production rule at rule_index is terminal, i.e., does not contain any nonterminal symbols.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isterminal-Tuple{Grammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.isterminal","text":"isterminal(grammar::Grammar, node::RuleNode)::Bool\n\nReturns true if the production rule used by node is terminal, i.e., does not contain any nonterminal symbols.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.isvariable-Tuple{Grammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.isvariable","text":"isvariable(grammar::Grammar, node::RuleNode)::Bool\n\nReturns true if the rule used by node represents a variable.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.log_probability-Tuple{Grammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.log_probability","text":"log_probability(grammar::Grammar, index::Int)::Real\n\nReturns the log probability for the rule at index in the grammar.\n\nwarning: Warning\nIf the grammar is not probabilistic, a warning is displayed, and a uniform probability is assumed.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.max_arity-Tuple{Grammar}","page":"HerbGrammar.jl","title":"HerbGrammar.max_arity","text":"max_arity(grammar::Grammar)::Int\n\nReturns the maximum arity (number of children) over all production rules in the Grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.mindepth-Tuple{Grammar, Symbol, AbstractVector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.mindepth","text":"mindepth(grammar::Grammar, typ::Symbol, dmap::AbstractVector{Int})\n\nReturns the minimum depth achievable for a given nonterminal symbol. The minimum depth is the depth of the lowest tree that can be made using typ  as a start symbol. dmap can be obtained from mindepth_map.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.mindepth_map-Tuple{Grammar}","page":"HerbGrammar.jl","title":"HerbGrammar.mindepth_map","text":"mindepth_map(grammar::Grammar)\n\nReturns the minimum depth achievable for each production rule in the Grammar. In other words, this function finds the depths of the lowest trees that can be made  using each of the available production rules as a root.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nchildren-Tuple{Grammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.nchildren","text":"nchildren(grammar::Grammar, rule_index::Int)::Int\n\nReturns the number of children (nonterminals) of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nchildren-Tuple{Grammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.nchildren","text":"nchildren(grammar::Grammar, node::RuleNode)::Int\n\nReturns the number of children in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.nonterminals-Tuple{Grammar}","page":"HerbGrammar.jl","title":"HerbGrammar.nonterminals","text":"nonterminals(grammar::Grammar)::Vector{Symbol}\n\nReturns a list of the nonterminals or types in the Grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.probability-Tuple{Grammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.probability","text":"probability(grammar::Grammar, index::Int)::Real\n\nReturn the probability for a rule in the grammar. Use log_probability whenever possible.\n\nwarning: Warning\nIf the grammar is not probabilistic, a warning is displayed, and a uniform probability is assumed.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.read_cfg-Tuple{AbstractString}","page":"HerbGrammar.jl","title":"HerbGrammar.read_cfg","text":"read_cfg(filepath::AbstractString)::ContextFreeGrammar\n\nReads a ContextFreeGrammar from the file provided in filepath.\n\ndanger: Danger\nOnly open trusted grammars.  Parts of the grammar can be passed to Julia's eval function.  \n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.read_csg-Tuple{AbstractString, AbstractString}","page":"HerbGrammar.jl","title":"HerbGrammar.read_csg","text":"read_csg(grammarpath::AbstractString, constraintspath::AbstractString)::ContextSensitiveGrammar\n\nReads a ContextSensitiveGrammar from the files at grammarpath and constraintspath. The grammar path may also point to a ContextFreeGrammar.\n\ndanger: Danger\nOnly open trusted grammars.  Parts of the grammar can be passed to Julia's eval function.  \n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.read_pcfg-Tuple{AbstractString}","page":"HerbGrammar.jl","title":"HerbGrammar.read_pcfg","text":"read_pcfg(filepath::AbstractString)::ContextFreeGrammar\n\nReads a probabilistic ContextFreeGrammar from a file provided in filepath.\n\ndanger: Danger\nOnly open trusted grammars.  Parts of the grammar can be passed to Julia's eval function.  \n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.read_pcsg-Tuple{AbstractString, AbstractString}","page":"HerbGrammar.jl","title":"HerbGrammar.read_pcsg","text":"read_pcsg(grammarpath::AbstractString, constraintspath::AbstractString)::ContextSensitiveGrammar\n\nReads a probabilistic ContextSensitiveGrammar from the files at grammarpath and constraintspath. The grammar path may also point to a ContextFreeGrammar.\n\ndanger: Danger\nOnly open trusted grammars.  Parts of the grammar can be passed to Julia's eval function.  \n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.remove_rule!-Tuple{Grammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.remove_rule!","text":"remove_rule!(g::Grammar, idx::Int)\n\nRemoves the rule corresponding to idx from the grammar.  In order to avoid shifting indices, the rule is replaced with nothing, and all other data structures are updated accordingly.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.return_type-Tuple{Grammar, Int64}","page":"HerbGrammar.jl","title":"HerbGrammar.return_type","text":"return_type(grammar::Grammar, rule_index::Int)::Symbol\n\nReturns the type of the production rule at rule_index.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.return_type-Tuple{Grammar, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.return_type","text":"return_type(grammar::Grammar, node::RuleNode)\n\nGives the return type or nonterminal symbol in the production rule used by node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.root_node_loc-Tuple{RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.root_node_loc","text":"rootnodeloc(root::RuleNode) Returns a NodeLoc pointing to the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulenode2expr-Tuple{RuleNode, Grammar}","page":"HerbGrammar.jl","title":"HerbGrammar.rulenode2expr","text":"rulenode2expr(rulenode::RuleNode, grammar::Grammar)\n\nConverts a RuleNode into a Julia expression corresponding to the rule definitions in the grammar. The returned expression can be evaluated with Julia semantics using eval().\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulenode_log_probability-Tuple{RuleNode, Grammar}","page":"HerbGrammar.jl","title":"HerbGrammar.rulenode_log_probability","text":"Calculates the log probability associated with a rulenode in a probabilistic grammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Grammar, Symbol, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesoftype","text":"rulesoftype(node::RuleNode, grammar::Grammar, ruletype::Symbol, ignoreNode::RuleNode)\n\nReturns every rule of nonterminal symbol ruletype that is also used in the AbstractRuleNode tree, but not in the ignoreNode subtree.\n\nwarning: Warning\nThe ignoreNode must be a subtree of node for it to have an effect.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Grammar, Symbol}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesoftype","text":"rulesoftype(node::RuleNode, grammar::Grammar, ruletype::Symbol)\n\nReturns every rule of nonterminal symbol ruletype that is also used in the AbstractRuleNode tree.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesoftype-Tuple{RuleNode, Set{Int64}, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesoftype","text":"rulesoftype(node::RuleNode, ruleset::Set{Int}, ignoreNode::RuleNode)\n\nReturns every rule in the ruleset that is also used in the AbstractRuleNode tree, but not in the ignoreNode subtree.\n\nwarning: Warning\nThe ignoreNode must be a subtree of node for it to have an effect.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.rulesonleft-Tuple{RuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.rulesonleft","text":"rulesonleft(expr::RuleNode, path::Vector{Int})::Set{Int}\n\nFinds all rules that are used in the left subtree defined by the path.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.store_cfg-Tuple{AbstractString, ContextFreeGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.store_cfg","text":"store_cfg(filepath::AbstractString, grammar::ContextFreeGrammar)\n\nWrites a ContextFreeGrammar to the file provided by filepath.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.store_csg-Tuple{AbstractString, AbstractString, ContextSensitiveGrammar}","page":"HerbGrammar.jl","title":"HerbGrammar.store_csg","text":"store_csg(grammarpath::AbstractString, constraintspath::AbstractString, g::ContextSensitiveGrammar)\n\nWrites a ContextSensitiveGrammar to the files at grammarpath and constraintspath. The grammarpath file will contain a ContextSensitiveGrammar definition, and the constraintspath file will contain the Constraints of the ContextSensitiveGrammar.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.subsequenceof-Tuple{Vector{Int64}, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.subsequenceof","text":"subsequenceof(vec1::Vector{Int}, vec2::Vector{Int})\n\nChecks if vec1 is a subsequence of vec2.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.swap_node-Tuple{AbstractRuleNode, AbstractRuleNode, Vector{Int64}}","page":"HerbGrammar.jl","title":"HerbGrammar.swap_node","text":"swap_node(expr::AbstractRuleNode, new_expr::AbstractRuleNode, path::Vector{Int})\n\nReplace a node in expr, specified by path, with new_expr. Path is a sequence of child indices, starting from the root node.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#HerbGrammar.swap_node-Tuple{RuleNode, RuleNode, Int64, RuleNode}","page":"HerbGrammar.jl","title":"HerbGrammar.swap_node","text":"swap_node(expr::RuleNode, node::RuleNode, child_index::Int, new_expr::RuleNode)\n\nReplace child i of a node, a part of larger expr, with new_expr.\n\n\n\n\n\n","category":"method"},{"location":"HerbGrammar/#Index","page":"HerbGrammar.jl","title":"Index","text":"","category":"section"},{"location":"HerbGrammar/","page":"HerbGrammar.jl","title":"HerbGrammar.jl","text":"","category":"page"}]
}
